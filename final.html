<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#212121">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;600;700&family=Montserrat:wght@500;700&display=swap" rel="stylesheet">
    <link rel="manifest" href="manifest.json">
    <link rel="stylesheet" href="safedrive-responsive.css?v=20260223">
    <title>EASY RIDE 180</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <script type="module" src="avatar-editor.js?v=20260227"></script>
    <script src="https://api-maps.yandex.ru/v3/?apikey=7f7db9e2-0eff-47d4-98d3-59b326552ed7&lang=ru_RU"></script>
    <script src="https://api-maps.yandex.ru/2.1/?apikey=7f7db9e2-0eff-47d4-98d3-59b326552ed7&lang=ru_RU"></script>
    <style>
        :root {
            --bg: #0d0d0d;
            --blue: #00d4ff; /* Electric Blue */
            --neon: #39ff14; /* Neon Green */
            --gray: rgba(255,255,255,0.65);
            --text-primary: rgba(255, 255, 255, 0.92);
            --card: rgba(26, 26, 26, 0.72);
            --card-strong: rgba(26, 26, 26, 0.88);
            --stroke: rgba(255,255,255,0.10);
            --critical-outline: 0 1px 0 rgba(0,0,0,0.95), 0 -1px 0 rgba(0,0,0,0.95), 1px 0 0 rgba(0,0,0,0.95), -1px 0 0 rgba(0,0,0,0.95);
            --safe-area-inset-top: env(safe-area-inset-top);
            --safe-area-inset-bottom: env(safe-area-inset-bottom);
            --safe-area-inset-left: env(safe-area-inset-left);
            --safe-area-inset-right: env(safe-area-inset-right);
            /* iPhone 14 Pro / Redmi: сдвиг UI ниже системных элементов */
            --ui-safe-top: calc(env(safe-area-inset-top) + 20px);
        }
        body, html {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: 'Rajdhani','Montserrat',system-ui,-apple-system,'Segoe UI',Roboto,sans-serif;
            background: #0d0d0d;
            color: var(--text-primary);
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            text-rendering: geometricPrecision;
            letter-spacing: 0.03em;
        }

        h1, h2, h3, h4, h5, h6 {
            font-weight: 800;
            color: var(--blue);
            text-shadow: 0 0 14px rgba(0, 212, 255, 0.28), 0 1px 0 rgba(0,0,0,0.55);
        }

        /* Подписи кнопок */
        .main-btn,
        .chat-send-btn,
        .ptt-hold-btn,
        .type-tab-btn,
        .type-btn span {
            font-weight: 600;
            letter-spacing: 0.03em;
        }

        /* Критически важные данные: скорость/дистанция */
        .speedometer-value,
        #speedValue,
        .proximity-banner-distance,
        #warningDistanceLabel {
            text-shadow: var(--critical-outline);
        }
        
        /* Отключение выделения и улучшение тап-реакций */
        * {
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
        }
        
        body, html {
            position: fixed;
            -webkit-user-select: none;
            user-select: none;
        }
        
        /* ============= ЭКРАН ПРИВЕТСТВИЯ ============= */
        #splashScreen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(1200px 800px at 20% 15%, rgba(0,212,255,0.22) 0%, rgba(13,13,13,0.0) 55%),
                        radial-gradient(900px 600px at 85% 75%, rgba(57,255,20,0.14) 0%, rgba(13,13,13,0.0) 60%),
                        #0d0d0d;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.5s ease, visibility 0.5s ease, transform 0.5s ease;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
            overflow: hidden;
        }
        
        #splashScreen.hidden {
            opacity: 0;
            transform: translateY(-12px);
            visibility: hidden;
            pointer-events: none;
        }
        
        .splash-logo {
            width: 180px;
            height: 180px;
            margin-bottom: 30px;
            animation: logoFadeIn 0.8s ease-out, logoPulse 2s ease-in-out infinite 1s;
            filter: drop-shadow(0 10px 30px rgba(0,0,0,0.3));
        }
        
        .splash-greeting {
            color: white;
            font-size: 24px;
            font-weight: 700;
            text-align: center;
            margin-bottom: 10px;
            animation: textFadeIn 1s ease-out 0.3s both;
            text-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        
        .splash-username {
            color: rgba(255,255,255,0.9);
            font-size: 18px;
            font-weight: 500;
            text-align: center;
            animation: textFadeIn 1s ease-out 0.5s both;
            text-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }
        
        .splash-loader {
            margin-top: 40px;
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255,255,255,0.2);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes logoFadeIn {
            from {
                opacity: 0;
                transform: scale(0.8) translateY(-20px);
            }
            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }
        
        @keyframes logoPulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
        }
        
        @keyframes textFadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* ============= УВЕДОМЛЕНИЕ О БАНЕ ============= */
        .ban-notice { 
            display: none;
            position: fixed; 
            top: 0; 
            left: 0; 
            right: 0; 
            bottom: 0; 
            background: rgba(0,0,0,0.9); 
            z-index: 9999; 
            align-items: center; 
            justify-content: center;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }
        
        .ban-notice.active { display: flex; }
        
        .ban-notice-content { 
            background: rgba(18, 18, 22, 0.86);
            border-radius: 24px; 
            padding: 30px; 
            max-width: 420px; 
            width: 90%; 
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.55);
            border: 1px solid rgba(255,255,255,0.10);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            color: rgba(255,255,255,0.95);
        }
        
        .ban-notice-icon { 
            font-size: 64px; 
            margin-bottom: 20px; 
        }
        
        .ban-notice-title { 
            font-size: 24px; 
            font-weight: 800; 
            color: #ff3b30; 
            margin-bottom: 15px; 
        }
        
        .ban-notice-message { 
            font-size: 16px; 
            color: rgba(255,255,255,0.85);
            line-height: 1.5; 
            margin-bottom: 20px; 
        }
        
        .ban-notice-time { 
            font-size: 14px; 
            color: var(--gray); 
            margin-bottom: 25px; 
        }
        
        .unban-request-btn {
            width: 100%;
            background: var(--blue);
            color: white;
            border: none;
            border-radius: 14px;
            padding: 16px;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            margin-bottom: 10px;
        }
        
        .unban-request-btn:active { transform: scale(0.98); }
        
        .unban-request-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .unban-status {
            font-size: 13px;
            color: #34c759;
            margin-top: 10px;
            font-weight: 600;
        }
        #map { width: 100%; height: 100%; position: absolute; }
        .target {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 9999;
            pointer-events: none;
            width: 30px;
            height: 30px;
            transition: visibility 0.2s, opacity 0.2s;
            visibility: visible;
            opacity: 1;
        }
        .target::before {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 50%;
            border: 2px solid var(--blue);
            background: rgba(255,255,255,0.92);
            box-shadow: 0 4px 12px rgba(0,0,0,0.18);
        }
        .target::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ff3b30;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 0 2px rgba(255,255,255,0.95);
        }
        .bottom-ui, .action-panel {
            position: fixed;
            bottom: calc(10px + var(--safe-area-inset-bottom));
            left: 0;
            right: 0;
            z-index: 1550;
            padding: 0 10px;
            pointer-events: none; /* важно: не блокировать жесты карты невидимыми областями */
        }
        .action-card {
            background: rgba(0, 0, 0, 0.65);
            color: #fff;
            backdrop-filter: blur(8px);
            border-radius: 22px;
            padding: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.35);
            border: 1px solid rgba(255,255,255,0.10);
            position: relative;
            pointer-events: auto; /* панель кликабельна, контейнер вокруг — нет */
            transform: translateY(0);
            opacity: 1;
            transition: transform 0.3s ease, opacity 0.3s ease;
            will-change: transform, opacity;
        }
        .action-card.hidden {
            display: block;
            transform: translateY(120%);
            opacity: 0;
            pointer-events: none;
        }
        .action-card-close { position: absolute; top: 10px; right: 10px; background: none; border: none; font-size: 24px; cursor: pointer; color: var(--gray); padding: 4px 8px; display: flex; align-items: center; justify-content: center; border-radius: 8px; transition: all 0.2s; }
        .action-card-close:active { background: rgba(255,255,255,0.10); color: #fff; }
        .open-action-btn { position: fixed; bottom: calc(18px + var(--safe-area-inset-bottom)); left: 50%; transform: translateX(-50%); width: 48px; height: 48px; border-radius: 50%; background: white; border: 2px solid var(--blue); z-index: 1600; display: none; align-items: center; justify-content: center; font-size: 22px; box-shadow: 0 6px 18px rgba(0,0,0,0.12); cursor: pointer; }
        .open-action-btn.visible { display: flex; }
        .addr-label { font-size: 12px; color: #fff; font-weight: 800; margin-bottom: 10px; display: block; text-align: center; }
        .type-selector { display: flex; justify-content: space-between; margin-bottom: 12px; gap: 6px; flex-wrap: wrap; }
        .type-btn { 
            border: none; background: none; cursor: pointer; display: flex; flex-direction: column; 
            align-items: center; gap: 4px; width: 32%; padding: 6px; border-radius: 14px; 
            transition: all 0.3s ease; position: relative;
        }
        .type-btn:active { transform: scale(0.95); }
        .icon-circle { 
            width: 46px; height: 46px; background: #f0f0f5; border-radius: 14px; display: flex; 
            align-items: center; justify-content: center; border: 3px solid transparent; 
            transition: all 0.3s ease; font-size: 22px; box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }
        .type-btn span { font-size: 10px; font-weight: 800; color: var(--gray); text-transform: uppercase; letter-spacing: 0.3px; }
        .type-btn:hover .icon-circle { transform: translateY(-4px); box-shadow: 0 4px 12px rgba(0,0,0,0.12); }
        .type-btn.active { color: var(--blue); background: rgba(0, 122, 255, 0.08); }
        .type-btn.active .icon-circle { background: #fff; border-color: var(--blue); box-shadow: 0 2px 8px rgba(0, 122, 255, 0.3); }
        .type-tabs { display: flex; gap: 6px; margin-bottom: 8px; }
        .type-tab-btn { flex: 1; border: 1px solid rgba(255,255,255,0.15); background: rgba(255,255,255,0.06); color: rgba(255,255,255,0.78); border-radius: 12px; padding: 8px 10px; font-size: 11px; font-weight: 900; cursor: pointer; transition: all 0.3s ease; }
        .type-tab-btn.active { background: rgba(52,199,89,0.16); color: #fff; border-color: rgba(52,199,89,0.55); }
        .type-group { display: none; width: 100%; gap: 6px; flex-wrap: wrap; }
        .type-group.active { display: flex; }
        .type-group-title { width: 100%; font-size: 11px; font-weight: 800; margin: 4px 0 2px 0; }
        .type-group-title.patrol { color: #34c759; }
        .type-group-title.help { color: rgba(52,199,89,0.95); }
        
        /* Счётчик активных меток */
        .markers-counter { font-size: 11px; color: rgba(255,255,255,0.85); margin-bottom: 10px; text-align: center; padding: 8px; background: rgba(255,255,255,0.06); border-radius: 12px; border: 1px solid rgba(255,255,255,0.10); }
        .counter-item { display: inline-block; margin: 0 6px; }
        .counter-item span:first-child { font-weight: 700; color: var(--blue); }

        /* Погодный виджет (1 строка) */
        .weather-widget { font-size: 11px; color: rgba(255,255,255,0.85); margin-bottom: 10px; text-align: center; padding: 8px; background: rgba(255,255,255,0.06); border-radius: 12px; border: 1px solid rgba(255,255,255,0.10); }
        .weather-widget .weather-warn { font-weight: 800; }
        .main-btn { width: 100%; background: var(--blue); color: white; border: none; border-radius: 16px; padding: 14px; font-size: 15px; font-weight: 800; cursor: pointer; }
        .action-card .main-btn { background: var(--neon); color: #0b0b0b; font-weight: 900; transition: all 0.3s ease; }
        .action-card .main-btn:active { transform: scale(0.98); }
        .b-cont { font-size: 14px; line-height: 1.4; min-width: 170px; }
        .b-poll { display: flex; gap: 8px; margin-top: 10px; }
        .b-poll-btn { flex: 1; border: none; border-radius: 8px; padding: 8px; cursor: pointer; background: #f0f0f5; font-weight: bold; }
        .b-del { color: #ff3b30; border: none; background: none; font-size: 11px; margin-top: 12px; width: 100%; cursor: pointer; font-weight: bold; }
        
        /* Стили для профиля и личного кабинета */
        .profile-btn { position: absolute; top: calc(15px + var(--safe-area-inset-top)); right: calc(15px + var(--safe-area-inset-right)); z-index: 1500; width: 45px; height: 45px; border-radius: 50%; background: white; border: 2px solid var(--blue); cursor: pointer; font-size: 22px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
        .profile-btn:active { transform: scale(1.05); }
        /* Кнопка сообщения о баге */
        .feedback-btn { position: absolute; top: calc(15px + var(--safe-area-inset-top)); right: calc(70px + var(--safe-area-inset-right)); z-index: 1500; width: 45px; height: 45px; border-radius: 50%; background: white; border: 2px solid #dc3545; cursor: pointer; font-size: 20px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
        .feedback-btn:active { transform: scale(1.05); }
        /* Кнопка "Где я" */
        .loc-btn { position: absolute; top: calc(15px + var(--safe-area-inset-top)); right: calc(125px + var(--safe-area-inset-right)); z-index: 1500; width: 45px; height: 45px; border-radius: 50%; background: white; border: 2px solid var(--blue); cursor: pointer; font-size: 20px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); display: flex; align-items: center; justify-content: center; }
        .loc-btn:active { transform: scale(1.05); }
        .follow-toggle { position: absolute; top: calc(15px + var(--safe-area-inset-top)); right: calc(180px + var(--safe-area-inset-right)); z-index: 1500; width: 40px; height: 40px; border-radius: 50%; background: white; border: 2px solid #34c759; cursor: pointer; font-size: 16px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); display: flex; align-items: center; justify-content: center; }
        .follow-toggle.inactive { background: #fff; border-color: #ccc; color: #888; }
        .follow-toggle.active { background: #34c759; color: white; border-color: #34c759; }
        .follow-icon { display: inline-flex; align-items: center; justify-content: center; width: 100%; height: 100%; }
        .follow-badge { position: absolute; bottom: -2px; right: -2px; width: 16px; height: 16px; border-radius: 50%; background: #111; color: #fff; font-size: 9px; font-weight: 800; display: flex; align-items: center; justify-content: center; border: 2px solid #fff; box-shadow: 0 2px 6px rgba(0,0,0,0.25); }
        
        .modal { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 2500; overflow-y: auto; }
        .modal.active { display: block; }
        .modal-content {
            background: rgba(18, 18, 22, 0.86);
            color: rgba(255,255,255,0.95);
            border-radius: 20px;
            margin: 20px;
            padding: 20px;
            max-width: 520px;
            margin-left: auto;
            margin-right: auto;
            border: 1px solid rgba(255,255,255,0.10);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            box-shadow: 0 18px 60px rgba(0,0,0,0.55);
        }
        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
        .modal-close { background: none; border: none; font-size: 28px; cursor: pointer; color: rgba(255,255,255,0.70); }
        
        /* Админ-панель */
        .admin-btn { position: absolute; top: calc(15px + var(--safe-area-inset-top)); left: calc(15px + var(--safe-area-inset-left)); z-index: 1500; width: 45px; height: 45px; border-radius: 50%; background: #ff9500; border: 2px solid white; cursor: pointer; font-size: 22px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); display: none; }
        .admin-btn.visible { display: block; }
        .admin-btn:active { transform: scale(1.05); }

        /* ============= ГРУППИРОВКА КНОПОК (MONOLITH 180) ============= */
        .top-controls {
            position: fixed;
            top: calc(15px + var(--safe-area-inset-top));
            right: calc(15px + var(--safe-area-inset-right));
            z-index: 1600;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: flex-end;
        }

        .top-controls .profile-btn,
        .top-controls .admin-btn {
            position: relative;
            top: auto;
            right: auto;
            left: auto;
        }

        .fab-stack {
            position: fixed;
            right: calc(15px + var(--safe-area-inset-right));
            bottom: calc(18px + var(--safe-area-inset-bottom));
            z-index: 1600;
            display: flex;
            flex-direction: column;
            gap: 14px;
            align-items: flex-end;
        }

        .fab-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: flex-end;
        }


        /* ============= DRIVER ERGO UI (по ТЗ) ============= */
        #onlineCountBadge.online-count {
            position: fixed;
            top: calc(12px + var(--safe-area-inset-top));
            left: calc(12px + var(--safe-area-inset-left));
            z-index: 2000;
            display: none;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            border-radius: 16px;
            background: rgba(0,0,0,0.55);
            color: #fff;
            font-weight: 900;
            font-size: 13px;
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255,255,255,0.10);
            box-shadow: 0 10px 30px rgba(0,0,0,0.30);
            transition: opacity 0.3s ease;
        }
        #onlineCountBadge.online-count.visible { display: inline-flex; }
        #mapEngineBadge.engine-badge {
            position: fixed;
            top: calc(56px + var(--safe-area-inset-top));
            left: calc(12px + var(--safe-area-inset-left));
            z-index: 2000;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 7px 10px;
            border-radius: 12px;
            background: rgba(0,0,0,0.48);
            color: #fff;
            font-weight: 800;
            font-size: 11px;
            letter-spacing: 0.2px;
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255,255,255,0.10);
            box-shadow: 0 8px 24px rgba(0,0,0,0.28);
            transition: opacity 0.3s ease;
            pointer-events: none;
        }
        #mapEngineBadge.engine-badge.is-v3 { border-color: rgba(0,212,255,0.45); }
        #mapEngineBadge.engine-badge.is-v2 { border-color: rgba(255,149,0,0.45); }
        #map3dToggleFloating {
            position: fixed;
            top: calc(92px + var(--safe-area-inset-top));
            left: calc(12px + var(--safe-area-inset-left));
            z-index: 2000;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 52px;
            height: 30px;
            padding: 0 10px;
            border-radius: 12px;
            border: 1px solid rgba(245,198,66,0.55);
            background: rgba(0,0,0,0.86);
            color: #f5c64a;
            font-weight: 900;
            font-size: 11px;
            letter-spacing: 0.4px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.28);
            backdrop-filter: blur(8px);
            cursor: pointer;
            transition: box-shadow 0.25s ease, border-color 0.25s ease, color 0.25s ease;
        }
        #map3dToggleFloating.is-on {
            border-color: rgba(57,255,20,0.72);
            color: #b9ffb3;
            box-shadow: 0 0 0 1px rgba(57,255,20,0.25), 0 0 18px rgba(57,255,20,0.38), 0 8px 24px rgba(0,0,0,0.30);
        }
        .online-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--neon);
            box-shadow: 0 0 0 0 rgba(57,255,20,0.40);
            animation: onlinePulse 1.4s ease-in-out infinite;
        }
        @keyframes onlinePulse {
            0% { box-shadow: 0 0 0 0 rgba(57,255,20,0.40); }
            70% { box-shadow: 0 0 0 10px rgba(57,255,20,0.0); }
            100% { box-shadow: 0 0 0 0 rgba(57,255,20,0.0); }
        }

        .user-marker-wrap { position: relative; width: 100%; height: 100%; pointer-events: none; }
        .user-pulse {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            background: rgba(57,255,20,0.18);
            box-shadow: 0 0 0 0 rgba(57,255,20,0.30);
            filter: blur(0.2px);
            animation: userPulse 1.35s ease-out infinite;
        }
        @keyframes userPulse {
            0% { transform: translate(-50%, -50%) scale(0.75); opacity: 0.78; box-shadow: 0 0 0 0 rgba(57,255,20,0.30); }
            70% { opacity: 0.10; box-shadow: 0 0 0 18px rgba(57,255,20,0.0); }
            100% { transform: translate(-50%, -50%) scale(1.35); opacity: 0; box-shadow: 0 0 0 24px rgba(57,255,20,0.0); }
        }

        .right-bar {
            position: fixed;
            top: calc(12px + var(--safe-area-inset-top));
            right: calc(10px + var(--safe-area-inset-right));
            z-index: 2000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            transition: opacity 0.3s ease, transform 0.3s ease;
            pointer-events: none;
        }

        /* Чистый экран: когда открыта нижняя панель выбора (.action-panel) */
        .right-bar.hidden {
            opacity: 0;
            transform: translateX(100px);
            pointer-events: none;
        }

        .right-bar .action-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.14);
            background: rgba(0,0,0,0.55);
            color: #fff;
            font-size: 20px;
            font-weight: 900;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(8px);
            cursor: pointer;
            transition: transform 0.3s ease, background 0.3s ease, opacity 0.3s ease;
            box-shadow: 0 10px 30px rgba(0,0,0,0.28);
            pointer-events: auto;
        }
        .right-bar .action-btn:active { transform: scale(0.95); }

        .right-bar .action-btn.active { border-color: rgba(0,212,255,0.70); box-shadow: 0 0 0 3px rgba(0,212,255,0.16), 0 10px 30px rgba(0,0,0,0.28); }

        .right-bar .action-btn.off { opacity: 0.65; }

        .locate-btn {
            position: fixed;
            left: calc(25px + var(--safe-area-inset-left));
            bottom: calc(25px + var(--safe-area-inset-bottom));
            z-index: 2000;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.14);
            background: rgba(0,0,0,0.55);
            backdrop-filter: blur(8px);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: transform 0.3s ease, opacity 0.3s ease;
            box-shadow: 0 12px 34px rgba(0,0,0,0.35);
        }
        .locate-btn:active { transform: scale(0.95); }
        .locate-btn .locate-icon { color: var(--blue); font-size: 20px; line-height: 1; }
        .locate-btn.active .locate-icon { color: #34c759; }

        .ptt-btn.ptt-fab {
            position: fixed;
            right: calc(25px + var(--safe-area-inset-right));
            bottom: calc(25px + var(--safe-area-inset-bottom));
            z-index: 2000;
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: none;
            background: #34c759;
            color: #fff;
            font-size: 26px;
            font-weight: 900;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 16px 42px rgba(0,0,0,0.42);
            transition: transform 0.3s ease, background 0.3s ease, opacity 0.3s ease;
            backdrop-filter: blur(8px);
            touch-action: none;
            user-select: none;
        }
        .ptt-btn.ptt-fab:active { transform: scale(0.96); }
        .ptt-btn.ptt-fab.talking { background: #ff3b30; }
        .ptt-btn.ptt-fab.talking::after {
            content: '';
            position: absolute;
            inset: -10px;
            border-radius: 50%;
            border: 2px solid rgba(255,59,48,0.55);
            animation: pttWave 0.95s ease-out infinite;
        }
        @keyframes pttWave {
            0% { transform: scale(0.85); opacity: 0.75; }
            100% { transform: scale(1.35); opacity: 0; }
        }

        /* Прячем старые плавающие элементы, чтобы интерфейс соответствовал ТЗ */
        .top-controls, .fab-stack, .follow-toggle, .feedback-btn { display: none !important; }
        .fab-row {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: flex-end;
            width: 100%;
        }

        /* Все кнопки внутри стека становятся относительными */
        .fab-stack .chat-btn,
        .fab-stack .loc-btn {
            position: relative;
            bottom: auto;
            right: auto;
            top: auto;
            left: auto;
        }

        /* Оперативные: рация самая крупная, чат под ней */
        .fab-stack .fab-ptt {
            width: 68px;
            height: 68px;
            font-size: 28px;
        }

        .fab-stack .fab-chat {
            width: 52px;
            height: 52px;
            font-size: 24px;
        }

        /* Навигационные: слои меньше, центрирование обычное */
        .fab-stack .layers-btn {
            width: 46px;
            height: 46px;
            font-size: 18px;
        }

        .fab-stack .loc-btn {
            width: 52px;
            height: 52px;
            font-size: 20px;
            border: 2px solid var(--blue);
        }
        
        .admin-table { width: 100%; border-collapse: collapse; margin-top: 15px; }
        .admin-table th, .admin-table td { padding: 12px; text-align: left; border-bottom: 1px solid #ddd; font-size: 12px; }
        .admin-table th { background: #f0f0f5; font-weight: 600; }
        .admin-table tr:hover { background: #f9f9f9; }
        
        .delete-btn { background: #ff3b30; color: white; border: none; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 11px; font-weight: bold; }
        .delete-btn:active { background: #e63027; }
        
        .admin-stats { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px; }
        .admin-stat-card { background: #f0f0f5; border-radius: 12px; padding: 15px; text-align: center; }
        .admin-stat-card .value { font-size: 28px; font-weight: 800; color: var(--blue); }
        .admin-stat-card .label { font-size: 12px; color: var(--gray); margin-top: 5px; }
        
        /* Стили для фильтров запросов на разбан */
        .filter-btn { transition: all 0.2s; }
        .filter-btn:active { transform: scale(0.95); }
        .filter-btn.active { opacity: 1; }
        .filter-btn:not(.active) { opacity: 0.6; }
        
        /* Кнопки модерации в профиле */
        .moderation-section { margin-top: 20px; padding-top: 20px; border-top: 2px solid #f0f0f5; }
        .moderation-title { font-size: 14px; font-weight: 700; color: #333; margin-bottom: 12px; text-align: center; }
        .moderation-buttons { display: flex; gap: 10px; }
        .mod-btn { flex: 1; border: none; padding: 12px; border-radius: 12px; font-size: 13px; font-weight: 700; cursor: pointer; transition: all 0.2s; display: flex; align-items: center; justify-content: center; gap: 6px; }
        .mod-btn:active { transform: scale(0.95); }
        .mod-btn-temp { background: #ff9500; color: white; }
        .mod-btn-temp:hover { background: #e68600; }
        .mod-btn-perm { background: #ff3b30; color: white; }
        .mod-btn-perm:hover { background: #e63027; }
        .mod-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        
        /* Модальное окно для временного бана */
        .ban-duration-modal { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.6); z-index: 3000; align-items: center; justify-content: center; }
        .ban-duration-modal.active { display: flex; }
        .ban-duration-content { background: white; border-radius: 20px; padding: 25px; max-width: 350px; width: 90%; }
        .ban-duration-title { font-size: 18px; font-weight: 700; margin-bottom: 15px; text-align: center; }
        .ban-options { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px; }
        .ban-option { background: #f0f0f5; border: 2px solid transparent; padding: 12px; border-radius: 12px; cursor: pointer; text-align: center; font-size: 13px; font-weight: 600; transition: all 0.2s; }
        .ban-option:hover { background: #e5e5ea; }
        .ban-option.selected { background: #fff; border-color: #ff9500; color: #ff9500; }
        .ban-option .duration { display: block; font-size: 16px; font-weight: 700; margin-bottom: 4px; }
        .ban-option .label { display: block; font-size: 11px; color: var(--gray); }
        .ban-actions { display: flex; gap: 10px; }
        .ban-confirm-btn, .ban-cancel-btn { flex: 1; border: none; padding: 12px; border-radius: 12px; font-size: 14px; font-weight: 700; cursor: pointer; }
        .ban-confirm-btn { background: #ff9500; color: white; }
        .ban-cancel-btn { background: #f0f0f5; color: #333; }
        
        /* Чат */
        .chat-btn { position: absolute; bottom: calc(100px + var(--safe-area-inset-bottom)); right: calc(15px + var(--safe-area-inset-right)); z-index: 1500; width: 50px; height: 50px; border-radius: 50%; background: var(--blue); border: 2px solid white; cursor: pointer; font-size: 24px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); display: flex; align-items: center; justify-content: center; }
        .chat-btn:hover { transform: scale(1.05); }
        .chat-btn:active { transform: scale(0.95); }
        .fab-chat { bottom: calc(100px + var(--safe-area-inset-bottom)); }
        .fab-heatmap { bottom: calc(220px + var(--safe-area-inset-bottom)); }
        .fab-heatmap-patrol { bottom: calc(160px + var(--safe-area-inset-bottom)); }
        .fab-ptt { bottom: calc(130px + var(--safe-area-inset-bottom)); }
        .fab-notif { bottom: calc(280px + var(--safe-area-inset-bottom)); }
        .fab-activity { bottom: calc(340px + var(--safe-area-inset-bottom)); }
        @media (max-height: 760px) {
            .fab-heatmap { bottom: calc(205px + var(--safe-area-inset-bottom)); }
            .fab-heatmap-patrol { bottom: calc(150px + var(--safe-area-inset-bottom)); }
            .fab-ptt { bottom: calc(125px + var(--safe-area-inset-bottom)); }
            .fab-notif { bottom: calc(260px + var(--safe-area-inset-bottom)); }
            .fab-activity { bottom: calc(315px + var(--safe-area-inset-bottom)); }
        }
        .ptt-btn { background: #34c759; font-size: 20px; }
        .ptt-hold-btn {
            width: 100%;
            height: 68px;
            border-radius: 16px;
            border: none;
            background: #34c759;
            color: #fff;
            font-size: 16px;
            font-weight: 800;
            cursor: pointer;
            user-select: none;
            touch-action: manipulation;
        }
        .ptt-hold-btn.disabled { background: #9ca3af; cursor: not-allowed; }
        .ptt-hold-btn.busy { background: #6b7280; cursor: not-allowed; }
        .ptt-status { font-size: 12px; color: #111; margin-top: 10px; text-align:center; }
        .ptt-sub { font-size: 11px; color: var(--gray); margin-top: 6px; text-align:center; }
        .ptt-actions { display:flex; gap:10px; margin-top: 12px; }
        .ptt-complain {
            flex: 1;
            height: 44px;
            border-radius: 12px;
            border: 1px solid #ddd;
            background: #fff;
            font-weight: 800;
            cursor: pointer;
        }
        .ptt-complain:disabled { opacity: 0.5; cursor: not-allowed; }

        /* Crowdsourcing quick confirm ("Тут ещё стоят?") */
        .crowd-confirm {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            bottom: calc(100px + var(--safe-area-inset-bottom));
            z-index: 2100;
            width: min(92vw, 520px);
            background: rgba(255,255,255,0.98);
            backdrop-filter: blur(14px);
            border-radius: 18px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.18);
            border: 1px solid rgba(0,0,0,0.06);
            padding: 12px;
            display: none;
        }
        .crowd-confirm.active { display: block; }
        .crowd-confirm-title { font-size: 13px; font-weight: 900; color: #111; text-align:center; }
        .crowd-confirm-sub { font-size: 11px; color: var(--gray); text-align:center; margin-top: 4px; }
        .crowd-confirm-actions { display:flex; gap:10px; margin-top: 10px; }
        .crowd-confirm-actions button {
            flex: 1;
            border: none;
            border-radius: 14px;
            padding: 12px;
            font-size: 14px;
            font-weight: 900;
            cursor: pointer;
        }
        .crowd-btn-yes { background: #34c759; color: #fff; }
        .crowd-btn-no { background: #ff3b30; color: #fff; }
        .crowd-btn-skip { background: #f0f0f5; color: #111; flex: 0.8; }
        .notif-btn { background: #5856d6; }
        .notif-badge { position: absolute; top: -4px; right: -4px; min-width: 18px; height: 18px; border-radius: 9px; background: #ff3b30; color: #fff; font-size: 10px; font-weight: 800; line-height: 18px; text-align: center; border: 2px solid #fff; display: none; padding: 0 4px; box-sizing: border-box; }
        .notif-toast-wrap { position: absolute; top: calc(58px + var(--safe-area-inset-top)); left: 50%; transform: translateX(-50%); z-index: 1900; width: min(92vw, 440px); pointer-events: none; }
        .notif-toast { background: rgba(17,17,17,0.95); color: #fff; border-radius: 12px; padding: 10px 12px; box-shadow: 0 8px 20px rgba(0,0,0,0.25); font-size: 12px; margin-bottom: 8px; opacity: 0; transform: translateY(-8px); transition: all .2s ease; }
        .notif-toast.visible { opacity: 1; transform: translateY(0); }
        .notif-row { display: flex; gap: 10px; align-items: flex-start; padding: 10px; border: 1px solid #ececf1; border-radius: 12px; margin-bottom: 8px; background: #fff; cursor: pointer; }
        .notif-row.unread { border-color: #cfe1ff; background: #f7fbff; }
        .notif-icon { font-size: 20px; line-height: 1; }
        .notif-title { font-size: 13px; font-weight: 700; color: #111; }
        .notif-body { font-size: 12px; color: #555; margin-top: 2px; }
        .notif-time { font-size: 10px; color: #999; margin-top: 4px; }
        .heatmap-toggle-btn { background: #ff9f0a; font-size: 18px; }
        .heatmap-toggle-btn.active { background: #ff3b30; box-shadow: 0 0 0 3px rgba(255,59,48,0.18), 0 8px 22px rgba(255,59,48,0.28); }
        .activity-btn { background: #007aff; font-size: 18px; }
        #mapDimmingOverlay {
            position: absolute;
            inset: 0;
            z-index: 1200;
            pointer-events: none;
            background: rgba(28, 28, 30, 0.30);
            opacity: 0;
            transition: opacity .25s ease;
            backdrop-filter: grayscale(0.55) contrast(0.9);
        }
        #mapDimmingOverlay.active { opacity: 1; }
        
        .chat-messages { display: flex; flex-direction: column; gap: 10px; margin-bottom: 15px; max-height: 400px; overflow-y: auto; padding: 10px; background: #f9f9f9; border-radius: 12px; }
        .chat-message { padding: 10px 12px; border-radius: 10px; font-size: 13px; max-width: 80%; word-wrap: break-word; }
        .chat-message.own { background: var(--blue); color: white; margin-left: auto; }
        .chat-message.other { background: white; border: 1px solid #ddd; }
        .chat-message-author { font-size: 11px; font-weight: 600; margin-bottom: 3px; opacity: 0.8; }
        .chat-message-photo { max-width: 200px; border-radius: 8px; margin-top: 5px; cursor: pointer; }
        .chat-message-time { font-size: 10px; opacity: 0.7; margin-top: 3px; }
        
        .chat-input-group { display: flex; gap: 8px; }
        .chat-input { flex: 1; padding: 10px; border: 1px solid #ddd; border-radius: 10px; font-size: 14px; box-sizing: border-box; }
        .chat-send-btn { background: var(--blue); color: white; border: none; padding: 10px 15px; border-radius: 10px; cursor: pointer; font-weight: 600; font-size: 14px; }
        .chat-send-btn:hover { background: #0051d5; }
        
        .chat-photo-upload { position: relative; }
        .chat-photo-input { display: none; }
        .chat-photo-btn { background: #f0f0f5; color: var(--blue); border: none; padding: 10px; border-radius: 10px; cursor: pointer; font-size: 16px; }
        .chat-photo-btn:hover { background: #e0e0e5; }
        
        /* Контекстное меню для сообщений */
        .chat-context-menu {
            position: fixed;
            background: white;
            border: 1px solid #ddd;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 9999;
            min-width: 180px;
            padding: 8px 0;
        }
        .chat-context-menu-item {
            padding: 10px 15px;
            cursor: pointer;
            border: none;
            background: none;
            width: 100%;
            text-align: left;
            font-size: 14px;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .chat-context-menu-item:hover { background: #f0f0f5; }
        .chat-context-menu-item.delete { color: #ff3b30; }
        .chat-context-menu-item.report { color: #ff9500; }
        
        /* Меню модерации для админа */
        .moderator-menu {
            animation: slideIn 0.15s ease-out;
        }
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: scale(0.9);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }
        
        /* Форма регистрации */
        .registration-form input { width: 100%; padding: 12px; margin-bottom: 10px; border: 1px solid #ddd; border-radius: 10px; font-size: 14px; box-sizing: border-box; }
        .registration-form label { display: block; font-weight: 600; margin-bottom: 5px; font-size: 13px; color: #000; }
        .registration-form .form-group { margin-bottom: 15px; }
        
        /* Стили профиля */
        .profile-header { text-align: center; margin-bottom: 20px; }
        .profile-avatar { width: 80px; height: 80px; background: var(--blue); border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-size: 40px; margin: 0 auto 15px; }
        .profile-name { font-size: 20px; font-weight: 800; color: #000; margin-bottom: 5px; }
        .profile-name.trusted { color: #b8860b; text-shadow: 0 1px 0 rgba(0,0,0,0.15); }
        .profile-id { font-size: 12px; color: var(--gray); }
        
        /* Уровень взаимовыручки */
        .rating-card { background: linear-gradient(135deg, var(--blue), #5ac8fa); border-radius: 15px; padding: 15px; color: white; margin-bottom: 15px; }
        .rating-value { font-size: 36px; font-weight: 800; }
        .rating-label { font-size: 12px; opacity: 0.9; }
        
        .stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px; }
        .stat-item { background: #f0f0f5; border-radius: 12px; padding: 12px; text-align: center; }
        .stat-value { font-size: 24px; font-weight: 800; color: var(--blue); }
        .stat-label { font-size: 11px; color: var(--gray); margin-top: 5px; }
        
        /* Стили ленты событий */
        .activity-item { padding: 10px; border-bottom: 1px solid #e0e0e0; font-size: 12px; line-height: 1.4; }
        .activity-item:last-child { border-bottom: none; }
        .activity-time { font-size: 10px; color: var(--gray); margin-top: 4px; }
        .activity-icon { margin-right: 6px; }

        /* Тепловая карта активности */
        .activity-heatmap { background: #f9f9f9; border-radius: 14px; padding: 12px; border: 1px solid #e6e6ea; margin-bottom: 12px; }
        .heatmap-header { display: flex; align-items: center; justify-content: space-between; gap: 10px; margin-bottom: 8px; }
        .heatmap-title { font-size: 13px; font-weight: 800; color: #111; }
        .heatmap-toggle { display: inline-flex; background: #fff; border-radius: 10px; border: 1px solid #e0e0e0; overflow: hidden; }
        .heatmap-toggle button { border: none; background: none; padding: 6px 10px; font-size: 11px; font-weight: 700; cursor: pointer; color: #666; }
        .heatmap-toggle button.active { background: var(--blue); color: #fff; }
        .heatmap-legend { display: flex; align-items: center; gap: 6px; font-size: 10px; color: #666; margin-bottom: 8px; }
        .heatmap-legend .chip { width: 14px; height: 14px; border-radius: 4px; background: #f0f0f5; border: 1px solid #e0e0e0; }
        .heatmap-scroll { overflow-x: auto; padding-bottom: 6px; }
        .heatmap-grid { display: grid; grid-template-columns: 40px repeat(24, 16px); gap: 4px; align-items: center; }
        .heatmap-cell { width: 16px; height: 16px; border-radius: 4px; background: #f0f0f5; border: 1px solid #e6e6ea; }
        .heatmap-label { font-size: 10px; color: #666; text-align: right; padding-right: 4px; white-space: nowrap; }
        .heatmap-hour { font-size: 9px; color: #888; text-align: center; }
        .heatmap-summary { font-size: 11px; color: #666; margin-top: 6px; text-align: right; }
        
        /* Достижения (Cyberpunk / Dark Premium) */
        #profile-achievements-block { border-top: 1px solid rgba(255,255,255,0.10) !important; }
        .achievement-grid { display: flex; flex-wrap: wrap; gap: 8px; }
        .achievement {
            display: inline-flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 10px 10px;
            margin: 0;
            border-radius: 14px;
            font-size: 11px;
            min-width: 86px;
            min-height: 86px;
            background:
                linear-gradient(var(--card), var(--card)) padding-box,
                linear-gradient(135deg, rgba(0,212,255,0.65), rgba(57,255,20,0.45)) border-box;
            border: 1px solid transparent;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            box-shadow: 0 12px 34px rgba(0,0,0,0.45);
            transition: transform .25s ease, opacity .25s ease, filter .25s ease;
        }
        .achievement:active { transform: scale(0.98); }
        .achievement-icon { margin-bottom: 6px; line-height: 1; color: rgba(210,220,232,0.92); filter: drop-shadow(0 6px 16px rgba(0,0,0,0.35)); }
        .achievement-icon svg { width: 26px; height: 26px; display: block; }
        .achievement-title { font-weight: 800; color: rgba(255,255,255,0.92); }
        .achievement-progress { font-size: 10px; color: rgba(255,255,255,0.65); margin-top: 3px; }
        .achievement.done {
            filter: saturate(1.15) brightness(1.03);
            box-shadow: 0 0 0 2px rgba(0,212,255,0.10), 0 12px 34px rgba(0,0,0,0.45);
        }
        .achievement.done .achievement-icon { color: rgba(0,212,255,0.95); }
        .achievement.locked { opacity: 0.55; }

        /* Спидометр */
        .speedometer { position: absolute; left: 12px; bottom: calc(140px + var(--safe-area-inset-bottom)); z-index: 1600; background: rgba(0,0,0,0.55); border-radius: 16px; padding: 10px 12px; box-shadow: 0 10px 26px rgba(0,0,0,0.35); border: 1px solid rgba(255,255,255,0.10); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); display: none; align-items: center; gap: 10px; min-width: 120px; }
        .speedometer.visible { display: flex; }
        .speedometer-value { font-size: 22px; font-weight: 800; color: var(--text-primary); line-height: 1; }
        .speedometer-unit { font-size: 11px; color: rgba(255,255,255,0.70); margin-left: 4px; font-weight: 700; }
        .speedometer-label { font-size: 10px; color: rgba(255,255,255,0.65); font-weight: 600; }
        .speedometer-toggle { position: absolute; top: -8px; right: -8px; width: 24px; height: 24px; border-radius: 50%; border: none; background: #ff3b30; color: white; font-size: 14px; cursor: pointer; box-shadow: 0 4px 10px rgba(0,0,0,0.2); }
        .speedometer-open-btn { position: absolute; left: 12px; bottom: calc(140px + var(--safe-area-inset-bottom)); z-index: 1600; width: 40px; height: 40px; border-radius: 50%; background: rgba(0,0,0,0.55); color: var(--text-primary); border: 1px solid rgba(255,255,255,0.12); display: none; align-items: center; justify-content: center; font-size: 18px; box-shadow: 0 10px 26px rgba(0,0,0,0.35); cursor: pointer; backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); }
        .speedometer-open-btn.visible { display: flex; }

        /* Админский маркер и имя */
        .admin-marker { background: radial-gradient(circle at 30% 28%, #fff8d6 0%, #f3d57a 38%, #b7851f 100%); border-radius: 50%; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; border: 2px solid #f5d76e; font-size: 18px; position: relative; box-shadow: 0 0 0 2px rgba(0,0,0,0.12), 0 0 16px rgba(245, 198, 66, 0.7), 0 8px 18px rgba(0,0,0,0.28); }
        .admin-marker::before { content: ''; position: absolute; inset: -12px; border-radius: 50%; background: radial-gradient(circle, rgba(245,198,66,0.45) 0%, rgba(245,198,66,0.0) 72%); }
        .admin-marker::after { content: ''; position: absolute; inset: -7px; border-radius: 50%; border: 2px solid rgba(245, 198, 66, 0.58); animation: adminPulse 1.6s ease-out infinite; }
        .admin-marker--map { width: 34px; height: 34px; font-size: 18px; }
        .admin-marker--self { width: 36px; height: 36px; font-size: 19px; }
        .admin-marker-core { position: relative; z-index: 1; text-shadow: 0 1px 0 rgba(255,255,255,0.45), 0 0 8px rgba(0,0,0,0.25); }
        .admin-marker-badge { position: absolute; top: -9px; right: -9px; min-width: 16px; height: 16px; padding: 0 3px; border-radius: 999px; font-size: 11px; line-height: 16px; text-align: center; font-weight: 900; color: #2d1a00; background: linear-gradient(135deg, #fff0b3 0%, #f5c64a 52%, #c68d00 100%); border: 1px solid rgba(120,76,0,0.45); box-shadow: 0 2px 8px rgba(0,0,0,0.28); z-index: 2; }
        .admin-siren { position: absolute; top: -6px; width: 10px; height: 6px; border-radius: 6px; box-shadow: 0 2px 6px rgba(0,0,0,0.25); animation: adminSiren 1.2s ease-in-out infinite; }
        .admin-siren-left { left: -2px; background: #ff3b30; }
        .admin-siren-right { right: -2px; background: #007aff; animation-delay: 0.6s; }
        .admin-confirm { margin-top: 8px; padding: 6px 8px; border-radius: 8px; background: linear-gradient(135deg, #fff0b3 0%, #f5c64a 52%, #c68d00 100%); color: #2d1a00; font-size: 11px; font-weight: 900; text-align: center; border: 1px solid rgba(120,76,0,0.35); box-shadow: 0 4px 12px rgba(0,0,0,0.12); }
        .admin-name { background: linear-gradient(90deg, #fff0b3 0%, #f5c64a 55%, #b88400 100%); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; color: transparent; font-weight: 900; text-shadow: 0 1px 0 rgba(0,0,0,0.15); }
        .admin-rank { font-size: 11px; color: #d39d10; font-weight: 900; text-transform: uppercase; letter-spacing: 0.5px; }
        .admin-online { display: inline-flex; align-items: center; gap: 6px; font-size: 11px; color: #34c759; font-weight: 700; }
        .admin-online-dot { width: 6px; height: 6px; border-radius: 50%; background: #34c759; box-shadow: 0 0 6px rgba(52, 199, 89, 0.9); }
        .ym3-admin-marker-shell { width: 60px; height: 90px; display: flex; flex-direction: column; align-items: center; justify-content: flex-end; transform: translate3d(0, 0, 0); will-change: transform; pointer-events: none; }
        .ym3-admin-marker-crown { font-size: 16px; line-height: 1; margin-bottom: 2px; pointer-events: none; }
        .ym3-admin-marker-center { position: relative; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; pointer-events: none; }
        .ym3-admin-marker-pulse-bg { position: absolute; inset: 0; width: 40px; height: 40px; border-radius: 50%; background: radial-gradient(circle at 30% 25%, #fff8d7 0%, #f5c64a 45%, #b57a10 100%); border: 2px solid #fff; animation: adminPulse 1.6s ease-out infinite; }
        .ym3-admin-marker-icon { position: relative; z-index: 1; width: 24px; height: 24px; object-fit: contain; vector-effect: non-scaling-stroke; pointer-events: none; }
        .ym3-admin-marker-name { margin-top: 4px; padding: 2px 8px; border-radius: 999px; background: #000; color: #f5c64a; font-size: 10px; font-weight: 900; line-height: 1.2; white-space: nowrap; max-width: 120px; overflow: hidden; text-overflow: ellipsis; pointer-events: none; }

        /* Спецбат: визуально отличный маркер (неоновое мигание) */
        .specbat-marker {
            width: 34px;
            height: 34px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            background: rgba(12, 12, 16, 0.92);
            border: 2px solid rgba(0, 212, 255, 0.75);
            box-shadow:
                0 0 0 1px rgba(57, 255, 20, 0.12),
                0 0 18px rgba(0, 212, 255, 0.45);
            font-size: 18px;
            animation: specbatGlow 1.05s ease-in-out infinite;
        }
        .specbat-marker::before {
            content: '';
            position: absolute;
            inset: -10px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(0, 212, 255, 0.22) 0%, rgba(0, 212, 255, 0.0) 65%);
            opacity: 0.9;
            animation: specbatAura 1.05s ease-in-out infinite;
        }
        .specbat-marker::after {
            content: '';
            position: absolute;
            inset: -6px;
            border-radius: 50%;
            border: 2px solid rgba(57, 255, 20, 0.55);
            box-shadow: 0 0 18px rgba(57, 255, 20, 0.30);
            animation: specbatRing 0.85s ease-in-out infinite;
        }
        .specbat-badge {
            position: absolute;
            top: -8px;
            right: -9px;
            font-size: 10px;
            font-weight: 900;
            padding: 2px 5px;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.72);
            color: rgba(255,255,255,0.95);
            border: 1px solid rgba(0, 212, 255, 0.35);
            box-shadow: 0 6px 14px rgba(0,0,0,0.35);
            letter-spacing: 0.08em;
        }
        @keyframes specbatGlow {
            0%, 100% {
                filter: saturate(1.05) brightness(1.00);
                transform: scale(1);
                border-color: rgba(0, 212, 255, 0.70);
                box-shadow: 0 0 0 1px rgba(57, 255, 20, 0.10), 0 0 16px rgba(0, 212, 255, 0.35);
            }
            50% {
                filter: saturate(1.25) brightness(1.08);
                transform: scale(1.06);
                border-color: rgba(57, 255, 20, 0.75);
                box-shadow: 0 0 0 1px rgba(0, 212, 255, 0.12), 0 0 22px rgba(57, 255, 20, 0.35);
            }
        }
        @keyframes specbatAura {
            0%, 100% { opacity: 0.65; transform: scale(0.95); }
            50% { opacity: 1; transform: scale(1.08); }
        }
        @keyframes specbatRing {
            0%, 100% { opacity: 0.20; transform: scale(0.88); border-color: rgba(57, 255, 20, 0.50); }
            50% { opacity: 0.90; transform: scale(1.12); border-color: rgba(0, 212, 255, 0.70); }
        }
        @keyframes adminPulse {
            0% { transform: scale(0.92); box-shadow: 0 0 0 1px rgba(120,76,0,0.35), 0 0 10px rgba(245,198,66,0.55), 0 6px 14px rgba(0,0,0,0.24); }
            70% { transform: scale(1.16); box-shadow: 0 0 0 1px rgba(120,76,0,0.28), 0 0 22px rgba(245,198,66,0.65), 0 10px 22px rgba(0,0,0,0.28); }
            100% { transform: scale(0.92); box-shadow: 0 0 0 1px rgba(120,76,0,0.35), 0 0 10px rgba(245,198,66,0.55), 0 6px 14px rgba(0,0,0,0.24); }
        }
        @keyframes adminSiren {
            0%, 100% { opacity: 0.35; transform: scaleX(0.9); }
            50% { opacity: 1; transform: scaleX(1.1); }
        }

        /* Баннер админ-уведомлений */
        .broadcast-banner { position: fixed; top: calc(12px + var(--safe-area-inset-top)); left: 50%; transform: translateX(-50%); z-index: 3000; background: linear-gradient(135deg, #111 0%, #333 100%); color: #fff; padding: 12px 16px; border-radius: 14px; box-shadow: 0 10px 30px rgba(0,0,0,0.35); display: none; max-width: 90%; text-align: center; font-weight: 700; }
        .broadcast-banner.visible { display: block; }
        .proximity-banner { position: fixed; top: calc(52px + var(--safe-area-inset-top)); left: 50%; transform: translateX(-50%); z-index: 2500; background: #1c1c1e; color: #fff; padding: 10px 14px; border-radius: 14px; box-shadow: 0 10px 30px rgba(0,0,0,0.28); display: none; min-width: 220px; text-align: center; font-weight: 800; letter-spacing: 0.2px; }
        .proximity-banner.visible { display: block; }
        .proximity-banner--yellow { background: #ffd60a; color: #1a1a1a; }
        .proximity-banner--orange { background: #ff9f0a; color: #1a1a1a; }
        .proximity-banner--red { background: #ff3b30; color: #fff; }
        .proximity-banner--blink { animation: proximityBlink 0.8s ease-in-out infinite; }
        .proximity-banner-title { font-size: 12px; font-weight: 700; opacity: 0.9; }
        .proximity-banner-distance { font-size: 18px; font-weight: 900; margin-left: 6px; }
        @keyframes proximityBlink {
            0%, 100% { box-shadow: 0 10px 30px rgba(255,59,48,0.35); }
            50% { box-shadow: 0 0 0 6px rgba(255,59,48,0.28); }
        }
        
        /* Overlay ограничения доступа */
        #tgAuthOverlay {
            display: none !important;
        }
        
        #tgAuthOverlay[style*="display: flex"] {
            display: flex !important;
        }

        /* ============= SAFE AREA TOP OFFSET (iPhone 14 Pro / Redmi) ============= */
        /* Требование: сдвинуть основной UI и модалки ниже системных кнопок ("Закрыть", "...") */
        .top-controls { top: var(--ui-safe-top) !important; }
        #onlineCountBadge.online-count { top: var(--ui-safe-top) !important; }
        #mapEngineBadge.engine-badge { top: calc(var(--ui-safe-top) + 44px) !important; }
        #map3dToggleFloating { top: calc(var(--ui-safe-top) + 80px) !important; }
        .right-bar { top: var(--ui-safe-top) !important; }
        .admin-btn,
        .profile-btn,
        .feedback-btn,
        .loc-btn,
        .follow-toggle { top: var(--ui-safe-top) !important; }
        .broadcast-banner { top: var(--ui-safe-top) !important; }
        .proximity-banner { top: calc(var(--ui-safe-top) + 44px) !important; }
        .notif-toast-wrap { top: calc(var(--ui-safe-top) + 58px) !important; }

        /* Модальные окна и оверлеи: добавляем padding-top, чтобы контент не залезал под верхние системные зоны */
        .modal { padding-top: var(--ui-safe-top); box-sizing: border-box; }
        #tgAuthOverlay,
        #betaInviteOverlay,
        .ban-notice { padding-top: var(--ui-safe-top) !important; box-sizing: border-box; }

        /* ============= FIX: WHITE-ON-WHITE (FORCE DARK + CONTRAST) ============= */
        /* Карточки/оверлеи, которые иногда остаются светлыми из старых inline-стилей */
        .settings-block,
        .profile-card,
        .admin-panel-item,
        .ban-duration-content,
        .notif-row,
        .chat-message.other,
        .heatmap-toggle,
        #tgAuthOverlay > div,
        #betaInviteOverlay > div,
        #betaInviteOverlay input,
        #tgAuthOverlay input,
        [style*="background:#fff"],
        [style*="background: #fff"],
        [style*="background:#f5f5f5"],
        [style*="background: #f5f5f5"],
        [style*="background:#f9f9f9"],
        [style*="background: #f9f9f9"],
        [style*="background:#f0f7ff"],
        [style*="background: #f0f7ff"],
        [style*="background:#f0f0f5"],
        [style*="background: #f0f0f5"],
        [style*="background:#ececf1"],
        [style*="background: #ececf1"],
        [style*="background-color:#fff"],
        [style*="background-color: #fff"],
        [style*="background-color:white"],
        [style*="background-color: white"],
        [style*="background-color:rgb(255,255,255"],
        [style*="background-color: rgb(255, 255, 255"],
        [style*="background: white"],
        [style*="background: rgb(255, 255, 255"],
        [style*="background:rgb(255,255,255"] {
            background-color: var(--card-strong) !important;
            color: var(--text-primary) !important;
            border-color: rgba(0, 212, 255, 0.20) !important;
        }

        .settings-block,
        .profile-card,
        .admin-panel-item,
        .ban-duration-content,
        #tgAuthOverlay,
        #betaInviteOverlay {
            color: var(--text-primary);
        }

        /* Общие светлые элементы UI → в тёмный premium */
        .icon-circle,
        .b-poll-btn,
        .admin-stat-card,
        .admin-table th {
            background: rgba(26, 26, 26, 0.92) !important;
            color: var(--text-primary) !important;
            border-color: rgba(0, 212, 255, 0.20) !important;
        }
        .admin-table th,
        .admin-table td {
            border-bottom-color: rgba(255,255,255,0.12) !important;
        }
        .admin-table tr:hover { background: rgba(0, 212, 255, 0.08) !important; }

        /* Текст внутри проблемных светлых блоков (в т.ч. с inline color:#333/#666/#888) */
        #tgAuthOverlay h1,
        #tgAuthOverlay h2,
        #tgAuthOverlay h3,
        #tgAuthOverlay p,
        #tgAuthOverlay span,
        #tgAuthOverlay div,
        #betaInviteOverlay h1,
        #betaInviteOverlay h2,
        #betaInviteOverlay h3,
        #betaInviteOverlay p,
        #betaInviteOverlay span,
        #betaInviteOverlay div,
        .settings-block h1,
        .settings-block h2,
        .settings-block h3,
        .settings-block p,
        .settings-block span,
        .profile-card h1,
        .profile-card h2,
        .profile-card h3,
        .profile-card p,
        .profile-card span,
        .admin-panel-item h1,
        .admin-panel-item h2,
        .admin-panel-item h3,
        .admin-panel-item p,
        .admin-panel-item span,
        .ban-duration-content h1,
        .ban-duration-content h2,
        .ban-duration-content h3,
        .ban-duration-content p,
        .ban-duration-content span,
        .notif-row p,
        .notif-row span {
            color: var(--text-primary) !important;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.50) !important;
        }

        /* Инпуты (модель авто, номер и т.п.) */
        input[type="text"],
        input[type="number"],
        input[type="tel"],
        input[type="email"],
        textarea {
            background: rgba(26, 26, 30, 0.92) !important;
            color: var(--blue) !important;
            caret-color: var(--blue);
            border: 1px solid rgba(255, 255, 255, 0.18) !important;
            padding: 12px !important;
        }

        /* “Подписи/подсказки” (серый на сером/чёрном) */
        .sub-text,
        .hint-text,
        .label-small,
        .text-label,
        .value-display {
            color: rgba(255, 255, 255, 0.70) !important;
        }

        /* Сплэш: гарантируем видимость текста даже при отключённых анимациях */
        #splashScreen { color: var(--text-primary); }
        .splash-greeting,
        .splash-username { opacity: 1; }
        @media (prefers-reduced-motion: reduce) {
            .splash-logo,
            .splash-greeting,
            .splash-username {
                animation: none !important;
                opacity: 1 !important;
                transform: none !important;
            }
        }
    </style>
</head>
<body>
    <!-- ============= ЭКРАН ПРИВЕТСТВИЯ ============= -->
    <div id="splashScreen">
        <img src="img/logo.png" alt="180 СафеДрайв" class="splash-logo">
        <div class="splash-greeting" id="greetingText">Доброе утро</div>
        <div class="splash-username" id="usernameText">Водитель...</div>
        <div class="splash-loader"></div>
    </div>

    <!-- ============= УВЕДОМЛЕНИЕ О БАНЕ ============= -->
    <div id="banNotice" class="ban-notice">
        <div class="ban-notice-content">
            <div class="ban-notice-icon">🚫</div>
            <div class="ban-notice-title">Доступ ограничен</div>
            <div class="ban-notice-message" id="banMessage">Ваш аккаунт временно заблокирован</div>
            <div class="ban-notice-time" id="banTimeRemaining"></div>
            <button id="unbanRequestBtn" class="unban-request-btn" onclick="requestUnban()">
                📨 Подать запрос на разбан
            </button>
            <div id="unbanStatus" class="unban-status" style="display: none;"></div>
        </div>
    </div>


    <div class="target" aria-hidden="true"></div>

    <!-- Overlay: Требуется Telegram для регистрации/действий -->
    <div id="tgAuthOverlay" class="auth-overlay" style="display:none; position:fixed; inset:0; z-index:99999; background:rgba(0,0,0,0.6); align-items:center; justify-content:center;">
        <div style="background:rgba(26,26,26,0.88); border:1px solid rgba(0,212,255,0.2); backdrop-filter:blur(10px); -webkit-backdrop-filter:blur(10px); padding:40px 25px; border-radius:16px; max-width:460px; width:95%; text-align:center; box-shadow:0 10px 40px rgba(0,0,0,0.45); animation: slideUp 0.4s ease; color:rgba(255,255,255,0.92);">
            <div style="font-size:48px; margin-bottom:20px; animation: pulse 2s ease-in-out infinite;">🔐</div>
            <h2 style="margin:0 0 15px 0; font-size:24px; font-weight:800; color:#00d4ff; text-shadow:0 0 12px rgba(0,212,255,0.28);">Вход в EASY RIDE 180</h2>
            <p style="color:rgba(255,255,255,0.92); font-size:15px; line-height:1.65; margin:0 0 14px 0;">
                Для сайта/PWA сначала выполните вход через Telegram.<br>
                В <strong>Telegram Mini App</strong> вход происходит автоматически.
            </p>
            <p style="color:rgba(255,255,255,0.72); font-size:13px; line-height:1.5; margin:0 0 20px 0;">
                Если вы в браузере/приложении — нажмите «Войти через Telegram» ниже.
            </p>
            <div style="display:flex; flex-direction:column; gap:12px; justify-content:center;">
                <div id="tgLoginWidget" style="display:flex; justify-content:center;"></div>
                <button onclick="openTelegramBot()" style="padding:14px 20px; border-radius:12px; border:none; background:linear-gradient(135deg, #007aff 0%, #0051d5 100%); color:#fff; font-weight:700; font-size:16px; cursor:pointer; transition:all 0.3s; box-shadow:0 4px 12px rgba(0,122,255,0.3);" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(0,122,255,0.4)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(0,122,255,0.3)'">
                    📱 Открыть в Telegram
                </button>
                <button onclick="location.reload()" style="padding:12px 20px; border-radius:12px; border:1px solid rgba(0,212,255,0.25); background:rgba(26,26,26,0.92); color:rgba(255,255,255,0.86); font-weight:700; font-size:15px; cursor:pointer; transition:all 0.3s;" onmouseover="this.style.borderColor='rgba(0,212,255,0.5)'" onmouseout="this.style.borderColor='rgba(0,212,255,0.25)'">
                    🔄 Перезагрузить страницу
                </button>
            </div>
            <div style="margin-top:18px; padding:12px; background:rgba(26,26,26,0.92); border-radius:10px; border:1px solid rgba(0,212,255,0.2); text-align:left;">
                <p style="margin:0 0 8px 0; font-size:12px; color:#00d4ff; line-height:1.5; font-weight:800;">📲 Установка PWA:</p>
                <p style="margin:0; font-size:12px; color:rgba(255,255,255,0.80); line-height:1.5;">
                    iPhone: Safari → Поделиться → «На экран Домой».<br>
                    Android: меню браузера → «Установить приложение».<br>
                    После установки войдите через Telegram Widget выше.
                </p>
            </div>
        </div>
    </div>
    <style>
        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
    </style>

    <!-- ============= ЭКРАН ВВОДА КОДА ЗБТ ПРИГЛАШЕНИЯ ============= -->
    <div id="betaInviteOverlay" class="beta-invite-overlay" style="display:none; position:fixed; inset:0; z-index:99998; background:rgba(0,0,0,0.7); align-items:center; justify-content:center; font-family:system-ui, -apple-system, sans-serif;">
        <div style="background:#fff; padding:40px 25px; border-radius:20px; max-width:450px; width:95%; text-align:center; box-shadow:0 20px 60px rgba(0,0,0,0.3); animation: slideUp 0.4s ease;">
            <div style="font-size:64px; margin-bottom:20px; animation: pulse 2s ease-in-out infinite;">🎉</div>
            <h2 style="margin:0 0 10px 0; font-size:28px; font-weight:800; color:#222;">Закрытое Бета-Тестирование</h2>
            <p style="color:#666; font-size:15px; line-height:1.6; margin:0 0 30px 0;">
                Введите код приглашения для доступа<br>к приложению EASY RIDE 180
            </p>
            
            <div style="display:flex; flex-direction:column; gap:15px; margin-bottom:25px;">
                <input id="betaInviteCode" type="text" placeholder="Введите код приглашения..." style="padding:14px 16px; border:2px solid #e0e0e0; border-radius:12px; font-size:16px; font-weight:600; letter-spacing:2px; text-transform:uppercase; text-align:center; transition:all 0.3s; outline:none;" onfocus="this.style.borderColor='#007aff'; this.style.boxShadow='0 0 0 3px rgba(0,122,255,0.1)'" onblur="this.style.borderColor='#e0e0e0'; this.style.boxShadow='none'">
                
                <button onclick="verifyBetaCode()" style="padding:14px 20px; border-radius:12px; border:none; background:linear-gradient(135deg, #007aff 0%, #0051d5 100%); color:#fff; font-weight:700; font-size:16px; cursor:pointer; transition:all 0.3s; box-shadow:0 4px 12px rgba(0,122,255,0.3);" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(0,122,255,0.4)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(0,122,255,0.3)'">
                    ✓ Проверить код
                </button>
            </div>
            
            <div id="betaStatus" style="display:none; padding:12px; border-radius:10px; margin-bottom:20px; font-size:14px; font-weight:500;"></div>
            
            <div style="padding:15px; background:#f9f9f9; border-radius:12px; border:1px solid #e0e0e0;">
                <p style="margin:0; font-size:13px; color:#888; line-height:1.6;">
                    💡 Код мог быть выслан вам<br>в личные сообщения в Telegram
                </p>
            </div>
        </div>
    </div>
    

    <!-- Онлайн-счётчик пользователей -->
    <div id="onlineCountBadge" class="online-count" aria-label="Онлайн">
        <span class="online-dot" aria-hidden="true"></span>
        <span id="onlineCountText">В сети: —</span>
    </div>
    <div id="mapEngineBadge" class="engine-badge" aria-label="Движок карты">🗺️ ymaps3</div>
    <button id="map3dToggleFloating" onclick="toggleMap3dFromUI()" title="Переключить 2D/3D" aria-label="Переключить 2D/3D">3D OFF</button>
    <div id="map"></div>
    <div id="mapDimmingOverlay"></div>

    <!-- Правая колонка кнопок -->
    <div class="right-bar" id="rightBar" aria-label="Быстрые действия">
        <button class="action-btn" id="ccProfileBtn" onclick="openProfileModal()" title="Профиль" aria-label="Профиль">👤</button>
        <button class="action-btn" id="ccSettingsBtn" onclick="openAdminModal()" title="Настройки" aria-label="Настройки">⚙️</button>
        <button class="action-btn" id="ccMapEngineBtn" onclick="toggleMapEngineFromUI()" title="Тест движка карты" aria-label="Тест движка карты">🗺️</button>
        <button class="action-btn" id="ccLayersBtn" onclick="toggleMainLayers()" title="Слои" aria-label="Слои">🗂️</button>
        <button class="action-btn" id="ccCourseBtn" onclick="toggleDynamicCourseFromUI()" title="Динамический курс" aria-label="Динамический курс">🧭</button>
        <button class="action-btn" id="ccVoiceBtn" onclick="toggleMonolithVoiceFromUI()" title="Голосовой штурман" aria-label="Голосовой штурман">🔊</button>
        <button class="action-btn" id="ccChatBtn" onclick="openChatModal()" title="Чат" aria-label="Чат">💬</button>
        <button class="action-btn" id="ccActivityBtn" onclick="openActivityModal('dpsSpecbatMonth')" title="Активность ДПС/Спецбат" aria-label="Активность ДПС/Спецбат">👮🛡️</button>
    </div>

    <!-- Нижние углы: Геолокация + Рация -->
    <div class="bottom-controls" id="bottomControls" aria-label="Нижние кнопки">
        <button class="locate-btn" id="locateBtn" onclick="centerOnMyLocation()" title="Центрирование" aria-label="Центрирование">
            <span class="locate-icon">➤</span>
        </button>
        <button class="ptt-btn ptt-fab" id="pttFabBtn" title="Рация (зажми и говори)" aria-label="Рация">🎙️</button>
    </div>

    <!-- Баннер админ-уведомлений -->
    <div id="broadcastBanner" class="broadcast-banner"></div>
    <!-- Динамический баннер приближения -->
    <div id="proximityBanner" class="proximity-banner"></div>

    <!-- Crowdsourcing: "Тут ещё стоят?" -->
    <div id="crowdConfirm" class="crowd-confirm" role="dialog" aria-label="Подтверждение метки">
        <div id="crowdConfirmTitle" class="crowd-confirm-title">Тут ещё стоят?</div>
        <div id="crowdConfirmSub" class="crowd-confirm-sub">Один тап — и карта станет точнее</div>
        <div class="crowd-confirm-actions">
            <button class="crowd-btn-yes" onclick="crowdConfirmAnswer(true)">Да</button>
            <button class="crowd-btn-no" onclick="crowdConfirmAnswer(false)">Нет</button>
            <button class="crowd-btn-skip" onclick="crowdConfirmHide()">Позже</button>
        </div>
    </div>

    <!-- Спидометр -->
    <div id="speedometer" class="speedometer">
        <div>
            <div class="speedometer-value"><span id="speedValue">0</span><span class="speedometer-unit">км/ч</span></div>
            <div class="speedometer-label">Скорость</div>
        </div>
        <button class="speedometer-toggle" onclick="toggleSpeedometer(false)" title="Скрыть">✕</button>
    </div>
    <button class="speedometer-open-btn" id="speedometerOpenBtn" onclick="toggleSpeedometer(true)" title="Показать спидометр">🧭</button>
    
    <div id="inAppNotifWrap" class="notif-toast-wrap"></div>
    
    <!-- Модальное окно чата -->
    <div id="chatModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 style="margin: 0;">Общий чат</h2>
                <button class="modal-close" onclick="closeChatModal()">✕</button>
            </div>

            
            <div class="chat-messages" id="chatMessages">
                <div style="text-align: center; color: var(--gray); padding: 20px;">Загрузка сообщений...</div>
            </div>
            
            <div id="chatPhotoPreview" style="padding: 10px; display: none;"></div>
            
            <div class="chat-input-group">
                <input type="text" id="chatInput" class="chat-input" placeholder="Напишите сообщение..." maxlength="500">
                <div class="chat-photo-upload">
                    <input type="file" id="chatPhotoInput" class="chat-photo-input" accept="image/*">
                    <button class="chat-photo-btn" onclick="document.getElementById('chatPhotoInput').click()">📷</button>
                </div>
                <button class="chat-send-btn" onclick="sendChatMessage()">Отправить</button>
            </div>
        </div>
    </div>

    <!-- Модальное окно Рации (PTT) -->
    <div id="pttModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 style="margin: 0;">🎙️ Рация</h2>
                <button class="modal-close" onclick="closePttModal()">✕</button>
            </div>
            <button id="pttHoldBtn" class="ptt-hold-btn">Удерживай, чтобы говорить</button>
            <div id="pttStatus" class="ptt-status">Готово.</div>
            <div id="pttSub" class="ptt-sub">Ограничение: 7 сек. Таймаут после реплики: 10 сек.</div>
            <div class="ptt-actions">
                <button id="pttComplainBtn" class="ptt-complain" disabled>🚫 Пожаловаться на последнюю реплику</button>
            </div>
        </div>
    </div>

    <!-- Шторка уведомлений -->
    <div id="notificationsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 style="margin: 0;">🔔 Уведомления</h2>
                <button class="modal-close" onclick="closeNotificationsDrawer()">✕</button>
            </div>
            <div style="display:flex; gap:8px; margin-bottom:10px;">
                <button class="main-btn" style="flex:1; background:#34c759;" onclick="markAllNotificationsRead()">Прочитать все</button>
                <button class="main-btn" style="flex:1; background:#999;" onclick="clearAllNotifications()">Очистить</button>
            </div>
            <div id="notificationsList" style="max-height: 460px; overflow-y: auto;">
                <div style="text-align:center; color: var(--gray); padding: 16px;">Пока нет уведомлений</div>
            </div>
        </div>
    </div>
    
    <!-- Кнопка отправки нареканий -->
    <button class="feedback-btn" id="feedbackBtn" onclick="openBugReportModal()" title="Сообщить о баге">🐛</button>
    <!-- Переключатель автослежения GPS -->
    <button class="follow-toggle" id="followToggleBtn" onclick="toggleFollow()" title="Автослежение GPS">🔔</button>

    <!-- Правый нижний угол: 2 блока (Оперативные / Навигационные) -->
    <div class="fab-stack" aria-label="Быстрые действия">
        <!-- Навигационные: Слои + Центрирование -->
        <div class="fab-group" aria-label="Навигационные">
            <div class="fab-row">
                <button class="chat-btn heatmap-toggle-btn layers-btn" id="patrolHeatmapBtn" onclick="togglePatrolHeatmap()" title="Слои: засад ДПС/Спецбат">👁️</button>
                <button class="chat-btn heatmap-toggle-btn layers-btn" id="dtpHeatmapBtn" onclick="toggleDtpHeatmap()" title="Слои: тепловая карта ДТП">🗂️🔥</button>
            </div>
            <button class="loc-btn" id="locBtn" onclick="centerOnMyLocation()" title="Центрирование (Где я)">📍</button>
        </div>

        <!-- Оперативные: Рация (самая крупная), Чат под ней -->
        <div class="fab-group" aria-label="Оперативные">
            <button class="chat-btn ptt-btn fab-ptt" onclick="openPttModal()" title="Рация: удерживай, чтобы говорить">🎙️</button>
            <button class="chat-btn fab-chat" onclick="openChatModal()" title="Чат">💬</button>
        </div>
    </div>
    
    <!-- Модальное окно отправки отчета о баге -->
    <div id="bugReportModal" class="modal">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <h2 style="margin: 0;">🐛 Сообщить о баге</h2>
                <button class="modal-close" onclick="closeBugReportModal()">✕</button>
            </div>
            
            <div style="padding: 20px; max-height: 70vh; overflow-y: auto;">
                <p style="color: #666; margin-bottom: 20px;">Помогите нам улучшить приложение. Опишите найденную проблему:</p>
                
                <!-- Категория -->
                <div style="margin-bottom: 15px;">
                    <label style="display: block; font-weight: 600; margin-bottom: 8px;">Категория:</label>
                    <select id="bugCategory" style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 8px; font-size: 14px;">
                        <option value="ui">🎨 Проблема интерфейса</option>
                        <option value="map">🗺️ Проблема карты</option>
                        <option value="markers">📍 Проблема с метками</option>
                        <option value="chat">💬 Проблема чата</option>
                        <option value="crash">💥 Приложение зависло</option>
                        <option value="performance">⚡ Проблема производительности</option>
                        <option value="other">❓ Другое</option>
                    </select>
                </div>
                
                <!-- Описание -->
                <div style="margin-bottom: 15px;">
                    <label style="display: block; font-weight: 600; margin-bottom: 8px;">Описание проблемы:</label>
                    <textarea id="bugDescription" 
                        style="width: 100%; min-height: 120px; padding: 10px; border: 2px solid #ddd; border-radius: 8px; font-family: inherit; font-size: 14px; resize: vertical;"
                        placeholder="Что произошло? Когда появилась проблема? Какие шаги привели к ошибке?"></textarea>
                </div>
                
                <!-- Контакт -->
                <div style="margin-bottom: 15px;">
                    <label style="display: block; font-weight: 600; margin-bottom: 8px;">Ваше имя (опционально):</label>
                    <input type="text" id="bugReporterName" 
                        style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 8px; font-size: 14px;"
                        placeholder="Как вас зовут?">
                </div>
                
                <!-- Чек-лист -->
                <div style="background: #f0f7ff; padding: 12px; border-radius: 8px; margin-bottom: 15px; font-size: 13px;">
                    <label style="display: flex; align-items: center; margin-bottom: 8px;">
                        <input type="checkbox" id="bugReproducible" style="margin-right: 8px;">
                        <span>Я могу повторить эту ошибку</span>
                    </label>
                    <label style="display: flex; align-items: center;">
                        <input type="checkbox" id="bugIncludeLogs" style="margin-right: 8px;">
                        <span>Включить техническую информацию</span>
                    </label>
                </div>
                
                <!-- Статус отправки -->
                <div id="bugReportStatus" style="display: none; padding: 12px; border-radius: 8px; margin-bottom: 15px; font-weight: 500;"></div>
                
                <!-- Кнопки -->
                <div style="display: flex; gap: 10px;">
                    <button onclick="submitBugReport()" style="flex: 1; background: linear-gradient(135deg, #dc3545 0%, #c82333 100%); color: white; border: none; padding: 12px; border-radius: 8px; font-weight: 700; cursor: pointer; font-size: 15px;">
                        📤 Отправить отчет
                    </button>
                    <button onclick="closeBugReportModal()" style="flex: 1; background: #f0f0f5; border: none; padding: 12px; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 15px;">
                        Отмена
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Модальное окно админ-панели -->
    <div id="adminModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 style="margin: 0;">Админ-панель</h2>
                <button class="modal-close" onclick="closeAdminModal()">✕</button>
            </div>
            
            <div class="admin-stats">
                <div class="admin-stat-card">
                    <div class="label">Всего водителей</div>
                    <div class="value" id="admin-drivers-count">0</div>
                </div>
                <div class="admin-stat-card">
                    <div class="label">Активных меток</div>
                    <div class="value" id="admin-markers-count">0</div>
                </div>
            </div>
            
            <h3 style="margin-top: 20px; margin-bottom: 10px; font-size: 14px;">Список водителей</h3>
            <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                <input type="text" id="driverSearchInput" placeholder="Поиск по имени или ID..." style="flex: 1; padding: 8px; border-radius: 8px; border: 1px solid #ddd; font-size: 13px;">
                <button onclick="clearDriverSearch()" style="padding: 8px 12px; border: none; border-radius: 8px; background: #f0f0f5; cursor: pointer; font-size: 13px; font-weight: 600;">🔄 Сброс</button>
            </div>
            <div style="overflow-x: auto; max-height: 300px; overflow-y: auto;">
                <table class="admin-table" id="admin-drivers-table">
                    <thead>
                        <tr>
                            <th>Имя</th>
                            <th>Авто</th>
                            <th>Номер</th>
                            <th>Статус</th>
                            <th>Действие</th>
                        </tr>
                    </thead>
                    <tbody id="admin-drivers-body">
                        <tr><td colspan="5" style="text-align: center; color: var(--gray);">Загрузка...</td></tr>
                    </tbody>
                </table>
            </div>
            
            <h3 style="margin-top: 20px; margin-bottom: 10px; font-size: 14px;">Активные метки</h3>
            <div style="display: flex; gap: 8px; margin-bottom: 12px; flex-wrap: wrap;">
                <select id="markerTypeFilter" style="padding: 8px 12px; border-radius: 8px; border: 1px solid #ddd; font-size: 13px; cursor: pointer;">
                    <option value="">📍 Все события</option>
                    <optgroup label="Дорожный патруль">
                        <option value="dps">👮 ДПС (Стандарт)</option>
                        <option value="patrol">🚔 Рейд</option>
                        <option value="specbat">🛡️ Спецбат</option>
                        <option value="motobat">🏍️ Мотобат</option>
                        <option value="cargo_control">🚛 Грузовой контроль</option>
                    </optgroup>
                    <optgroup label="Взаимопомощь">
                        <option value="sos">🆘 SOS / Нужна помощь</option>
                        <option value="dtp">💥 ДТП</option>
                        <option value="danger">⚠️ Опасность</option>
                        <option value="traffic_jam">🚗 Пробка / Затор</option>
                    </optgroup>
                    <optgroup label="Legacy">
                        <option value="camera">📸 Наблюдение (legacy)</option>
                        <option value="works">🛣️ Работы (legacy)</option>
                    </optgroup>
                </select>
                <button onclick="clearMarkerFilter()" style="padding: 8px 12px; border: none; border-radius: 8px; background: #f0f0f5; cursor: pointer; font-size: 13px; font-weight: 600;">🔄 Сброс</button>
            </div>
            <div style="overflow-x: auto; max-height: 300px; overflow-y: auto;">
                <table class="admin-table" id="admin-markers-table">
                    <thead>
                        <tr>
                            <th>Тип</th>
                            <th>Комментарий</th>
                            <th>Подтверждения</th>
                            <th>Спорные</th>
                            <th>Exp</th>
                            <th>Действие</th>
                        </tr>
                    </thead>
                    <tbody id="admin-markers-body">
                        <tr><td colspan="6" style="text-align: center; color: var(--gray);">Загрузка...</td></tr>
                    </tbody>
                </table>
            </div>
            
            <!-- ============= СЕКЦИЯ УПРАВЛЕНИЯ ЗБТ КОДАМИ ============= -->
            <div id="betaInvitesSection" style="margin-top: 30px; padding: 20px; background: #f0f7ff; border-radius: 12px; border: 2px solid #007aff;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h3 style="margin: 0; font-size: 18px; font-weight: 700;">🎉 Управление ЗБТ кодами</h3>
                    <button onclick="refreshBetaCodes()" style="background: var(--blue); color: white; border: none; padding: 8px 16px; border-radius: 8px; cursor: pointer; font-weight: 600;">
                        🔄 Обновить
                    </button>
                </div>

                <!-- Генерирование нового кода -->
                <div style="background: white; padding: 15px; border-radius: 10px; margin-bottom: 15px; border: 1px solid #e0e0e0;">
                    <h4 style="margin: 0 0 12px 0; font-size: 14px; font-weight: 700;">Создать новый код:</h4>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <input type="number" id="betaCodeCountInput" placeholder="Кол-во использований (1-100)" min="1" max="100" value="1" style="padding: 10px; border: 1px solid #ddd; border-radius: 8px; width: 200px; font-size: 14px;">
                        <input type="text" id="betaCodeDescInput" placeholder="Описание (опционально)" style="padding: 10px; border: 1px solid #ddd; border-radius: 8px; flex: 1; min-width: 200px; font-size: 14px;">
                        <button onclick="generateBetaCode()" style="background: #28a745; color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-weight: 700; white-space: nowrap;">
                            ✨ Создать код
                        </button>
                    </div>
                    <div id="betaCodeStatus" style="margin-top: 10px; display: none; padding: 10px; border-radius: 8px; font-size: 14px; font-weight: 500;"></div>
                </div>

                <!-- Список кодов -->
                <div style="max-height: 250px; overflow-y: auto;">
                    <table style="width: 100%; border-collapse: collapse; font-size: 13px;">
                        <thead style="background: #007aff; color: white; font-weight: 700; position: sticky; top: 0;">
                            <tr>
                                <th style="padding: 10px; text-align: left; border: 1px solid #ddd;">Код</th>
                                <th style="padding: 10px; text-align: center; border: 1px solid #ddd;">Макс. исп.</th>
                                <th style="padding: 10px; text-align: center; border: 1px solid #ddd;">Текущ. исп.</th>
                                <th style="padding: 10px; text-align: center; border: 1px solid #ddd;">Итого</th>
                                <th style="padding: 10px; text-align: center; border: 1px solid #ddd;">Статус</th>
                                <th style="padding: 10px; text-align: center; border: 1px solid #ddd;">Действие</th>
                            </tr>
                        </thead>
                        <tbody id="betaCodesTableBody">
                            <tr style="background: #f9f9f9;">
                                <td colspan="6" style="padding: 20px; text-align: center; color: #888;">Загрузка...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- ============= МАССОВАЯ ВЫДАЧА АЧИВОК (АДМИН) ============= -->
            <div style="margin-top: 20px; padding: 16px; background: #fff; border-radius: 12px; border: 1px solid #e8e8e8;">
                <h4 style="margin: 0 0 8px 0; font-size: 14px; font-weight: 700;">🏷️ Массовая выдача ачивки `beta_tester`</h4>
                <div style="display:flex; gap:8px; margin-bottom:8px;">
                    <input id="bulkBetaIds" placeholder="Введите user_id через запятую или пробел" style="flex:1; padding:8px; border:1px solid #ddd; border-radius:8px; font-size:13px;">
                    <button onclick="grantBetaFromInput()" style="padding:8px 12px; background:#ff9500; color:white; border:none; border-radius:8px; cursor:pointer; font-weight:700;">🎖️ Выдать</button>
                </div>
                <div id="bulkBetaStatus" style="font-size:13px; color:#666; min-height:18px;"></div>
            </div>

            <!-- ============= Загрузка MP3 озвучки для предупреждений ============= -->
            <div style="margin-top:20px; padding:16px; background:#fff8e6; border-radius:12px; border:1px solid #ffe0a3;">
                <h4 style="margin:0 0 8px 0; font-size:14px; font-weight:700;">🎤 Загрузка своей озвучки (MP3)</h4>
                <div style="font-size:13px; color:#444; margin-bottom:10px;">Загрузите 4 файла в bucket <strong>/audio/</strong> с точными именами:</div>
                <div style="font-size:12px; color:#666; margin-bottom:10px; line-height:1.5;">
                    • warning_standard_far.mp3<br>
                    • warning_standard_close.mp3<br>
                    • warning_cheeky_far.mp3<br>
                    • warning_cheeky_close.mp3
                </div>
                <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-bottom:12px;">
                    <div>
                        <div style="font-size:12px; font-weight:700; margin-bottom:6px;">Стандартный (далеко)</div>
                        <input type="file" id="audioStandardFar" accept="audio/mpeg,audio/mp3" style="width:100%;">
                    </div>
                    <div>
                        <div style="font-size:12px; font-weight:700; margin-bottom:6px;">Стандартный (близко)</div>
                        <input type="file" id="audioStandardClose" accept="audio/mpeg,audio/mp3" style="width:100%;">
                    </div>
                    <div>
                        <div style="font-size:12px; font-weight:700; margin-bottom:6px;">Дерзкий (далеко)</div>
                        <input type="file" id="audioCheekyFar" accept="audio/mpeg,audio/mp3" style="width:100%;">
                    </div>
                    <div>
                        <div style="font-size:12px; font-weight:700; margin-bottom:6px;">Дерзкий (близко)</div>
                        <input type="file" id="audioCheekyClose" accept="audio/mpeg,audio/mp3" style="width:100%;">
                    </div>
                </div>
                <div style="display:flex; gap:8px; flex-wrap:wrap; margin-bottom:8px;">
                    <button onclick="uploadCustomWarningAudios()" style="padding:10px 14px; background:#111; color:white; border:none; border-radius:8px; cursor:pointer; font-weight:700;">⬆️ Загрузить файлы</button>
                    <button onclick="listAudioStorageFiles()" style="padding:10px 14px; background:#6f42c1; color:white; border:none; border-radius:8px; cursor:pointer; font-weight:700;">📂 Проверить Storage</button>
                </div>
                <div style="margin-top:8px;">
                    <div id="storageFilesList" style="max-height:140px; overflow:auto; border:1px dashed #e0e0e0; padding:8px; border-radius:8px; background:#fff;"></div>
                </div>
                <div id="warningAudioStatus" style="font-size:13px; color:#666; min-height:18px;"></div>
            </div>
            
            <!-- Вкладка для управления запросами на разбан -->
<div id="unbanRequestsSection" style="margin-top: 30px;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h3 style="margin: 0; font-size: 18px; font-weight: 700;">📨 Запросы на разбан</h3>
        <button onclick="refreshUnbanRequests()" style="background: var(--blue); color: white; border: none; padding: 8px 16px; border-radius: 8px; cursor: pointer; font-weight: 600;">
            🔄 Обновить
        </button>
    </div>

    <!-- Статистика -->
    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-bottom: 20px;">
        <div style="background: #fff3cd; border-radius: 12px; padding: 15px; text-align: center;">
            <div style="font-size: 24px; font-weight: 800; color: #ff9500;" id="pendingRequestsCount">0</div>
            <div style="font-size: 12px; color: #666; margin-top: 5px;">Ожидают</div>
        </div>
        <div style="background: #d4edda; border-radius: 12px; padding: 15px; text-align: center;">
            <div style="font-size: 24px; font-weight: 800; color: #28a745;" id="approvedRequestsCount">0</div>
            <div style="font-size: 12px; color: #666; margin-top: 5px;">Одобрено</div>
        </div>
        <div style="background: #f8d7da; border-radius: 12px; padding: 15px; text-align: center;">
            <div style="font-size: 24px; font-weight: 800; color: #dc3545;" id="rejectedRequestsCount">0</div>
            <div style="font-size: 12px; color: #666; margin-top: 5px;">Отклонено</div>
        </div>
    </div>

    <!-- Фильтры -->
    <div style="display: flex; gap: 10px; margin-bottom: 15px;">
        <button onclick="filterUnbanRequests('all')" id="filterAll" class="filter-btn active" style="flex: 1; padding: 10px; border: 2px solid var(--blue); background: var(--blue); color: white; border-radius: 8px; cursor: pointer; font-weight: 600;">
            Все
        </button>
        <button onclick="filterUnbanRequests('pending')" id="filterPending" class="filter-btn" style="flex: 1; padding: 10px; border: 2px solid #ff9500; background: white; color: #ff9500; border-radius: 8px; cursor: pointer; font-weight: 600;">
            Ожидают
        </button>
        <button onclick="filterUnbanRequests('approved')" id="filterApproved" class="filter-btn" style="flex: 1; padding: 10px; border: 2px solid #28a745; background: white; color: #28a745; border-radius: 8px; cursor: pointer; font-weight: 600;">
            Одобрено
        </button>
        <button onclick="filterUnbanRequests('rejected')" id="filterRejected" class="filter-btn" style="flex: 1; padding: 10px; border: 2px solid #dc3545; background: white; color: #dc3545; border-radius: 8px; cursor: pointer; font-weight: 600;">
            Отклонено
        </button>
    </div>

    <!-- Таблица запросов -->
    <div style="overflow-x: auto;">
        <table class="admin-table" id="unbanRequestsTable">
            <thead>
                <tr>
                    <th>ID</th>
                    <th>Пользователь</th>
                    <th>User ID</th>
                    <th>Дата запроса</th>
                    <th>Статус</th>
                    <th>Действия</th>
                </tr>
            </thead>
            <tbody id="unbanRequestsBody">
                <tr>
                    <td colspan="6" style="text-align: center; padding: 20px; color: var(--gray);">
                        Загрузка...
                    </td>
                </tr>
            </tbody>
        </table>
    </div>
    </div>

            <!-- ============= СЕКЦИЯ ПРОСМОТРА ОТЧЕТОВ О БАГАХ ============= -->
            <div id="bugReportsSection" style="margin-top: 30px; padding: 20px; background: #fff3cd; border-radius: 12px; border: 2px solid #ff9500;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h3 style="margin: 0; font-size: 18px; font-weight: 700;">🐛 Отчеты о багах</h3>
                    <button onclick="refreshBugReports()" style="background: var(--blue); color: white; border: none; padding: 8px 16px; border-radius: 8px; cursor: pointer; font-weight: 600;">
                        🔄 Обновить
                    </button>
                </div>

                <!-- Статистика -->
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-bottom: 20px;">
                    <div style="background: white; border-radius: 12px; padding: 15px; text-align: center;">
                        <div style="font-size: 24px; font-weight: 800; color: #ff9500;" id="newBugsCount">0</div>
                        <div style="font-size: 12px; color: #666; margin-top: 5px;">Новые</div>
                    </div>
                    <div style="background: white; border-radius: 12px; padding: 15px; text-align: center;">
                        <div style="font-size: 24px; font-weight: 800; color: #007aff;" id="readBugsCount">0</div>
                        <div style="font-size: 12px; color: #666; margin-top: 5px;">Прочитано</div>
                    </div>
                    <div style="background: white; border-radius: 12px; padding: 15px; text-align: center;">
                        <div style="font-size: 24px; font-weight: 800; color: #28a745;" id="resolvedBugsCount">0</div>
                        <div style="font-size: 12px; color: #666; margin-top: 5px;">Решены</div>
                    </div>
                </div>

                <!-- Таблица отчетов -->
                <div style="max-height: 300px; overflow-y: auto;">
                    <table style="width: 100%; border-collapse: collapse; font-size: 13px;">
                        <thead style="background: #ff9500; color: white; font-weight: 700; position: sticky; top: 0;">
                            <tr>
                                <th style="padding: 10px; text-align: left; border: 1px solid #ddd;">Категория</th>
                                <th style="padding: 10px; text-align: left; border: 1px solid #ddd;">Описание</th>
                                <th style="padding: 10px; text-align: left; border: 1px solid #ddd;">От кого</th>
                                <th style="padding: 10px; text-align: center; border: 1px solid #ddd;">Статус</th>
                                <th style="padding: 10px; text-align: center; border: 1px solid #ddd;">Дата</th>
                                <th style="padding: 10px; text-align: center; border: 1px solid #ddd;">Действие</th>
                            </tr>
                        </thead>
                        <tbody id="bugReportsTableBody">
                            <tr style="background: white;">
                                <td colspan="6" style="padding: 20px; text-align: center; color: #888;">Загрузка...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Раздел Техническое Обслуживание -->
            <div id="maintenanceSection" style="margin-top: 30px; padding: 20px; background: #e8d5ff; border-radius: 12px; border: 2px solid #9c27b0;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h3 style="margin: 0; font-size: 18px; font-weight: 700;">⚙️ Техническое обслуживание</h3>
                    <div id="maintenanceStatus" style="background: #28a745; color: white; padding: 6px 12px; border-radius: 8px; font-size: 13px; font-weight: 600;">Карта активна</div>
                </div>

                <div style="background: white; border-radius: 12px; padding: 15px; margin-bottom: 15px;">
                    <p style="margin: 0 0 15px 0; font-size: 14px; color: #333;">Закройте карту для технического обслуживания. Пользователи увидят уведомление:</p>
                    <input type="text" id="maintenanceMessage" placeholder="Введите сообщение пользователям (макс 100 символов)" 
                           style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 8px; font-size: 14px; margin-bottom: 15px; box-sizing: border-box;"
                           maxlength="100" value="⚠️ Техническое обслуживание. Приносим извинения.">
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                    <button onclick="enableMaintenance()" style="background: var(--red); color: white; border: none; padding: 12px 16px; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 14px;">
                        🔴 Закрыть карту на ТО
                    </button>
                    <button onclick="disableMaintenance()" style="background: #28a745; color: white; border: none; padding: 12px 16px; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 14px;">
                        🟢 Открыть карту
                    </button>
                </div>
            </div>

            <!-- Админ: массовое уведомление и режим невидимки -->
            <div id="adminBroadcastSection" style="margin-top: 30px; padding: 20px; background: #fff; border-radius: 12px; border: 2px solid #d4af37;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                    <h3 style="margin: 0; font-size: 18px; font-weight: 700;">👑 Админ-центр</h3>
                    <div class="admin-rank">Admin SafeDrive</div>
                </div>
                <div style="font-size: 13px; color: #666; margin-bottom: 10px;">Массовое уведомление для всех онлайн пользователей:</div>
                <textarea id="adminBroadcastText" placeholder="Например: Внимание! Очередь на КПП выросла до 5 часов!" style="width: 100%; min-height: 80px; padding: 10px; border: 1px solid #ddd; border-radius: 8px; font-size: 13px; box-sizing: border-box; margin-bottom: 10px;"></textarea>
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <button onclick="sendAdminBroadcast(false)" style="flex: 1; background: #111; color: #fff; border: none; padding: 10px 12px; border-radius: 8px; font-weight: 700; cursor: pointer;">📣 Отправить текст</button>
                    <button onclick="sendAdminBroadcast(true)" style="flex: 1; background: #ff9500; color: #fff; border: none; padding: 10px 12px; border-radius: 8px; font-weight: 700; cursor: pointer;">🔊 Текст + сигнал</button>
                </div>
                <div id="adminBroadcastStatus" style="margin-top: 8px; font-size: 12px; color: #666; min-height: 16px;"></div>
                <div style="margin-top: 15px; padding-top: 12px; border-top: 1px dashed #e0e0e0; display: flex; align-items: center; justify-content: space-between; gap: 10px;">
                    <div style="font-size: 13px; font-weight: 700;">🕵️ Режим невидимки</div>
                    <button id="adminInvisibleToggle" onclick="toggleAdminInvisible()" style="background: #f0f0f5; color: #333; border: none; padding: 8px 12px; border-radius: 8px; font-weight: 700; cursor: pointer;">ВЫКЛ</button>
                </div>
            </div>
    
    <button class="main-btn" onclick="closeAdminModal()" style="margin-top: 20px;">Закрыть</button>
        </div>
    </div>

<!-- Модальное окно для рассмотрения запроса -->
<div id="reviewUnbanModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h3>🔍 Рассмотрение запроса на разбан</h3>
            <button class="modal-close" onclick="closeReviewUnbanModal()">×</button>
        </div>

        <div id="reviewUnbanContent">
            <!-- Информация о запросе -->
            <div style="background: #f0f0f5; border-radius: 12px; padding: 15px; margin-bottom: 20px;">
                <div style="margin-bottom: 10px;">
                    <strong>Пользователь:</strong> <span id="reviewUsername">-</span>
                </div>
                <div style="margin-bottom: 10px;">
                    <strong>User ID:</strong> <span id="reviewUserId">-</span>
                </div>
                <div style="margin-bottom: 10px;">
                    <strong>Дата запроса:</strong> <span id="reviewCreatedAt">-</span>
                </div>
                <div>
                    <strong>Информация о бане:</strong> <span id="reviewBanInfo">-</span>
                </div>
            </div>

            <!-- Комментарий -->
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; font-weight: 600;">Комментарий модератора:</label>
                <textarea id="reviewComment" 
                    style="width: 100%; min-height: 100px; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-family: inherit; font-size: 14px; resize: vertical;"
                    placeholder="Опишите причину решения..."></textarea>
            </div>

            <!-- Кнопки действий -->
            <div style="display: flex; gap: 10px;">
                <button onclick="approveUnbanRequest()" 
                    style="flex: 1; background: #28a745; color: white; border: none; padding: 14px; border-radius: 12px; font-size: 15px; font-weight: 700; cursor: pointer;">
                    ✅ Одобрить и снять бан
                </button>
                <button onclick="rejectUnbanRequest()" 
                    style="flex: 1; background: #dc3545; color: white; border: none; padding: 14px; border-radius: 12px; font-size: 15px; font-weight: 700; cursor: pointer;">
                    ❌ Отклонить запрос
                </button>
            </div>
        </div>
    </div>
</div>
    
    <!-- Обязательное окно правил при первом входе -->
    <div id="rulesModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 style="margin: 0;">Правила</h2>
            </div>
            <div style="line-height: 1.5; color: #333; font-size: 14px;">
                <p style="margin-top: 0;"><strong>Добро пожаловать в Safe Drive 180!</strong></p>
                <p>Перед использованием, пожалуйста, подтвердите, что вы согласны с правилами:</p>
                <p style="margin: 8px 0;">Приложение используется только для обмена гражданской информацией о дорожной обстановке (помощь, опасности, ДТП, работы).</p>
                <p style="margin: 8px 0;">Запрещено размещение любой информации, связанной с безопасностью региона или военными объектами.</p>
                <p style="margin: 8px 0;">Вы несете личную ответственность за соблюдение ПДД.</p>
                <p style="margin: 8px 0 16px 0;">Нажимая «Принимаю», вы подтверждаете, что будете использовать сервис только в гражданских целях для помощи другим водителям.</p>
                <p style="margin: 8px 0 0 0;"><strong>Цель проекта:</strong> снижение аварийности и взаимоподдержка граждан в сложных дорожных условиях.</p>
            </div>
            <button id="rulesAcceptBtn" class="main-btn" style="margin-top: 10px;">ПРИНИМАЮ И СОГЛАСЕН</button>
        </div>
    </div>

    <!-- Модальное окно для регистрации (только данные об авто) -->
    <div id="registrationModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 style="margin: 0;">Завершите профиль</h2>
            </div>
            <div style="text-align: center; margin-bottom: 20px;">
                <div class="profile-avatar">👤</div>
                <div class="profile-name" id="reg-user-name">Загрузка...</div>
            </div>
            <form class="registration-form" onsubmit="registerDriver(event)">
                <div class="form-group">
                    <label>Марка/Модель автомобиля:</label>
                    <input type="text" id="driver-car" placeholder="Например: Toyota Camry">
                </div>
                <div class="form-group">
                    <label>Номер автомобиля (необязательно):</label>
                    <input type="text" id="driver-plate" placeholder="Например: A123BC 77">
                </div>
                <button type="submit" class="main-btn" style="margin-top: 15px;">ЗАВЕРШИТЬ</button>
            </form>
        </div>
    </div>
    
    <!-- Модальное окно профиля -->
    <div id="profileModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 style="margin: 0;">Мой профиль</h2>
                <button class="modal-close" onclick="closeProfileModal()">✕</button>
            </div>
            <div class="profile-header">
                <div class="profile-avatar" id="profile-avatar-display" onclick="changeAvatar()" style="cursor: pointer; position: relative;" title="Нажмите чтобы изменить">👤</div>
                <input type="hidden" id="profile-avatar-value" value="👤">
                <input type="hidden" id="profile-avatar-url" value="">
                <button class="main-btn" onclick="document.getElementById('profile-photo-input').click()" style="margin-top: 10px; font-size: 12px; padding: 8px; background: #34c759;">📸 Загрузить фото аватара</button>
                <input type="file" id="profile-photo-input" style="display: none;" accept="image/*">
                <div class="profile-name" id="profile-name-text">Загрузка...</div>
                <div id="profile-admin-badges" style="display: none; margin-top: 6px; justify-content: center; align-items: center; gap: 10px; flex-wrap: wrap;">
                    <div class="admin-rank" id="profile-admin-rank">Admin SafeDrive</div>
                    <div class="admin-online"><span class="admin-online-dot"></span><span id="profile-admin-online">На связи</span></div>
                </div>
                <div style="margin-top: 15px; border: 1px solid #ddd; border-radius: 10px; padding: 10px; background: #f9f9f9;">
                    <div class="form-group">
                        <label style="font-size: 12px; color: var(--gray);">Модель автомобиля:</label>
                        <input type="text" id="edit-car-model" placeholder="Toyota Camry" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 6px; box-sizing: border-box; font-size: 14px;">
                    </div>
                    <div class="form-group">
                        <label style="font-size: 12px; color: var(--gray);">Номер автомобиля:</label>
                        <input type="text" id="edit-car-plate" placeholder="A123BC 77" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 6px; box-sizing: border-box; font-size: 14px;">
                    </div>
                    <button class="main-btn" onclick="saveProfileChanges()" style="font-size: 13px; padding: 10px; margin-top: 10px;">Сохранить изменения</button>
                </div>
            </div>
            
            <div class="rating-card">
                <div class="rating-label">Ваш уровень взаимовыручки</div>
                <div class="rating-value" id="profile-rating">0</div>
            </div>
            
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-value" id="profile-marks-count">0</div>
                    <div class="stat-label">Отправлено меток</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="profile-votes-sum">0</div>
                    <div class="stat-label">Очков кармы</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="profile-likes">0</div>
                    <div class="stat-label">Подтверждений</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="profile-dislikes">0</div>
                    <div class="stat-label">Спорных голосов</div>
                </div>
            </div>
            
            <div style="background: #f9f9f9; border-radius: 12px; padding: 12px; margin-bottom: 15px; text-align: center;">
                <div style="font-size: 12px; color: var(--gray); margin-bottom: 5px;">Статус</div>
                <div id="profile-trust-status" style="font-size: 16px; font-weight: 800; color: var(--blue);">🎯 Обычный водитель</div>
            </div>
            
            <button class="main-btn" onclick="openRatingsModal()" style="margin-bottom: 10px; background: #34c759;">ГЛОБАЛЬНЫЙ УРОВЕНЬ ВЗАИМОВЫРУЧКИ</button>
            
            <!-- Настройки озвучки уведомлений -->
            <div style="background: #f0f0f5; border-radius: 12px; padding: 12px; margin-bottom: 15px;">
                <div style="font-size: 13px; font-weight: 700; color: #000; margin-bottom: 10px;">🔊 Стиль озвучки уведомлений</div>
                <div style="display: flex; gap: 8px;">
                    <button onclick="setVoiceStyle('standard')" id="voiceStyleStandard" class="main-btn" style="flex: 1; background: #34c759; padding: 10px; font-size: 12px; border-radius: 8px;">
                        📢 Стандартный
                    </button>
                    <button onclick="setVoiceStyle('cheeky')" id="voiceStyleCheeky" class="main-btn" style="flex: 1; background: #9c9c9c; padding: 10px; font-size: 12px; border-radius: 8px;">
                        😎 Дерзкий
                    </button>
                </div>
                <div style="font-size: 11px; color: var(--gray); margin-top: 8px; text-align: center;">
                    <span id="voiceStyleDescription">Выбран: Стандартный стиль</span>
                </div>
            </div>

            <div style="background: #f0f0f5; border-radius: 12px; padding: 12px; margin-bottom: 15px;">
                <div style="font-size: 13px; font-weight: 700; color: #000; margin-bottom: 10px;">🗣️ Голосовые уведомления</div>
                <label style="display:flex; align-items:center; justify-content:space-between; gap:10px; font-size: 12px; font-weight:700; color:#111;">
                    <span>Включить озвучку</span>
                    <input id="voice-enable" type="checkbox" style="width:22px; height:22px;">
                </label>
                <div style="font-size: 11px; color: var(--gray); margin-top: 8px; text-align: center;">
                    Работает через системный синтез речи. В фоне зависит от Android/WebView.
                </div>
            </div>

            <div style="background: #f0f0f5; border-radius: 12px; padding: 12px; margin-bottom: 15px;">
                <div style="font-size: 13px; font-weight: 700; color: #000; margin-bottom: 10px;">🗺️ Движок карты</div>
                <button onclick="toggleMapEngineFromUI()" id="mapEngineSettingsBtn" class="main-btn" style="width:100%; background:#007aff; padding:10px; font-size:12px; border-radius:8px;">
                    Переключить ymaps2 / ymaps3
                </button>
                <button onclick="toggleMap3dFromUI()" id="map3dSettingsBtn" class="main-btn" style="width:100%; margin-top:8px; background:#111; color:#f5c64a; border:1px solid rgba(245,198,66,0.6); box-shadow:0 0 0 1px rgba(245,198,66,0.15); padding:10px; font-size:12px; border-radius:8px;">
                    3D: ВЫКЛ
                </button>
                <div id="mapEngineSettingsHint" style="font-size: 11px; color: var(--gray); margin-top: 8px; text-align: center;">
                    Текущий режим: —
                </div>
                <div id="map3dSettingsHint" style="font-size: 11px; color: var(--gray); margin-top: 6px; text-align: center;">
                    3D доступно только в ymaps3
                </div>
            </div>

            <div style="background: #f0f0f5; border-radius: 12px; padding: 12px; margin-bottom: 15px;">
                <div style="font-size: 13px; font-weight: 700; color: #000; margin-bottom: 10px;">📍 Оповещения по расстоянию</div>
                <div style="display: flex; gap: 8px;">
                    <button onclick="setProximityMode(false)" id="proximityModeAlways" class="main-btn" style="flex: 1; background: #34c759; padding: 10px; font-size: 12px; border-radius: 8px;">
                        Всегда
                    </button>
                    <button onclick="setProximityMode(true)" id="proximityModeFollow" class="main-btn" style="flex: 1; background: #9c9c9c; padding: 10px; font-size: 12px; border-radius: 8px;">
                        Только при автослежении
                    </button>
                </div>
                <div style="font-size: 11px; color: var(--gray); margin-top: 8px; text-align: center;">
                    <span id="proximityModeDescription">Выбран: Всегда</span>
                </div>
            </div>

            <div style="background: #f0f0f5; border-radius: 12px; padding: 12px; margin-bottom: 15px;">
                <div style="font-size: 13px; font-weight: 700; color: #000; margin-bottom: 8px;">🧭 Дистанция предупреждения</div>
                <div style="font-size: 11px; color: var(--gray); margin-bottom: 8px; text-align: center;">
                    <span id="warningDistanceLabel">800 м</span>
                </div>
                <input id="warningDistanceRange" type="range" min="300" max="2000" step="100" value="800"
                    oninput="setWarningDistance(this.value)"
                    style="width: 100%;">
                <div style="display: flex; justify-content: space-between; font-size: 10px; color: var(--gray); margin-top: 6px;">
                    <span>300 м</span><span>2.0 км</span>
                </div>
            </div>
            
            <button class="main-btn" onclick="logout()">ВЫЙТИ</button>
        </div>
    </div>
    
    <!-- Модальное окно для редактирования аватара -->
    <div id="avatarEditorModal" class="modal">
        <div class="modal-content" style="width: 90%; max-width: 400px;">
            <div class="modal-header">
                <h2 style="margin: 0;">Редактор аватара</h2>
                <button class="modal-close" onclick="closeAvatarEditor()">✕</button>
            </div>
            <div style="text-align: center; padding: 20px;">
                <!-- Круглый контейнер для предпросмотра -->
                <div style="position: relative; width: 200px; height: 200px; margin: 0 auto 20px; border-radius: 50%; overflow: hidden; border: 2px solid var(--blue); background: #f0f0f0;">
                    <img id="avatarEditorImage" style="position: absolute; width: 100%; height: 100%; object-fit: cover; cursor: grab;" alt="Avatar">
                </div>
                
                <!-- Контролы для редактирования -->
                <div style="padding: 0 10px;">
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; text-align: left; font-size: 12px; color: var(--gray); margin-bottom: 5px;">Масштаб (зум):</label>
                        <input type="range" id="avatarZoom" min="1" max="3" step="0.1" value="1" style="width: 100%; cursor: pointer;">
                        <div style="font-size: 11px; color: var(--gray); text-align: right;">
                            <span id="avatarZoomValue">100</span>%
                        </div>
                    </div>
                    
                    <div style="margin-bottom: 15px;">
                        <label style="display: block; text-align: left; font-size: 12px; color: var(--gray); margin-bottom: 5px;">Смещение по X:</label>
                        <input type="range" id="avatarOffsetX" min="-50" max="50" value="0" style="width: 100%; cursor: pointer;">
                    </div>
                    
                    <div style="margin-bottom: 20px;">
                        <label style="display: block; text-align: left; font-size: 12px; color: var(--gray); margin-bottom: 5px;">Смещение по Y:</label>
                        <input type="range" id="avatarOffsetY" min="-50" max="50" value="0" style="width: 100%; cursor: pointer;">
                    </div>
                    
                    <button class="main-btn" onclick="saveAvatarEdit()" style="width: 100%; margin-bottom: 10px;">✅ СОХРАНИТЬ</button>
                    <button class="main-btn" onclick="closeAvatarEditor()" style="width: 100%; background: #999;">Отмена</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Модальное окно для просмотра фото в полный размер -->
    <input type="hidden" id="photoUrl" value="">
    <div id="photoViewerModal" class="modal" onclick="closePhotoViewer()">
        <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; align-items: center; justify-content: center; padding: 20px;" onclick="event.stopPropagation()">
            <div style="position: relative; max-width: 90vw; max-height: 90vh;">
                <button class="modal-close" onclick="closePhotoViewer()" style="position: absolute; top: -50px; right: 0; font-size: 30px;">✕</button>
                <button class="modal-close" onclick="deletePhotoFromChat()" style="position: absolute; top: -50px; right: 40px; font-size: 24px; background: #ff3b30; color: white; border: none; border-radius: 50%; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; cursor: pointer; padding: 0;" title="Удалить фото">🗑️</button>
                <img id="photoViewerImage" src="" style="max-width: 100%; max-height: 90vh; border-radius: 12px; box-shadow: 0 10px 40px rgba(0,0,0,0.3);" alt="Photo">
            </div>
        </div>
    </div>
    
    <!-- Модальное окно глобального уровня взаимовыручки -->
    <div id="ratingsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 style="margin: 0;">🏆 Уровень взаимовыручки</h2>
                <button class="modal-close" onclick="closeRatingsModal()">✕</button>
            </div>
            
            <div style="font-size: 12px; color: var(--gray); margin-bottom: 15px; text-align: center;">
                Участники сортированы по вкладу в взаимопомощь. 🛟 = выручатор (50+ очков)
            </div>
            
            <div style="max-height: 500px; overflow-y: auto;">
                <div id="ratingsList" style="text-align: center; color: var(--gray);">Загрузка уровней взаимовыручки...</div>
            </div>
            
            <button class="main-btn" onclick="closeRatingsModal()" style="margin-top: 15px;">Закрыть</button>
        </div>
    </div>
    
    <!-- Модальное окно ленты событий -->
    <div id="activityModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 style="margin: 0;">📡 Лента событий</h2>
                <button class="modal-close" onclick="closeActivityModal()">✕</button>
            </div>
            
            <div style="font-size: 12px; color: var(--gray); margin-bottom: 10px; text-align: center;">
                Рабочая активность водителей в реальном времени
            </div>

            <div id="activityHeatmap" class="activity-heatmap">
                <div class="heatmap-header">
                    <div class="heatmap-title">🔥 Тепловая карта вашей активности</div>
                    <div class="heatmap-toggle" id="heatmapToggle">
                        <button type="button" data-mode="day">День</button>
                        <button type="button" data-mode="week" class="active">Неделя</button>
                        <button type="button" data-mode="month">Месяц</button>
                    </div>
                </div>
                <div class="heatmap-header" style="margin-top: 6px;">
                    <div class="heatmap-title" style="font-size: 12px; color: #666;">Типы</div>
                    <div class="heatmap-toggle" id="heatmapTypeToggle">
                        <button type="button" data-type="all" class="active">Все</button>
                        <button type="button" data-type="dps_specbat">ДПС + Спецбат</button>
                    </div>
                </div>
                <div class="heatmap-legend" id="heatmapLegend">
                    <span>Мало</span>
                    <span class="chip"></span>
                    <span class="chip" style="background: rgba(0,122,255,0.35);"></span>
                    <span class="chip" style="background: rgba(0,122,255,0.6);"></span>
                    <span class="chip" style="background: rgba(0,122,255,0.85);"></span>
                    <span>Много</span>
                </div>
                <div class="heatmap-scroll">
                    <div id="heatmapGrid" class="heatmap-grid"></div>
                </div>
                <div id="heatmapSummary" class="heatmap-summary">Загрузка...</div>
            </div>
            
            <div id="activityFeed" style="max-height: 450px; overflow-y: auto; border: 1px solid #e0e0e0; border-radius: 12px; padding: 10px;">
                <div style="text-align: center; color: var(--gray); padding: 20px;">⏳ Загрузка событий...</div>
            </div>
            
            <button class="main-btn" onclick="closeActivityModal()" style="margin-top: 15px;">Закрыть</button>
        </div>
    </div>
    
    <div class="bottom-ui action-panel">
        <div class="action-card hidden" id="actionCard">
            <button class="action-card-close" onclick="toggleActionCard()">✕</button>
            <span class="addr-label" id="addr-text">Определение адреса...</span>
            <div class="markers-counter" id="markersCounter">Загрузка...</div>
            <div id="markerRenderModeControl" style="display:flex; gap:6px; margin-bottom:8px;">
                <button id="markerRenderAllBtn" class="main-btn" onclick="setMarkerRenderMode('all')" style="flex:1; padding:7px 10px; font-size:12px; border-radius:8px; background:#9c9c9c;">🌍 Все</button>
                <button id="markerRenderNearbyBtn" class="main-btn" onclick="setMarkerRenderMode('nearby')" style="flex:1; padding:7px 10px; font-size:12px; border-radius:8px; background:#34c759;">📍 Рядом</button>
            </div>
            <div class="weather-widget" id="weatherWidget">🌦 Погода: загрузка...</div>
            <div class="type-selector">
                <div class="type-tabs">
                    <button class="type-tab-btn active" data-category="patrol" onclick="switchTypeCategory('patrol', this)">🛡️ ПАТРУЛЬ</button>
                    <button class="type-tab-btn" data-category="help" onclick="switchTypeCategory('help', this)">🤝 ВЗАИМОПОМОЩЬ</button>
                </div>

                <div class="type-group active" data-category="patrol">
                    <div class="type-group-title patrol">🛡️ ДОРОЖНЫЙ ПАТРУЛЬ</div>
                    <button data-type="dps" onclick="setType('dps', this)" class="type-btn active"><div class="icon-circle">👮</div><span>ДПС</span></button>
                    <button data-type="patrol" onclick="setType('patrol', this)" class="type-btn"><div class="icon-circle">🚔</div><span>Рейд</span></button>
                    <button data-type="specbat" onclick="setType('specbat', this)" class="type-btn"><div class="icon-circle">🛡️</div><span>Спецбат</span></button>
                    <button data-type="motobat" onclick="setType('motobat', this)" class="type-btn"><div class="icon-circle">🏍️</div><span>Мотобат</span></button>
                    <button data-type="cargo_control" onclick="setType('cargo_control', this)" class="type-btn"><div class="icon-circle">🚛</div><span>Груз. контроль</span></button>
                </div>

                <div class="type-group" data-category="help">
                    <div class="type-group-title help">🤝 ВЗАИМОПОМОЩЬ</div>
                    <button data-type="sos" onclick="setType('sos', this)" class="type-btn"><div class="icon-circle">🆘</div><span>SOS</span></button>
                    <button data-type="dtp" onclick="setType('dtp', this)" class="type-btn"><div class="icon-circle">💥</div><span>ДТП</span></button>
                    <button data-type="danger" onclick="setType('danger', this)" class="type-btn"><div class="icon-circle">⚠️</div><span>Опасность</span></button>
                    <button data-type="works" onclick="setType('works', this)" class="type-btn"><div class="icon-circle">🛣️</div><span>Работы</span></button>
                    <button data-type="traffic_jam" onclick="setType('traffic_jam', this)" class="type-btn"><div class="icon-circle">🚗</div><span>Пробка</span></button>
                </div>
            </div>
            <input type="text" id="m-comm" style="width:100%; margin-bottom:10px; border-radius:10px; border:1px solid #ddd; padding:8px; box-sizing: border-box;" placeholder="Комментарий...">
            <button class="main-btn" onclick="addPoint()">ОТПРАВИТЬ</button>
        </div>
    </div>
<script>
    // Константы для подключения к Supabase базе данных
    const SUPABASE_URL = "https://phazbjchjhsruwalddis.supabase.co";
    const SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBoYXpiamNoamhzcnV3YWxkZGlzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzAxNDcyNjQsImV4cCI6MjA4NTcyMzI2NH0.juQSLL03uRb6ImiCul_UOOE4OwY3mXy-AuItwt2u9ds";
    // Telegram bot username (used to open/start the bot when user is not in Telegram)
    // Формат: '@YourBot'
    const BOT_USERNAME = '@DPSRADARDPR180bot';
    function createSupabaseClient(token = null) {
        const options = {
            auth: {
                persistSession: false,
                autoRefreshToken: false,
                detectSessionInUrl: false
            }
        };
        if (token) {
            options.global = { headers: { Authorization: `Bearer ${token}` } };
        }
        return window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY, options);
    }

    function clearSupabaseAuth() {
        closeRealtimeChannels();
        currentSupabaseToken = '';
        _sb = createSupabaseClient();
        try { window._sb = _sb; } catch(e) {}
        try {
            localStorage.removeItem('sb_jwt');
            localStorage.removeItem('sb_jwt_exp');
            Object.keys(localStorage).forEach((key) => {
                if (key.includes('-auth-token')) localStorage.removeItem(key);
            });
        } catch (e) {
            // ignore storage errors
        }
    }

    // Клиент Supabase для работы с БД
    let _sb = createSupabaseClient();
    let currentSupabaseToken = '';
    // Удобно для диагностики из DevTools: в некоторых WebView глобальный `let` не виден как переменная.
    try { window._sb = _sb; } catch(e) {}

    function setSupabaseAuth(token) {
        if (!token || typeof token !== 'string' || token.split('.').length !== 3) {
            clearSupabaseAuth();
            return;
        }
        if (currentSupabaseToken === token) return;
        currentSupabaseToken = token;
        closeRealtimeChannels();
        _sb = createSupabaseClient(token);
        try { window._sb = _sb; } catch(e) {}
        initRealtimeChannels();
    }

    let lastHelpHomeSyncAt = 0;
    async function syncHelpSubscriberHomeCoords(force = false) {
        try {
            if (!uid) return;
            if (!_sb) return;
            if (!Array.isArray(userLocation) || userLocation.length < 2) return;
            if (!gpsReliable) return;

            const now = Date.now();
            if (!force && lastHelpHomeSyncAt && (now - lastHelpHomeSyncAt) < 5 * 60 * 1000) return;
            lastHelpHomeSyncAt = now;

            const lat = Number(userLocation[0]);
            const lon = Number(userLocation[1]);
            if (!Number.isFinite(lat) || !Number.isFinite(lon)) return;
            // если геолокация не получена и браузер вернул 0,0 — не перетираем опорную точку
            if (Math.abs(lat) < 1e-9 && Math.abs(lon) < 1e-9) return;

            // В приватных чатах chat_id обычно совпадает с user_id (Telegram ID), поэтому обновляем по обоим вариантам.
            await _sb
                .from('telegram_help_subscribers')
                .update({
                    home_lat: lat,
                    home_lon: lon,
                    updated_at: new Date().toISOString()
                })
                .or(`user_id.eq.${String(uid)},chat_id.eq.${String(uid)}`);
        } catch (e) {
            // Если пользователь ещё не подписан в Telegram-боте (нет строки) — будет update 0 rows, это ок.
            // Если токена нет/просрочен — sync не нужен, auth восстановится через ensureSupabaseAuth.
        }
    }

    async function ensureSupabaseAuth() {
        function getJwtExp(token) {
            try {
                const parts = String(token || '').split('.');
                if (parts.length !== 3) return 0;
                const payloadPart = parts[1].replace(/-/g, '+').replace(/_/g, '/');
                const normalized = payloadPart + '='.repeat((4 - (payloadPart.length % 4)) % 4);
                const json = JSON.parse(atob(normalized));
                const exp = Number(json?.exp || 0);
                return Number.isFinite(exp) ? exp : 0;
            } catch (e) {
                return 0;
            }
        }

        const initData = window.Telegram?.WebApp?.initData;
        if (!initData) {
            try {
                const cachedToken = localStorage.getItem('sb_jwt') || '';
                const cachedExpRaw = Number(localStorage.getItem('sb_jwt_exp') || 0);
                const cachedExp = cachedExpRaw > 0 ? cachedExpRaw : getJwtExp(cachedToken);
                const nowSec = Math.floor(Date.now() / 1000);
                if (cachedToken && cachedToken.split('.').length === 3 && (!cachedExp || cachedExp > nowSec + 60)) {
                    setSupabaseAuth(cachedToken);
                    try {
                        const storedUid = localStorage.getItem('site_uid');
                        if (!uid && storedUid) uid = String(storedUid);
                    } catch(e) {}
                    return cachedToken;
                }
            } catch (e) {}
            return null;
        }

        try {
            const res = await fetch(`${SUPABASE_URL}/functions/v1/telegram-auth`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ initData })
            });
            if (!res.ok) {
                let errText = '';
                try { errText = await res.text(); } catch (e) { errText = ''; }
                clearSupabaseAuth();
                throw new Error(`telegram-auth failed (${res.status}): ${errText || 'empty response'}`);
            }
            const data = await res.json();
            if (data?.token && typeof data.token === 'string' && data.token.split('.').length === 3) {
                setSupabaseAuth(data.token);
                try {
                    localStorage.setItem('sb_jwt', data.token);
                    if (data.exp) localStorage.setItem('sb_jwt_exp', String(data.exp));
                } catch (e) {
                    // ignore storage errors
                }
                // после успешной авторизации можно синхронизировать координаты подписчика (если GPS уже известен)
                syncHelpSubscriberHomeCoords(true).catch(()=>{});
                return data.token;
            } else {
                clearSupabaseAuth();
                throw new Error('telegram-auth returned invalid token');
            }
        } catch (e) {
            const msg = String(e?.message || e || '');
            console.warn('Supabase auth failed:', msg);
            if (/invalid hash/i.test(msg)) {
                console.warn('⚠️ Telegram initData не совпадает с токеном бота. Откройте Mini App ИМЕННО из @DPSRADARDPR180bot (не из BotFather/пересланных ссылок), затем перезапустите карту.');
            }
            return null;
        }
    }

    function getRulesAcceptanceKey(userId) {
        return `rulesAccepted_${String(userId || '')}`;
    }

    const RULES_CONSENT_KEY = 'rules_v1';

    function hasAcceptedRules(userId) {
        if (!userId) return false;
        try {
            return localStorage.getItem(getRulesAcceptanceKey(userId)) === 'true';
        } catch (e) {
            return false;
        }
    }

    async function hasAcceptedRulesOnServer(userId) {
        if (!userId || !_sb) return false;
        try {
            const { data, error } = await _sb
                .from('user_consents')
                .select('accepted_at')
                .eq('user_id', String(userId))
                .eq('consent_key', RULES_CONSENT_KEY)
                .maybeSingle();
            if (error) return false;
            return !!data;
        } catch (e) {
            return false;
        }
    }

    function markRulesAccepted(userId) {
        if (!userId) return;
        try {
            localStorage.setItem(getRulesAcceptanceKey(userId), 'true');
        } catch (e) {
            console.warn('Не удалось сохранить принятие правил:', e?.message || e);
        }
    }

    async function markRulesAcceptedOnServer(userId) {
        if (!userId || !_sb) return;
        try {
            await _sb
                .from('user_consents')
                .upsert({
                    user_id: String(userId),
                    consent_key: RULES_CONSENT_KEY,
                    accepted_at: new Date().toISOString()
                }, { onConflict: 'user_id,consent_key' });
        } catch (e) {
            console.warn('Не удалось сохранить согласие на сервере:', e?.message || e);
        }
    }

    function showRulesModal(userId) {
        return new Promise((resolve) => {
            const modal = document.getElementById('rulesModal');
            const acceptBtn = document.getElementById('rulesAcceptBtn');
            if (!modal || !acceptBtn) {
                resolve(true);
                return;
            }

            if (acceptBtn._rulesHandler) {
                acceptBtn.removeEventListener('click', acceptBtn._rulesHandler);
            }

            const onAccept = async () => {
                markRulesAccepted(userId);
                await markRulesAcceptedOnServer(userId);
                modal.classList.remove('active');
                acceptBtn.removeEventListener('click', onAccept);
                acceptBtn._rulesHandler = null;
                resolve(true);
            };

            acceptBtn._rulesHandler = onAccept;
            acceptBtn.addEventListener('click', onAccept);
            modal.classList.add('active');
        });
    }

    async function ensureRulesAccepted(userId) {
        if (!userId) return true;
        if (hasAcceptedRules(userId)) return true;
        if (await hasAcceptedRulesOnServer(userId)) {
            markRulesAccepted(userId);
            return true;
        }
        return showRulesModal(userId);
    }
    
    // Вспомогательная функция для запросов к Supabase с таймаутом
    async function queryWithTimeout(promise, timeoutMs = 15000) {
        return Promise.race([
            promise,
            new Promise((_, reject) =>
                setTimeout(() => reject(new Error(`Timeout: нет ответа от сервера в течение ${timeoutMs/1000}с - проверьте сеть`)), timeoutMs)
            )
        ]);
    }

    function tryVibrate(ms = 15) {
        try {
            if (navigator.vibrate) navigator.vibrate(ms);
        } catch (e) {}
    }

    function sanitizeMediaUrl(raw) {
        const value = String(raw || '').trim();
        if (!value) return '';
        if (value.includes('${') || value.includes('}')) return '';
        if (/^data:image\//i.test(value)) return value;
        if (/^https?:\/\//i.test(value)) return value;
        if (value.startsWith('/')) return value;
        return value;
    }

    function isFeatureAllowedByPolicy(featureName) {
        try {
            const policy = document.permissionsPolicy || document.featurePolicy;
            if (!policy || typeof policy.allowsFeature !== 'function') return true;
            return !!policy.allowsFeature(String(featureName || ''));
        } catch (e) {
            return true;
        }
    }

    function applyResponsiveUiScale() {
        try {
            const h = Math.max(0, Number(window.innerHeight) || 0);
            const w = Math.max(0, Number(window.innerWidth) || 0);
            const isLandscape = w > h;

            // Базовая настройка: чем ниже экран — тем меньше UI.
            // Под реальные устройства:
            // - iPhone 14 Pro (CSS ~ 393x852)
            // - Redmi 12 (CSS обычно ~ 392..412 ширина, высота ~ 800..900)
            // На них scale должен быть 1.0.
            let scale = 1;

            if (isLandscape) {
                // В ландшафте высота резко меньше — уменьшаем сильнее
                scale = 0.86;
            } else if (h && h < 610) {
                scale = 0.86;
            } else if (h && h < 680) {
                scale = 0.92;
            } else if (h && h < 740) {
                scale = 0.96;
            } else if (h && h > 940 && w && w >= 430) {
                // Очень большие экраны (планшеты/фолды) — слегка увеличим читаемость
                scale = 1.02;
            }
            document.documentElement.style.setProperty('--ui-scale', String(scale));
        } catch (e) {}
    }

    // Responsive tuning on load + rotations
    try {
        window.addEventListener('resize', applyResponsiveUiScale, { passive: true });
        window.addEventListener('orientationchange', applyResponsiveUiScale, { passive: true });
        applyResponsiveUiScale();
    } catch (e) {}

    // ============= Telegram Mini App UI fixes (header overlay + viewport height) =============
    let tgViewportHeightPx = 0;

    function applyTelegramUiVars() {
        try {
            const isTg = !!window.Telegram?.WebApp;
            document.documentElement.style.setProperty('--tg-header-offset', isTg ? '45px' : '0px');
        } catch (e) {}

        try {
            const vh = Number(window.Telegram?.WebApp?.viewportHeight || 0);
            if (vh && Number.isFinite(vh)) {
                tgViewportHeightPx = Math.max(0, Math.round(vh));
                document.documentElement.style.setProperty('--tg-viewport-height', `${tgViewportHeightPx}px`);
            }
        } catch (e) {}
    }

    function initTelegramWebAppUi() {
        try {
            const wa = window.Telegram?.WebApp;
            if (!wa) {
                applyTelegramUiVars();
                return;
            }

            try { wa.ready(); } catch (e) {}
            try { wa.expand(); } catch (e) {}
            try { wa.setHeaderColor('#000000'); } catch (e) {}
            try { wa.enableClosingConfirmation(); } catch (e) {}

            applyTelegramUiVars();

            try {
                wa.onEvent?.('viewportChanged', () => {
                    applyTelegramUiVars();
                    try { updateTargetAnchorPosition(); } catch(e) {}
                });
            } catch (e) {}
        } catch (e) {}
    }

    try { initTelegramWebAppUi(); } catch (e) {}

    function getTelegramDisplayUser() {
        return window.Telegram?.WebApp?.initDataUnsafe?.user || siteTelegramUser;
    }

    function ensureTelegramLoginWidgetRendered() {
        try {
            // Login Widget нужен только для сайта (обычный браузер). Внутри Telegram Mini App он
            // либо не нужен (есть initData), либо будет блокироваться CSP у oauth.telegram.org.
            if (window.Telegram?.WebApp?.initData) return;

            const wrap = document.getElementById('tgLoginWidget');
            if (!wrap) return;
            if (wrap.__tgWidgetMounted) return;
            wrap.__tgWidgetMounted = true;

            const botUser = String(BOT_USERNAME || '').replace(/^@/, '').trim();
            if (!botUser) return;

            window.onTelegramSiteAuth = window.onTelegramSiteAuth || function(user) {
                handleTelegramSiteAuth(user).catch(()=>{});
            };

            const s = document.createElement('script');
            s.async = true;
            s.src = 'https://telegram.org/js/telegram-widget.js?22';
            s.setAttribute('data-telegram-login', botUser);
            s.setAttribute('data-size', 'large');
            s.setAttribute('data-radius', '12');
            s.setAttribute('data-request-access', 'write');
            s.setAttribute('data-onauth', 'onTelegramSiteAuth(user)');
            wrap.innerHTML = '';
            wrap.appendChild(s);
        } catch (e) {}
    }

    async function handleTelegramSiteAuth(user) {
        try {
            if (!user || !user.id || !user.hash) throw new Error('Invalid widget user');

            const res = await fetch(`${SUPABASE_URL}/functions/v1/telegram-login`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ user })
            });
            if (!res.ok) {
                const t = await res.text().catch(()=> '');
                throw new Error(`telegram-login failed (${res.status}): ${t}`);
            }
            const data = await res.json().catch(()=> null);
            const token = data?.token;
            if (!token || typeof token !== 'string' || token.split('.').length !== 3) throw new Error('telegram-login returned invalid token');

            setSupabaseAuth(token);
            uid = String(data?.user_id || user.id);
            siteTelegramUser = data?.user || user;
            try { window.__siteTelegramUser = siteTelegramUser; } catch(e) {}

            try {
                localStorage.setItem('sb_jwt', token);
                localStorage.setItem('site_uid', String(uid));
                if (data?.exp) {
                    localStorage.setItem('sb_jwt_exp', String(Number(data.exp) || 0));
                } else {
                    localStorage.setItem('sb_jwt_exp', String(Math.floor(Date.now()/1000) + 24*60*60));
                }
            } catch(e) {}

            try {
                const overlay = document.getElementById('tgAuthOverlay');
                if (overlay) overlay.style.display = 'none';
            } catch(e) {}

            // Подтянем профиль водителя (если уже есть)
            try {
                const { data: driver } = await _sb.from('drivers').select('user_id,name,car_model,car_plate').eq('user_id', uid).maybeSingle();
                if (driver) currentDriver = driver;
            } catch(e) {}

            // Продолжаем инициализацию приложения (initApp мог выйти раньше из-за отсутствия токена)
            try {
                initAppInProgress = false;
                initApp();
            } catch (e) {}
        } catch (e) {
            console.warn('handleTelegramSiteAuth error:', e?.message || e);
        }
    }

    /**
     * Auth Variant B (Monolith 180):
     * - Telegram Mini App: используем initData → Edge Function telegram-auth.
     * - Web/PWA: используем сохранённый sb_jwt; если нет — показываем оверлей с Telegram Login Widget.
     */
    async function checkAppEnvironment() {
        const overlay = document.getElementById('tgAuthOverlay');
        const splash = document.getElementById('splashScreen');

        const initData = window.Telegram?.WebApp?.initData;
        const tgUser = window.Telegram?.WebApp?.initDataUnsafe?.user;
        const isTelegram = !!(initData && tgUser);

        if (isTelegram) {
            // Mini App: авторизация должна обновляться через initData
            const token = await ensureSupabaseAuth();
            if (overlay) overlay.style.display = 'none';
            return { mode: 'telegram', isTelegram: true, token };
        }

        // Web/PWA: пробуем восстановить токен из localStorage
        const token = await ensureSupabaseAuth();
        if (token) {
            if (overlay) overlay.style.display = 'none';
            return { mode: 'web', isTelegram: false, token };
        }

        // Нет токена → показываем модалку входа и монтируем Telegram Login Widget
        try { ensureTelegramLoginWidgetRendered(); } catch (e) {}
        if (overlay) overlay.style.display = 'flex';
        if (splash) splash.classList.add('hidden');
        return { mode: 'web-need-auth', isTelegram: false, token: null };
    }

    // Открыть бот в Telegram (пытаемся сначала tg://, затем https://)
    function openTelegramBot() {
        try {
            const botUser = String(BOT_USERNAME || '').replace(/^@/, '').trim();
            const tgUrl = `tg://resolve?domain=${botUser}`;
            const webUrl = `https://t.me/${botUser}`;
            // Попытка открыть в приложении
            window.open(tgUrl, '_blank');
            // Через 300ms открываем веб-вариант как fallback
            setTimeout(() => { window.open(webUrl, '_blank'); }, 300);
        } catch (e) {
            console.warn('Не удалось открыть Telegram:', e);
            const botUser = String(BOT_USERNAME || '').replace(/^@/, '').trim();
            window.open(`https://t.me/${botUser}`, '_blank');
        }
    }
    
    // Иконки для разных типов дорожных событий
    const MAP_ICONS = {
        dps: '👮',
        patrol: '🚔',
        specbat: '🛡️',
        motobat: '🏍️',
        cargo_control: '🚛',
        sos: '🆘',
        dtp: '💥',
        danger: '⚠️',
        traffic_jam: '🚗',
        camera: '📸',
        works: '🛣️'
    };
    // ID текущего пользователя из Telegram (null если не авторизован)
    const rawTgId = window.Telegram?.WebApp?.initDataUnsafe?.user?.id;
    let uid = rawTgId ? String(rawTgId) : null;
    let siteTelegramUser = null; // Telegram Login Widget user (для входа через сайт)
    try { window.__siteTelegramUser = siteTelegramUser; } catch(e) {}
    // Переменные для карты и выбранного типа маркера (по умолчанию ДПС)
    let myMap, selectedType = 'dps';
    let preferredMapEngine = 'ymaps3';
    let activeMapEngine = 'ymaps2';
    let mapAdapter = null;
    // Текущее GPS местоположение пользователя
    let userLocation = null;
    let lastReliableUserLocation = null;
    let lastGpsAccuracyMeters = null;
    let gpsReliable = false;
    let gpsWarnedUnreliable = false;
    // ID отслеживания GPS (для остановки отслеживания)
    let gpsWatchId = null;
    // Маркер текущего местоположения на карте
    let userLocationMarker = null;
    // Для вычисления скорости: предыдущая позиция и время
    let lastUserPositionCoords = null; // [lat, lon]
    let lastUserPositionTime = null; // ms
    let userSpeedKmh = 0; // скорость в км/ч
    let userHeadingDeg = 0; // курс (0..360)
    let dynamicCourseEnabled = true;
    let dynamicCourseCompassDeg = null;
    let dynamicCourseGpsDeg = null;
    let dynamicCourseFusedDeg = null;
    let dynamicCourseLastCameraDeg = null;
    let dynamicCourseLastCompassTs = 0;
    let dynamicCourseCameraTimerId = null;
    let dynamicCourseCompassInit = false;
    const DYNAMIC_COURSE_TILT = 0.8;
    const DYNAMIC_COURSE_AHEAD_MIN_M = 450;
    const DYNAMIC_COURSE_AHEAD_MAX_M = 2300;
    const DYNAMIC_COURSE_UPDATE_MS = 450;
    // Текущие серверные ачивки (ключ -> count)
    let currentAchievementCounts = {};
    // Коллекция для маркеров (чтобы не удалять служебные geoObjects при обновлении)
    let markersCollection = null;
    // Флаг автоследования: если true — карта центрируется на пользователе при обновлении GPS
    let autoFollow = true;
    // Данные профиля текущего пользователя
    let currentDriver = null;
    // ID администратора (измените на свой ID Telegram)
    const ADMIN_ID = "5118431735";
    const ADMIN_RANK_LABEL = 'Admin SafeDrive';
    const ADMIN_TITLE_LABEL = 'Основатель';
    // Порог подтверждений для статуса "Проверенный водитель"
    const TRUST_LIKES_THRESHOLD = 20; // можно менять по необходимости
    const TYPE_CATEGORY_STORAGE_KEY = 'selected_type_category';
    const DYNAMIC_COURSE_ENABLED_KEY = 'dynamicCourseEnabled';
    const MAP_ENGINE_STORAGE_KEY = 'mapEnginePreference';
    const MAP_ENGINE_LEGACY_FORCE_KEY = 'mapEngineLegacyForce';
    const MAP_ENGINE_YM3_FAIL_KEY = 'mapEngineYm3Failed';
    const MAP_3D_MODE_KEY = 'map3dModeEnabled';
    const MAP_3D_MIN_ZOOM = 16.8;
    const MARKER_INSERT_NO_TS_EXP_KEY = 'markerInsertNoTsExp';
    const HELP_NOTIFY_AUTH_COOLDOWN_UNTIL_KEY = 'helpNotifyAuthCooldownUntil';
    // Порог подтверждений "уехали" для автоудаления метки
    const MARKER_LEAVE_THRESHOLD = 3; // если 3 человека нажали "Уехали" - метка удаляется
    // Флаг для проверки, является ли пользователь админом
    let isAdmin = false;
    // Флаг режима невидимости админа (глобально для всех клиентов)
    let adminInvisible = false;
    // Realtime-канал для админ-уведомлений и статусов
    let adminBroadcastChannel = null;
    // Realtime-каналы для мгновенного обновления карты и чата
    let markersRealtimeChannel = null;
    let messagesRealtimeChannel = null;
    let markersRealtimeTimer = null;
    let messagesRealtimeTimer = null;
    let adminInvisibleIntervalId = null;
    // Флаг: открыт ли собственный профиль (для блокировки настроек в чужом профиле)
    let isViewingOwnProfile = true;
    // Флаг инициализации приложения (чтобы не вызывать initApp повторно)
    let initAppInProgress = false;
    // Спидометр: видимость
    let speedometerEnabled = true;
    let map3dEnabled = false;
    // Анти-спам для меток
    const MARKER_RATE_LIMIT_MS = 120000;
    // Переменная для хранения выбранной фотографии
    let selectedChatPhoto = null;
    // Множество для отслеживания уже воспроизведенных уведомлений (чтобы не спамить звук)
    let notifiedMarkers = new Set();
    // Отслеживание уведомлений по расстоянию (marker_id -> уровень уведомления: 'far' или 'near')
    let distanceNotifications = new Map(); // { markerId: 'far'|'near' }
    // Тренд расстояния до маркера (marker_id -> { lastDistance, lastTrend, lastUpdate })
    let markerDistanceState = new Map();
    const MONOLITH_WARNING_OPTIONS = [300, 500, 1000, 2000];
    const MONOLITH_SOS_PRIORITY_RADIUS_METERS = 5000;
    const MONOLITH_POST_PASS_ASK_METERS = 200;
    const monolithStreetCache = new Map();
    const monolithStreetInflight = new Map();
    // Состояние динамического баннера приближения
    let proximityBannerState = {
        markerId: null,
        markerType: null,
        markerCoords: null,
        lastDistance: null,
        lastUpdateTs: 0
    };
    let proximityBannerIntervalId = null;
    let currentWarningAudio = null;
    let appNotifications = [];
    let patrolNotifBatch = { count: 0, lastMarker: null, timer: null };
    let notifFeedSyncIntervalId = null;
    const NOTIF_STORAGE_PREFIX = 'app_notifications_';
    const NOTIF_GROUP_WINDOW_MS = 5 * 60 * 1000;
    const NOTIF_MAX_ITEMS = 120;
    const NOTIF_MCHS_RETENTION_MS = 24 * 60 * 60 * 1000;
    const NOTIF_FEED_RADIUS_METERS = 20000;
    const NOTIF_FEED_MARKER_LOOKBACK_MS = 24 * 60 * 60 * 1000;
    const NOTIF_FEED_SYNC_INTERVAL_MS = 5 * 60 * 1000;
    const CRITICAL_DTP_CONFIRMATIONS = 3;
    const PATROL_TYPES = new Set(['dps', 'patrol', 'specbat', 'motobat', 'cargo_control']);
    const TARGET_MIN_TOP_PX = 120;
    const TARGET_CARD_GAP_PX = 90;
    let dtpHeatmapEnabled = false;
    let dtpHeatmapCollection = null;
    let dtpHeatmapCellsCache = [];
    let dtpHeatmapCacheLoadedAt = 0;
    let dtpHeatmapRenderTimer = null;
    const DTP_HEATMAP_CACHE_MS = 2 * 60 * 1000;
    const DTP_HEATMAP_LOOKBACK_DAYS = 30;
    const DTP_HEATMAP_MAX_POINTS = 1200;

    // "Зоркий глаз": точная теплокарта засад ДПС/Спецбат (свежесть 2–3 часа)
    let patrolHeatmapEnabled = false;
    let patrolHeatmapCollection = null;
    let patrolHeatmapCellsCache = [];
    let patrolHeatmapCacheLoadedAt = 0;
    let patrolHeatmapRenderTimer = null;
    const PATROL_HEATMAP_CACHE_MS = 60 * 1000;
    const PATROL_HEATMAP_LOOKBACK_HOURS = 3;
    const PATROL_HEATMAP_MAX_POINTS = 2500;
    const SAFE_DRIVE_NEWS_ITEMS = [
        {
            id: 'news_notif_feed_v1',
            icon: '🔵',
            title: 'Важные новости SafeDrive',
            body: 'Раздел «Уведомления» теперь показывает Погоду (Open‑Meteo), SOS и критичные ДТП.',
            createdAt: '2026-02-14T21:00:00.000Z',
            read: false,
            source: 'safedrive_news',
            priority: 'normal'
        }
    ];
    // Стиль озвучки: 'standard' (стандартный) или 'cheeky' (дерзкий)
    let voiceStyle = 'standard';
    // Оповещения по расстоянию только при автослежении
    let proximityRequiresFollow = false;
    // Дистанция предупреждения (в метрах)
    let warningDistanceMeters = 500;
    const MARKER_RENDER_MODE_KEY = 'markerRenderMode';
    let markerRenderMode = 'nearby'; // 'nearby' | 'all'
    // Флаг видимости нижнего виджета
    let actionCardVisible = false;
    // Флаг для отключения автосцентрирования GPS после размещения метки
    let disableAutoFollowOnce = false;
    // Кэш данных авторов для оптимизации запросов к БД
    let authorsCache = {};
    let authorsCacheTime = 0;
    const CACHE_DURATION = 300000; // Кэширование на 5 минут
    // Таймер для дебаунса loadMarkers
    let loadMarkersTimeout = null;
    let loadMarkersInFlight = false;
    let loadMarkersPending = false;

    function isAdminUserId(userId) {
        return String(userId) === String(ADMIN_ID);
    }

    function updateProfileAdminBadges(isAdminProfile) {
        const badges = document.getElementById('profile-admin-badges');
        const rankEl = document.getElementById('profile-admin-rank');
        if (!badges) return;
        if (isAdminProfile) {
            badges.style.display = 'flex';
            if (rankEl) rankEl.textContent = ADMIN_RANK_LABEL;
        } else {
            badges.style.display = 'none';
        }
    }

    // Функция для переключения видимости нижнего виджета
    function toggleActionCard() {
        actionCardVisible = !actionCardVisible;
        const card = document.getElementById('actionCard');
        const openBtn = document.getElementById('openActionBtn');
        if (actionCardVisible) {
            card.classList.remove('hidden');
            if (openBtn) openBtn.classList.remove('visible');
        } else {
            card.classList.add('hidden');
            if (openBtn) openBtn.classList.add('visible');
        }
        try { setRightActionsHidden(!!actionCardVisible); } catch(e) {}
        try {
            const panel = document.querySelector('.action-panel');
            if (panel) panel.classList.toggle('open', !!actionCardVisible);
        } catch (e) {}
        updateTargetAnchorPosition();
    }

    function setRightActionsHidden(hidden) {
        const bar = document.getElementById('rightBar');
        if (bar) bar.classList.toggle('hidden', !!hidden);
    }

    function updateTargetAnchorPosition() {
        const target = document.querySelector('.target');
        if (!target) return;

        target.style.transform = 'translate(-50%, -50%)';

        // Базируемся на реальной видимой области карты (а не на window.innerHeight),
        // чтобы нижний виджет не перекрывал прицел.
        let mapRect = null;
        try {
            mapRect = document.getElementById('map')?.getBoundingClientRect?.() || null;
        } catch (e) {
            mapRect = null;
        }
        const mapTop = mapRect ? mapRect.top : 0;
        const baseBottom = mapRect ? mapRect.bottom : window.innerHeight;
        const tgBottom = (tgViewportHeightPx && tgViewportHeightPx > 0) ? (mapTop + tgViewportHeightPx) : 0;
        const mapBottom = tgBottom ? Math.min(baseBottom, tgBottom) : baseBottom;

        const card = document.getElementById('actionCard');
        if (!actionCardVisible || !card || card.classList.contains('hidden')) {
            const mid = mapTop + (mapBottom - mapTop) * 0.5;
            target.style.top = `${Math.round(mid)}px`;
            return;
        }

        const cardRect = card.getBoundingClientRect();
        const visibleBottom = Math.max(mapTop + 80, Math.min(mapBottom, cardRect.top - TARGET_CARD_GAP_PX));
        const desiredTop = Math.max(TARGET_MIN_TOP_PX, mapTop + (visibleBottom - mapTop) * 0.5);
        target.style.top = `${Math.round(desiredTop)}px`;
    }

    function getTargetPlacementCoords() {
        if (!myMap) return [48.01, 37.80];

        const fallback = myMap.getCenter();
        const isYm3Active = String(activeMapEngine || '').includes('ymaps3') || String(mapAdapter?.mode || '').includes('ymaps3');
        if (isYm3Active) {
            if (Array.isArray(fallback) && fallback.length >= 2 && Number.isFinite(Number(fallback[0])) && Number.isFinite(Number(fallback[1]))) {
                return [Number(fallback[0]), Number(fallback[1])];
            }
            return [48.01, 37.80];
        }
        try {
            const target = document.querySelector('.target');
            const projection = myMap.options?.get?.('projection');
            if (!target || !projection || !myMap.converter?.pageToGlobal) return fallback;

            const rect = target.getBoundingClientRect();
            const pixelPoint = [
                rect.left + rect.width / 2,
                rect.top + rect.height / 2
            ];

            const globalPixels = myMap.converter.pageToGlobal(pixelPoint);
            const coords = projection.fromGlobalPixels(globalPixels, myMap.getZoom());

            if (Array.isArray(coords) && coords.length >= 2 && Number.isFinite(Number(coords[0])) && Number.isFinite(Number(coords[1]))) {
                return [Number(coords[0]), Number(coords[1])];
            }
        } catch (e) {
            console.warn('Не удалось вычислить координаты по центральной метке:', e?.message || e);
        }
        return fallback;
    }

    function setDtpHeatmapUiState(enabled) {
        const btn = document.getElementById('dtpHeatmapBtn');
        if (btn) btn.classList.toggle('active', !!enabled);
        const overlay = document.getElementById('mapDimmingOverlay');
        if (overlay) overlay.classList.toggle('active', !!enabled);
    }

    function setPatrolHeatmapUiState(enabled) {
        const btn = document.getElementById('patrolHeatmapBtn');
        if (btn) btn.classList.toggle('active', !!enabled);
    }

    function getPatrolHeatColor(type, norm) {
        const n = Math.max(0, Math.min(1, Number(norm) || 0));
        // ДПС: жёлто‑оранжевый, Спецбат: фиолетовый/красный
        if (String(type) === 'specbat') {
            // purple -> deep red
            const r = Math.round(175 + (255 - 175) * n);
            const g = Math.round(82 + (59 - 82) * n);
            const b = Math.round(222 + (48 - 222) * n);
            return `rgb(${r},${g},${b})`;
        }
        // dps
        const r = Math.round(255);
        const g = Math.round(214 + (120 - 214) * n);
        const b = Math.round(10 + (0 - 10) * n);
        return `rgb(${r},${g},${b})`;
    }

    function buildDotSvg(color, sizePx, alpha = 0.9) {
        const s = Math.max(16, Math.min(28, Math.round(sizePx || 22)));
        const r = Math.round(s / 2);
        const stroke = 'rgba(0,0,0,0.10)';
        const fill = String(color || 'rgb(255,159,10)');
        const svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="${s}" height="${s}" viewBox="0 0 ${s} ${s}">
  <circle cx="${r}" cy="${r}" r="${Math.max(3, r - 1)}" fill="${fill}" fill-opacity="${Math.max(0.2, Math.min(1, alpha)).toFixed(2)}" stroke="${stroke}" stroke-width="1"/>
</svg>`;
        return 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(svg);
    }

    function getPatrolHeatmapCellDegrees(zoom) {
        // Очень строгая сетка: чтобы точки были "на конкретном кармане/съезде"
        if (zoom >= 17) return 0.00045;
        if (zoom >= 16) return 0.00065;
        if (zoom >= 15) return 0.00095;
        if (zoom >= 14) return 0.0014;
        return 0.0022;
    }

    function parseTsToMsForQuery(ts) {
        // Используем тот же хелпер, что и для других мест
        return parseMarkerTimestampToMs(ts);
    }

    async function loadPatrolHeatmapData(force = false) {
        if (!force && (Date.now() - patrolHeatmapCacheLoadedAt) < PATROL_HEATMAP_CACHE_MS && patrolHeatmapCellsCache.length) {
            return patrolHeatmapCellsCache;
        }

        const now = Date.now();
        const sinceMs = now - PATROL_HEATMAP_LOOKBACK_HOURS * 60 * 60 * 1000;
        const sinceIso = new Date(sinceMs).toISOString();

        let rows = [];
        // Пытаемся как BIGINT(ms), иначе fallback на ISO
        {
            const r1 = await _sb
                .from('markers')
                .select('id,type,ts,coords')
                .in('type', ['dps', 'specbat'])
                .gte('ts', sinceMs)
                .order('ts', { ascending: false })
                .limit(PATROL_HEATMAP_MAX_POINTS);
            if (r1?.error) {
                const r2 = await _sb
                    .from('markers')
                    .select('id,type,ts,coords')
                    .in('type', ['dps', 'specbat'])
                    .gte('ts', sinceIso)
                    .order('ts', { ascending: false })
                    .limit(PATROL_HEATMAP_MAX_POINTS);
                if (!r2?.error && Array.isArray(r2?.data)) rows = r2.data;
            } else {
                if (Array.isArray(r1?.data)) rows = r1.data;
            }
        }

        if (!Array.isArray(rows) || !rows.length) {
            patrolHeatmapCellsCache = [];
            patrolHeatmapCacheLoadedAt = Date.now();
            return patrolHeatmapCellsCache;
        }

        const zoom = myMap ? Number(myMap.getZoom() || 16) : 16;
        const cellDeg = getPatrolHeatmapCellDegrees(zoom);
        const cellMap = new Map();

        rows.forEach(row => {
            const coords = extractMarkerCoordsForNotif(row);
            if (!coords) return;
            const tsMs = parseTsToMsForQuery(row?.ts);
            if (!Number.isFinite(tsMs) || tsMs < sinceMs) return;

            const latKey = Math.round(Number(coords.lat) / cellDeg);
            const lonKey = Math.round(Number(coords.lon) / cellDeg);
            const key = `${latKey}:${lonKey}`;

            const existing = cellMap.get(key) || {
                lat: latKey * cellDeg,
                lon: lonKey * cellDeg,
                dps: 0,
                specbat: 0,
                weight: 0,
                latestMs: 0
            };
            if (row.type === 'dps') existing.dps += 1;
            if (row.type === 'specbat') existing.specbat += 1;

            const ageMin = Math.max(0, (now - tsMs) / 60000);
            // Свежесть: чем свежее, тем выше вес
            const recency = ageMin <= 30 ? 1.0 : ageMin <= 90 ? 0.75 : ageMin <= 150 ? 0.55 : 0.40;
            existing.weight += recency;
            existing.latestMs = Math.max(existing.latestMs, tsMs);
            cellMap.set(key, existing);
        });

        patrolHeatmapCellsCache = [...cellMap.values()]
            .filter(c => (c.dps + c.specbat) > 0)
            .sort((a, b) => (b.weight || 0) - (a.weight || 0))
            .slice(0, 900);

        patrolHeatmapCacheLoadedAt = Date.now();
        return patrolHeatmapCellsCache;
    }

    async function showPatrolHeatmapAnalytics(cell) {
        if (!cell) return;
        if (!myMap) return;

        const lat = Number(cell.lat);
        const lon = Number(cell.lon);
        if (!Number.isFinite(lat) || !Number.isFinite(lon)) return;

        let street = '—';
        try {
            const res = await ymaps.geocode([lat, lon]);
            const obj = res?.geoObjects?.get?.(0);
            const line = obj ? String(obj.getAddressLine() || '').trim() : '';
            if (line) street = line;
        } catch(e) {}

        let probability = null;
        let peak = null;
        try {
            let token = localStorage.getItem('sb_jwt') || '';
            if (!token) {
                const refreshed = await ensureSupabaseAuth();
                token = refreshed || localStorage.getItem('sb_jwt') || '';
            }
            if (token) {
                const resp = await fetch(`${SUPABASE_URL}/functions/v1/smart-hints?action=analyze`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` },
                    body: JSON.stringify({ lat, lon, ts_ms: Date.now(), recent_hours: PATROL_HEATMAP_LOOKBACK_HOURS, analyze_radius_m: 420, fetch_radius_m: 2500, window_days: 30, bucket_hours: 2 })
                });
                if (resp.ok) {
                    const data = await resp.json().catch(()=>null);
                    probability = Number(data?.analyze?.probability);
                    peak = data?.analyze?.peak || null;
                }
            }
        } catch(e) {}

        const probText = Number.isFinite(probability) ? `${Math.round(probability)}%` : '—';
        const peakText = peak?.start && peak?.end ? `${peak.start} - ${peak.end}` : 'нет данных';

        const html = [
            '<div style="font-size:12px; line-height:1.25;">',
            '<div style="font-weight:900; margin-bottom:6px;">Аналитика Монолита</div>',
            `<div>📍 Место: ${escapeHtml(street)}</div>`,
            `<div>⚠️ Вероятность поста: <b>${escapeHtml(probText)}</b></div>`,
            `<div>🕒 Пик активности: <b>${escapeHtml(peakText)}</b></div>`,
            '</div>'
        ].join('');

        try {
            myMap.balloon.open([lat, lon], html, { closeButton: true, maxWidth: 320 });
        } catch(e) {}
    }

    async function renderPatrolHeatmapOverlay() {
        if (!myMap) return;
        if (!patrolHeatmapCollection) {
            patrolHeatmapCollection = new ymaps.GeoObjectCollection();
            myMap.geoObjects.add(patrolHeatmapCollection);
        }

        patrolHeatmapCollection.removeAll();
        if (!patrolHeatmapEnabled) return;

        const cells = await loadPatrolHeatmapData(false);
        if (!cells.length) return;

        const maxWeight = Math.max(...cells.map(c => Number(c.weight || 0)), 1);

        cells.forEach(cell => {
            const total = (cell.dps || 0) + (cell.specbat || 0);
            const dominant = (cell.specbat || 0) >= (cell.dps || 0) ? 'specbat' : 'dps';
            const norm = Math.max(0.12, Math.min(1, Number(cell.weight || 0) / maxWeight));
            const color = getPatrolHeatColor(dominant, norm);

            // Радиус точки строго ~10–12px
            const size = 22; // diameter
            const href = buildDotSvg(color, size, 0.92);

            const pm = new ymaps.Placemark([cell.lat, cell.lon], {
                hintContent: dominant === 'specbat' ? `Спецбат • ${total}` : `ДПС • ${total}`
            }, {
                iconLayout: 'default#image',
                iconImageHref: href,
                iconImageSize: [size, size],
                iconImageOffset: [-Math.round(size/2), -Math.round(size/2)],
                zIndex: 1200
            });

            pm.events.add('click', () => {
                showPatrolHeatmapAnalytics(cell);
            });

            patrolHeatmapCollection.add(pm);
        });
    }

    function schedulePatrolHeatmapRender() {
        if (patrolHeatmapRenderTimer) clearTimeout(patrolHeatmapRenderTimer);
        patrolHeatmapRenderTimer = setTimeout(() => {
            renderPatrolHeatmapOverlay().catch(e => {
                console.warn('Не удалось отрисовать тепловую карту засад:', e?.message || e);
            });
        }, 120);
    }

    async function togglePatrolHeatmap(forceState = null) {
        patrolHeatmapEnabled = typeof forceState === 'boolean' ? forceState : !patrolHeatmapEnabled;
        setPatrolHeatmapUiState(patrolHeatmapEnabled);

        if (!patrolHeatmapEnabled) {
            if (patrolHeatmapCollection) patrolHeatmapCollection.removeAll();
            return;
        }

        await loadPatrolHeatmapData(false);
        schedulePatrolHeatmapRender();
    }

    function parseMarkerTimestampToMs(value) {
        if (typeof value === 'number') {
            if (value > 1e12) return value;
            if (value > 1e9) return value * 1000;
        }
        if (typeof value === 'string') {
            const asNum = Number(value);
            if (Number.isFinite(asNum)) return parseMarkerTimestampToMs(asNum);
            const parsed = Date.parse(value);
            if (Number.isFinite(parsed)) return parsed;
        }
        return Date.now();
    }

    function getDtpHeatmapCellDegrees(zoom) {
        // Чем ближе зум — тем мельче сетка, чтобы "пятна" указывали на конкретнее место.
        if (zoom >= 17) return 0.0010;
        if (zoom >= 16) return 0.0016;
        if (zoom >= 15) return 0.0025;
        if (zoom >= 14) return 0.0038;
        if (zoom >= 13) return 0.0055;
        return 0.008;
    }

    function getDtpHeatmapRadiusMeters(zoom) {
        // Радиусы уменьшены, чтобы пользователи понимали конкретный перекрёсток/участок.
        if (zoom >= 17) return 120;
        if (zoom >= 16) return 180;
        if (zoom >= 15) return 260;
        if (zoom >= 14) return 400;
        if (zoom >= 13) return 550;
        return 750;
    }

    function getDtpHeatColor(norm) {
        const n = Math.max(0, Math.min(1, Number(norm) || 0));
        if (n <= 0.5) {
            const t = n / 0.5;
            const r = Math.round(70 + (255 - 70) * t);
            const g = Math.round(180 + (214 - 180) * t);
            const b = Math.round(255 + (10 - 255) * t);
            return `rgb(${r},${g},${b})`;
        }
        const t = (n - 0.5) / 0.5;
        const r = 255;
        const g = Math.round(214 + (59 - 214) * t);
        const b = Math.round(10 + (48 - 10) * t);
        return `rgb(${r},${g},${b})`;
    }

    async function loadDtpHeatmapData(force = false) {
        if (!force && (Date.now() - dtpHeatmapCacheLoadedAt) < DTP_HEATMAP_CACHE_MS && dtpHeatmapCellsCache.length) {
            return dtpHeatmapCellsCache;
        }

        const { data, error } = await _sb
            .from('markers')
            .select('id,type,ts,coords,leave_confirmations')
            .eq('type', 'dtp')
            .order('ts', { ascending: false })
            .limit(DTP_HEATMAP_MAX_POINTS);

        if (error || !Array.isArray(data)) {
            console.warn('Не удалось загрузить точки для тепловой карты ДТП:', error?.message || error);
            return dtpHeatmapCellsCache;
        }

        const lookbackMs = DTP_HEATMAP_LOOKBACK_DAYS * 24 * 60 * 60 * 1000;
        const now = Date.now();

        dtpHeatmapCellsCache = data.map(row => {
            const coords = extractMarkerCoordsForNotif(row);
            if (!coords) return null;

            const tsMs = parseMarkerTimestampToMs(row?.ts);
            const ageMs = Math.max(0, now - tsMs);
            const recency = ageMs <= 24 * 60 * 60 * 1000 ? 1 : ageMs <= 3 * 24 * 60 * 60 * 1000 ? 0.75 : ageMs <= 7 * 24 * 60 * 60 * 1000 ? 0.55 : 0.35;
            const confirmations = Number(row?.leave_confirmations || 0);
            const confirmBoost = Math.min(1.4, confirmations * 0.18);

            return {
                lat: Number(coords.lat),
                lon: Number(coords.lon),
                tsMs,
                weight: recency + confirmBoost
            };
        }).filter(point => {
            if (!point) return false;
            if (!Number.isFinite(point.lat) || !Number.isFinite(point.lon)) return false;
            return (now - point.tsMs) <= lookbackMs;
        });

        dtpHeatmapCacheLoadedAt = Date.now();
        return dtpHeatmapCellsCache;
    }

    function aggregateDtpHeatmapCells(points, zoom) {
        const cellDeg = getDtpHeatmapCellDegrees(zoom);
        const cellMap = new Map();

        points.forEach(point => {
            const latKey = Math.round(point.lat / cellDeg);
            const lonKey = Math.round(point.lon / cellDeg);
            const key = `${latKey}:${lonKey}`;
            const existing = cellMap.get(key) || { lat: latKey * cellDeg, lon: lonKey * cellDeg, weight: 0, hits: 0 };
            existing.weight += Number(point.weight || 0);
            existing.hits += 1;
            cellMap.set(key, existing);
        });

        return [...cellMap.values()];
    }

    async function renderDtpHeatmapOverlay() {
        if (!myMap) return;
        if (!dtpHeatmapCollection) {
            dtpHeatmapCollection = new ymaps.GeoObjectCollection();
            myMap.geoObjects.add(dtpHeatmapCollection);
        }

        dtpHeatmapCollection.removeAll();
        if (!dtpHeatmapEnabled) return;

        const points = await loadDtpHeatmapData(false);
        if (!points.length) return;

        const zoom = Number(myMap.getZoom() || 14);
        const radius = getDtpHeatmapRadiusMeters(zoom);
        const bounds = myMap.getBounds();
        const cells = aggregateDtpHeatmapCells(points, zoom).filter(cell => {
            if (!Array.isArray(bounds) || bounds.length < 2) return true;
            const [sw, ne] = bounds;
            return cell.lat >= Number(sw[0]) - 0.03 && cell.lat <= Number(ne[0]) + 0.03 && cell.lon >= Number(sw[1]) - 0.03 && cell.lon <= Number(ne[1]) + 0.03;
        });

        if (!cells.length) return;
        const maxWeight = Math.max(...cells.map(c => Number(c.weight || 0)), 1);

        cells.forEach(cell => {
            const norm = Math.max(0.08, Math.min(1, Number(cell.weight || 0) / maxWeight));
            const color = getDtpHeatColor(norm);

            const glow = new ymaps.Circle([[cell.lat, cell.lon], radius * 1.4], {}, {
                fillColor: color,
                fillOpacity: 0.10 + norm * 0.14,
                strokeOpacity: 0,
                zIndex: 1100
            });
            const core = new ymaps.Circle([[cell.lat, cell.lon], radius], {}, {
                fillColor: color,
                fillOpacity: 0.20 + norm * 0.34,
                strokeColor: color,
                strokeOpacity: 0.08,
                strokeWidth: 1,
                zIndex: 1101
            });

            dtpHeatmapCollection.add(glow);
            dtpHeatmapCollection.add(core);
        });
    }

    function scheduleDtpHeatmapRender() {
        if (dtpHeatmapRenderTimer) clearTimeout(dtpHeatmapRenderTimer);
        dtpHeatmapRenderTimer = setTimeout(() => {
            renderDtpHeatmapOverlay().catch(e => {
                console.warn('Не удалось отрисовать тепловую карту ДТП:', e?.message || e);
            });
        }, 120);
    }

    async function toggleDtpHeatmap(forceState = null) {
        dtpHeatmapEnabled = typeof forceState === 'boolean' ? forceState : !dtpHeatmapEnabled;
        setDtpHeatmapUiState(dtpHeatmapEnabled);

        if (!dtpHeatmapEnabled) {
            if (dtpHeatmapCollection) dtpHeatmapCollection.removeAll();
            return;
        }

        await loadDtpHeatmapData(false);
        scheduleDtpHeatmapRender();
    }

    // Спидометр: загрузка и применение настроек
    function loadSpeedometerPreference() {
        try {
            const saved = localStorage.getItem('speedometerEnabled');
            speedometerEnabled = saved !== 'false';
        } catch (e) {
            speedometerEnabled = true;
        }
        applySpeedometerVisibility();
    }

    function applySpeedometerVisibility() {
        const el = document.getElementById('speedometer');
        const openBtn = document.getElementById('speedometerOpenBtn');
        if (!el || !openBtn) return;
        if (speedometerEnabled) {
            el.classList.add('visible');
            openBtn.classList.remove('visible');
        } else {
            el.classList.remove('visible');
            openBtn.classList.add('visible');
        }
    }

    function toggleSpeedometer(forceOn) {
        if (typeof forceOn === 'boolean') {
            speedometerEnabled = forceOn;
        } else {
            speedometerEnabled = !speedometerEnabled;
        }
        try { localStorage.setItem('speedometerEnabled', speedometerEnabled ? 'true' : 'false'); } catch(e) {}
        applySpeedometerVisibility();
    }

    function updateSpeedometerUI(speedKmh) {
        const valueEl = document.getElementById('speedValue');
        if (!valueEl) return;
        valueEl.textContent = Math.max(0, Math.round(speedKmh || 0));
    }

    function registerServiceWorker() {
        if (!('serviceWorker' in navigator)) return;
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('service-worker.js?v=4').catch(err => {
                console.warn('Service Worker registration failed:', err);
            });
        });
    }

    // ===================== PWA: Web Push + background location bridge =====================
    // ВАЖНО:
    // - Web Push работает только в поддерживаемых браузерах и обычно требует HTTPS + установленную PWA.
    // - Геолокация недоступна в Service Worker; поэтому координаты берём на странице и шлём в SW.

    // Вставьте сюда ваш VAPID public key (base64url, без '=' в конце обычно).
    // Пример формата: "BEl6..." (это НЕ секрет, в отличие от private key).
    const WEB_PUSH_VAPID_PUBLIC_KEY = 'BCKNXhwDka5GLPLOGJib2ONjp2Hw985myXXwBOWeH2d5m50A6yiBt7ykM0tbxRtbMo5IBH7HP0EpeMwcA4sLvtE';
    const PUSH_SUB_LOCALSTORAGE_KEY = 'safedrive180:pushSubscription';

    function urlBase64ToUint8Array(base64String) {
        const padding = '='.repeat((4 - (base64String.length % 4)) % 4);
        const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/');
        const rawData = atob(base64);
        const outputArray = new Uint8Array(rawData.length);
        for (let i = 0; i < rawData.length; ++i) outputArray[i] = rawData.charCodeAt(i);
        return outputArray;
    }

    async function getActiveServiceWorkerForMessaging() {
        if (!('serviceWorker' in navigator)) return null;
        try {
            if (navigator.serviceWorker.controller) return navigator.serviceWorker.controller;
            const reg = await navigator.serviceWorker.ready;
            return reg.active || reg.waiting || reg.installing || null;
        } catch (e) {
            return null;
        }
    }

    function storePushSubscription(subscription) {
        try {
            localStorage.setItem(PUSH_SUB_LOCALSTORAGE_KEY, JSON.stringify(subscription));
        } catch (e) {}
    }

    function clearStoredPushSubscription() {
        try { localStorage.removeItem(PUSH_SUB_LOCALSTORAGE_KEY); } catch (e) {}
    }

    async function saveWebPushSubscriptionOnServer(subscriptionJson) {
        try {
            if (!subscriptionJson || !subscriptionJson.endpoint) return false;
            if (typeof SUPABASE_URL === 'undefined' || !SUPABASE_URL) return false;

            const resp = await fetch(`${SUPABASE_URL}/functions/v1/push-subscribe`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    subscription: subscriptionJson,
                    userId: (typeof uid !== 'undefined' && uid) ? String(uid) : null,
                    userAgent: (navigator && navigator.userAgent) ? navigator.userAgent : ''
                })
            });
            if (!resp.ok) {
                const t = await resp.text().catch(() => '');
                console.warn('Web Push: push-subscribe failed:', resp.status, t);
                return false;
            }
            return true;
        } catch (e) {
            console.warn('Web Push: save subscription error:', e?.message || e);
            return false;
        }
    }

    async function enableWebPush() {
        if (!('serviceWorker' in navigator)) throw new Error('Service Worker не поддерживается в этом окружении');
        if (!('PushManager' in window)) throw new Error('PushManager не поддерживается (Web Push недоступен)');
        if (!('Notification' in window)) throw new Error('Notification API не поддерживается');

        let permission = Notification.permission;
        if (permission === 'default') {
            permission = await Notification.requestPermission();
        }
        if (permission !== 'granted') {
            throw new Error('Нет разрешения на уведомления (Notification.permission != granted)');
        }

        const reg = await navigator.serviceWorker.ready;
        const existing = await reg.pushManager.getSubscription();
        if (existing) {
            storePushSubscription(existing.toJSON());
            saveWebPushSubscriptionOnServer(existing.toJSON()).catch(()=>{});
            return existing;
        }

        const key = String(WEB_PUSH_VAPID_PUBLIC_KEY || '').trim();
        if (!key) {
            throw new Error('Не задан WEB_PUSH_VAPID_PUBLIC_KEY — без него подписку создать нельзя');
        }

        const sub = await reg.pushManager.subscribe({
            userVisibleOnly: true,
            applicationServerKey: urlBase64ToUint8Array(key)
        });

        storePushSubscription(sub.toJSON());
        console.log('Web Push subscription created:', sub.toJSON());
        saveWebPushSubscriptionOnServer(sub.toJSON()).catch(()=>{});
        return sub;
    }

    async function disableWebPush() {
        if (!('serviceWorker' in navigator)) return false;
        try {
            const reg = await navigator.serviceWorker.ready;
            const sub = await reg.pushManager.getSubscription();
            if (sub) await sub.unsubscribe();
            clearStoredPushSubscription();
            return true;
        } catch (e) {
            return false;
        }
    }

    async function postLocationToServiceWorker(position) {
        const sw = await getActiveServiceWorkerForMessaging();
        if (!sw || typeof sw.postMessage !== 'function') return;
        const coords = position?.coords;
        if (!coords) return;

        // Клонируем только простые поля (не тащим прототипы GeolocationCoordinates)
        const payload = {
            latitude: Number(coords.latitude),
            longitude: Number(coords.longitude),
            accuracy: Number(coords.accuracy),
            altitude: coords.altitude == null ? null : Number(coords.altitude),
            altitudeAccuracy: coords.altitudeAccuracy == null ? null : Number(coords.altitudeAccuracy),
            heading: coords.heading == null ? null : Number(coords.heading),
            speed: coords.speed == null ? null : Number(coords.speed)
        };

        sw.postMessage({
            type: 'LOCATION_UPDATE',
            coords: payload,
            timestamp: Number.isFinite(position?.timestamp) ? position.timestamp : Date.now()
        });
    }

    // Экспортируем минимальный API, чтобы можно было включать через существующие кнопки/жесты.
    window.SafeDrivePwa = {
        enableWebPush,
        disableWebPush,
        postLocationToServiceWorker
    };

    function getNotifStorageKey() {
        return `${NOTIF_STORAGE_PREFIX}${String(uid || 'anon')}`;
    }

    function escapeHtml(input) {
        return String(input || '')
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;');
    }

    function loadNotificationsState() {
        try {
            const raw = localStorage.getItem(getNotifStorageKey());
            const parsed = raw ? JSON.parse(raw) : [];
            appNotifications = Array.isArray(parsed) ? parsed : [];
        } catch (e) {
            appNotifications = [];
        }
        pruneOldMchsNotifications();
        renderNotificationsList();
        updateNotificationBadge();
    }

    function pruneOldMchsNotifications() {
        const now = Date.now();
        const before = appNotifications.length;
        appNotifications = appNotifications.filter(n => {
            if (String(n?.source || '') !== 'mchs') return true;
            const ts = new Date(n?.createdAt || 0).getTime();
            if (!Number.isFinite(ts)) return false;
            return (now - ts) <= NOTIF_MCHS_RETENTION_MS;
        });
        if (appNotifications.length !== before) {
            saveNotificationsState();
        }
    }

    function saveNotificationsState() {
        try {
            localStorage.setItem(getNotifStorageKey(), JSON.stringify(appNotifications.slice(0, NOTIF_MAX_ITEMS)));
        } catch (e) {
            console.warn('Не удалось сохранить уведомления:', e?.message || e);
        }
    }

    async function updatePwaBadge(unreadCount) {
        try {
            if (typeof navigator.setAppBadge === 'function') {
                if (unreadCount > 0) await navigator.setAppBadge(unreadCount);
                else if (typeof navigator.clearAppBadge === 'function') await navigator.clearAppBadge();
            }
        } catch (e) {
            // ignore unsupported contexts
        }
    }

    function updateNotificationBadge() {
        const unread = appNotifications.filter(n => !n.read).length;
        const badge = document.getElementById('notifUnreadBadge');
        if (badge) {
            if (unread > 0) {
                badge.style.display = 'block';
                badge.textContent = unread > 99 ? '99+' : String(unread);
            } else {
                badge.style.display = 'none';
            }
        }
        updatePwaBadge(unread);
    }

    function formatNotificationTime(ts) {
        try {
            return new Date(ts).toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' });
        } catch (e) {
            return '';
        }
    }

    function formatRelativeNotificationTime(ts) {
        const value = new Date(ts).getTime();
        if (!Number.isFinite(value)) return '';
        const diffMs = Date.now() - value;
        if (diffMs < 60 * 1000) return 'только что';
        const diffMin = Math.floor(diffMs / (60 * 1000));
        if (diffMin < 60) return `${diffMin} мин. назад`;
        const diffH = Math.floor(diffMin / 60);
        if (diffH < 24) return `${diffH} ч. назад`;
        const diffD = Math.floor(diffH / 24);
        return `${diffD} дн. назад`;
    }

    function formatDistanceForNotification(distanceMeters) {
        if (!Number.isFinite(distanceMeters)) return null;
        if (distanceMeters >= 1000) return `${(distanceMeters / 1000).toFixed(1)} км от вас`;
        return `${Math.round(distanceMeters)} м от вас`;
    }

    function looksLikeMojibake(text) {
        const value = String(text || '');
        return /Ð|Ñ|�/.test(value);
    }

    function normalizeFeedText(value, fallback = '') {
        const text = String(value || '').trim();
        if (!text) return fallback;
        if (looksLikeMojibake(text)) return fallback;
        return text;
    }

    function showInAppNotification(notification) {
        const wrap = document.getElementById('inAppNotifWrap');
        if (!wrap) return;
        const toast = document.createElement('div');
        toast.className = 'notif-toast';
        toast.innerHTML = `<div style="font-weight:700; margin-bottom:2px;">${escapeHtml(notification.title)}</div><div>${escapeHtml(notification.body || '')}</div>`;
        wrap.prepend(toast);
        requestAnimationFrame(() => toast.classList.add('visible'));
        setTimeout(() => {
            toast.classList.remove('visible');
            setTimeout(() => toast.remove(), 220);
        }, 4200);
        if (notification.priority === 'high' && navigator.vibrate) {
            try { navigator.vibrate([200, 120, 220]); } catch (e) {}
        }
    }

    async function showSystemNotification(notification) {
        if (!document.hidden) return;
        if (!('Notification' in window)) return;
        let permission = Notification.permission;
        if (permission === 'default') {
            try { permission = await Notification.requestPermission(); } catch (e) { return; }
        }
        if (permission !== 'granted') return;

        // Если задан VAPID public key — создаём Web Push подписку (без нового UI).
        try {
            const key = String(typeof WEB_PUSH_VAPID_PUBLIC_KEY !== 'undefined' ? WEB_PUSH_VAPID_PUBLIC_KEY : '').trim();
            if (key && window.SafeDrivePwa && typeof window.SafeDrivePwa.enableWebPush === 'function') {
                window.SafeDrivePwa.enableWebPush().catch(()=>{});
            }
        } catch (e) {}

        const options = {
            body: notification.body || '',
            tag: `marker-${notification.type || 'event'}`,
            renotify: notification.priority === 'high',
            data: {
                url: '/',
                coords: notification.coords || null,
                notifId: notification.id
            },
            vibrate: notification.priority === 'high' ? [200, 120, 220] : [80],
            badge: 'manifest.json'
        };

        try {
            if (navigator.serviceWorker?.controller) {
                navigator.serviceWorker.controller.postMessage({
                    type: 'SHOW_NOTIFICATION',
                    title: notification.title,
                    options
                });
                return;
            }
            if (navigator.serviceWorker?.ready) {
                const reg = await navigator.serviceWorker.ready;
                await reg.showNotification(notification.title, options);
                return;
            }
            new Notification(notification.title, options);
        } catch (e) {
            console.warn('Не удалось показать системное уведомление:', e?.message || e);
        }
    }

    function upsertAppNotification(notification, options = {}) {
        if (!notification || !notification.id) return;
        const silent = !!options.silent;
        const idx = appNotifications.findIndex(n => String(n.id) === String(notification.id));
        if (idx >= 0) {
            const prev = appNotifications[idx] || {};
            appNotifications[idx] = { ...prev, ...notification, read: typeof notification.read === 'boolean' ? notification.read : prev.read };
        } else {
            appNotifications.unshift(notification);
        }

        appNotifications.sort((a, b) => new Date(b.createdAt || 0).getTime() - new Date(a.createdAt || 0).getTime());
        if (appNotifications.length > NOTIF_MAX_ITEMS) appNotifications = appNotifications.slice(0, NOTIF_MAX_ITEMS);

        saveNotificationsState();
        renderNotificationsList();
        updateNotificationBadge();

        if (!silent && idx < 0) {
            if (!document.hidden) showInAppNotification(notification);
            showSystemNotification(notification);
        }
    }

    function pushAppNotification(notification) {
        upsertAppNotification(notification, { silent: false });
    }

    function renderNotificationsList() {
        const list = document.getElementById('notificationsList');
        if (!list) return;
        if (!appNotifications.length) {
            list.innerHTML = '<div style="text-align:center; color: var(--gray); padding: 16px;">Пока нет важных событий</div>';
            return;
        }
        list.innerHTML = appNotifications.map(n => `
            <div class="notif-row ${n.read ? '' : 'unread'}" onclick="goToNotification('${escapeHtml(n.id)}')">
                <div class="notif-icon">${escapeHtml(n.icon || '📍')}</div>
                <div style="flex:1; min-width:0;">
                    <div class="notif-title">${escapeHtml(n.title)}</div>
                    <div class="notif-body">${escapeHtml(n.body || '')}</div>
                    <div class="notif-time">${formatRelativeNotificationTime(n.createdAt) || formatNotificationTime(n.createdAt)}</div>
                </div>
            </div>
        `).join('');
    }

    function markNotificationReadById(id) {
        const idx = appNotifications.findIndex(n => String(n.id) === String(id));
        if (idx < 0) return;
        if (!appNotifications[idx].read) {
            appNotifications[idx].read = true;
            saveNotificationsState();
            renderNotificationsList();
            updateNotificationBadge();
        }
    }

    function openNotificationsDrawer() {
        const target = document.querySelector('.target');
        if (target) target.style.visibility = 'hidden';
        syncImportantNotificationsFeed({ silent: true }).catch(()=>{});
        renderNotificationsList();
        document.getElementById('notificationsModal').classList.add('active');
    }

    function closeNotificationsDrawer() {
        const target = document.querySelector('.target');
        if (target) target.style.visibility = 'visible';
        document.getElementById('notificationsModal').classList.remove('active');
    }

    function markAllNotificationsRead() {
        appNotifications = appNotifications.map(n => ({ ...n, read: true }));
        saveNotificationsState();
        renderNotificationsList();
        updateNotificationBadge();
    }

    function clearAllNotifications() {
        appNotifications = [];
        saveNotificationsState();
        renderNotificationsList();
        updateNotificationBadge();
    }

    function goToNotification(notificationId) {
        const n = appNotifications.find(item => String(item.id) === String(notificationId));
        if (!n) return;
        markNotificationReadById(notificationId);
        if (n.coords && myMap) {
            try {
                myMap.setCenter([n.coords.lat, n.coords.lon], 16, { duration: 250 });
            } catch (e) {}
        }
        closeNotificationsDrawer();
    }

    function extractMarkerCoordsForNotif(marker) {
        if (!marker) return null;
        if (Array.isArray(marker.coords) && marker.coords.length >= 2) {
            const a = Number(marker.coords[0]);
            const b = Number(marker.coords[1]);
            if (Math.abs(a) <= 90 && Math.abs(b) <= 180) return { lat: a, lon: b };
            if (Math.abs(a) <= 180 && Math.abs(b) <= 90) return { lat: b, lon: a };
            return { lat: a, lon: b };
        }
        if (typeof marker.latitude === 'number' && typeof marker.longitude === 'number') {
            return { lat: marker.latitude, lon: marker.longitude };
        }
        return null;
    }

    function buildMarkerNotification(marker, distanceMeters, override = null) {
        const type = marker?.type || 'event';
        const icon = getMarkerEmoji(type);
        const label = getMarkerLabel(type);
        const distance = Number.isFinite(distanceMeters) ? `${Math.round(distanceMeters)} м` : null;
        const baseBody = override || `${label}${distance ? ` • ${distance}` : ''}${marker?.comment ? ` • ${String(marker.comment).slice(0, 80)}` : ''}`;
        const markerIdPart = marker?.id ? String(marker.id) : `${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
        return {
            id: `realtime_${type}_${markerIdPart}`,
            type,
            icon,
            title: type === 'sos' ? '🆘 Рядом SOS' : `Рядом: ${label}`,
            body: baseBody,
            priority: type === 'sos' ? 'high' : 'normal',
            createdAt: new Date().toISOString(),
            read: false,
            source: 'marker',
            coords: extractMarkerCoordsForNotif(marker)
        };
    }

    function buildFeedMarkerNotification(marker, kind, distanceMeters) {
        const markerId = String(marker?.id || `${Date.now()}_${Math.random().toString(36).slice(2, 7)}`);
        const distanceText = formatDistanceForNotification(distanceMeters);
        const comment = String(marker?.comment || '').trim();
        const ts = marker?.ts ? new Date(marker.ts).toISOString() : new Date().toISOString();

        if (kind === 'sos') {
            return {
                id: `feed_sos_${markerId}`,
                type: 'sos',
                icon: '🔴',
                title: 'SOS: Нужна помощь',
                body: `${comment || 'Пользователь запросил помощь'}${distanceText ? ` (${distanceText})` : ''}`,
                priority: 'high',
                createdAt: ts,
                read: false,
                source: 'sos',
                coords: extractMarkerCoordsForNotif(marker)
            };
        }

        return {
            id: `feed_dtp_critical_${markerId}`,
            type: 'dtp',
            icon: '🔵',
            title: 'ДТП: Критичное событие',
            body: `${comment || 'Возможное перекрытие движения'}${distanceText ? ` (${distanceText})` : ''}`,
            priority: 'normal',
            createdAt: ts,
            read: false,
            source: 'critical_dtp',
            coords: extractMarkerCoordsForNotif(marker)
        };
    }

    async function syncMchsFeedToNotifications({ silent = true } = {}) {
        try {
            const resp = await fetch(`${SUPABASE_URL}/functions/v1/mchs-auto?action=feed&limit=8`, { method: 'GET' });
            if (!resp.ok) return;
            const payload = await resp.json();
            const alerts = Array.isArray(payload?.alerts) ? payload.alerts : [];
            alerts.forEach(alert => {
                const alertId = String(alert?.id || '');
                if (!alertId) return;
                const rawTitle = String(alert?.title || '').trim();
                const link = String(alert?.source_link || '').trim();
                const isWeather = /open-meteo\.com/i.test(link) || /\bпогода\b/i.test(rawTitle);
                const isSafeDriveUpdate = /обновление\s+safedrive/i.test(rawTitle) || (!link && !isWeather);
                const hazard = normalizeFeedText(alert?.hazard_text, normalizeFeedText(rawTitle, 'Без описания'));
                const recommendation = normalizeFeedText(
                    alert?.recommendation_text,
                    isSafeDriveUpdate ? 'Следите за сообщениями в разделе «Уведомления».' : ''
                );
                upsertAppNotification({
                    id: `${isSafeDriveUpdate ? 'feed_update_' : 'feed_mchs_'}${alertId}`,
                    type: isSafeDriveUpdate ? 'update' : (isWeather ? 'weather' : 'mchs'),
                    icon: isSafeDriveUpdate ? '🔵' : (isWeather ? '🌦' : '🟠'),
                    title: isSafeDriveUpdate ? 'SafeDrive: Обновление' : (isWeather ? 'Погода: Донецк' : 'МЧС: Штормовое предупреждение'),
                    body: `${hazard}${recommendation ? ` • ${recommendation}` : ''}`.slice(0, 220),
                    priority: 'normal',
                    createdAt: alert?.pub_date || alert?.created_at || new Date().toISOString(),
                    read: false,
                    source: isSafeDriveUpdate ? 'safedrive_news' : (isWeather ? 'weather' : 'mchs'),
                    link: link || null
                }, { silent });
            });
        } catch (e) {
            console.warn('Не удалось синхронизировать погоду/сводки:', e?.message || e);
        }
    }

    function buildWeatherWidgetLine(alert) {
        const full = String(alert?.full_text || '');
        const hazardText = String(alert?.hazard_text || '');

        const t = full.match(/🌡\s*ТЕМПЕРАТУРА:\s*([+\-]?\d+)\s*°C/i)?.[1] || null;
        const wind = full.match(/💨\s*ВЕТЕР:\s*(\d+)\s*км\/ч/i)?.[1] || null;
        const vis = full.match(/👁\s*ВИДИМОСТЬ:\s*(\d+)\s*м/i)?.[1] || null;

        const isIce = /ГОЛОЛЕД/i.test(hazardText) || /ГОЛОЛЕД/i.test(full);
        const roadPart = isIce ? '⚠️ Гололёд' : (/✅\s*НОРМА/i.test(hazardText) ? '✅ Норма' : '');

        const parts = [];
        parts.push(`🌦 ${t !== null ? `${t}°C` : '—'}`);
        if (wind !== null) parts.push(`💨 ${wind} км/ч`);
        if (vis !== null) parts.push(`👁 ${vis} м`);
        if (roadPart) parts.push(`<span class="weather-warn">${roadPart}</span>`);

        return parts.join(' • ');
    }

    async function syncWeatherWidget() {
        const el = document.getElementById('weatherWidget');
        if (!el) return;

        try {
            const resp = await fetch(`${SUPABASE_URL}/functions/v1/mchs-auto?action=feed&limit=3`, { method: 'GET' });
            if (!resp.ok) return;
            const payload = await resp.json();
            const alerts = Array.isArray(payload?.alerts) ? payload.alerts : [];

            const weather = alerts.find(a => /open-meteo\.com/i.test(String(a?.source_link || '')) || /\bпогода\b/i.test(String(a?.title || '')));
            if (!weather) {
                el.textContent = '🌦 Погода: нет данных';
                return;
            }

            el.innerHTML = buildWeatherWidgetLine(weather);
        } catch (e) {
            // Не шумим — виджет не критичен
        }
    }

    async function syncNearbyImportantMarkersToNotifications({ silent = true } = {}) {
        try {
            const sinceMs = Date.now() - NOTIF_FEED_MARKER_LOOKBACK_MS;
            let markers = [];
            let error = null;

            ({ data: markers, error } = await _sb
                .from('markers')
                .select('id,type,ts,comment,coords,author_id')
                .in('type', ['sos', 'dtp'])
                .order('ts', { ascending: false })
                .limit(80));

            if (error || !Array.isArray(markers)) return;

            markers = markers.filter(marker => {
                const tsMs = parseMarkerTimestampToMs(marker?.ts);
                return Number.isFinite(tsMs) ? tsMs >= sinceMs : true;
            });

            markers.forEach(marker => {
                if (String(marker?.author_id || '') === String(uid || '')) return;

                const coords = extractMarkerCoordsForNotif(marker);
                let distanceMeters = NaN;
                if (coords && Array.isArray(userLocation) && userLocation.length >= 2) {
                    distanceMeters = calculateDistance(userLocation[0], userLocation[1], Number(coords.lat), Number(coords.lon));
                    if (Number.isFinite(distanceMeters) && distanceMeters > NOTIF_FEED_RADIUS_METERS) return;
                }

                if (marker.type === 'sos') {
                    upsertAppNotification(buildFeedMarkerNotification(marker, 'sos', distanceMeters), { silent });
                    return;
                }

                if (marker.type === 'dtp') {
                    upsertAppNotification(buildFeedMarkerNotification(marker, 'critical_dtp', distanceMeters), { silent });
                }
            });
        } catch (e) {
            console.warn('Не удалось синхронизировать SOS/ДТП в ленту уведомлений:', e?.message || e);
        }
    }

    function seedSafeDriveNewsNotifications() {
        SAFE_DRIVE_NEWS_ITEMS.forEach(item => {
            upsertAppNotification({ ...item }, { silent: true });
        });
    }

    async function syncImportantNotificationsFeed({ silent = true } = {}) {
        await syncMchsFeedToNotifications({ silent });
        await syncWeatherWidget();
        await syncNearbyImportantMarkersToNotifications({ silent });
        pruneOldMchsNotifications();
    }

    async function notifyHelpBotAboutMarker(marker) {
        try {
            if (!marker || !marker.type) return;
            const HELP_NOTIFY_SHARED_KEY = 'f050f0aa-91dc-46c1-b761-2e1030af5b49';
            const helpTypes = new Set(['sos', 'dps', 'specbat', 'dtp', 'danger', 'traffic_jam', 'works']);
            if (!helpTypes.has(String(marker.type))) return;

            const nowMs = Date.now();
            try {
                const cooldownUntil = Number(localStorage.getItem(HELP_NOTIFY_AUTH_COOLDOWN_UNTIL_KEY) || 0);
                if (cooldownUntil > nowMs) return;
            } catch (e) {}

            const token = String(localStorage.getItem('sb_jwt') || '').trim();
            let authToken = '';
            if (token && token.split('.').length === 3) {
                try {
                    const payloadPart = token.split('.')[1].replace(/-/g, '+').replace(/_/g, '/');
                    const normalized = payloadPart + '='.repeat((4 - (payloadPart.length % 4)) % 4);
                    const payloadJwt = JSON.parse(atob(normalized));
                    const exp = Number(payloadJwt?.exp || 0);
                    const nowSec = Math.floor(Date.now() / 1000);
                    if (exp && exp > (nowSec + 30)) {
                        authToken = token;
                    } else {
                        try {
                            localStorage.removeItem('sb_jwt');
                            localStorage.removeItem('sb_jwt_exp');
                        } catch (e) {}
                    }
                } catch (e) {
                    authToken = '';
                }
            }

            const addrText = (document.getElementById('addr-text')?.textContent || '').trim();
            const driverName = String(currentDriver?.name || 'Водитель');
            const driverRank = isAdminUserId(uid) ? 'Админ' : 'Участник';

            const payload = {
                markerId: marker.id,
                type: marker.type,
                comment: marker.comment || '',
                createdAtMs: Number(marker.ts || marker.createdAtMs || Date.now()),
                lat: marker.coords?.[0],
                lon: marker.coords?.[1],
                placeText: addrText,
                driverName,
                driverRank
            };

            const sendHelpNotify = async (jwt) => {
                const authToken = String(jwt || '').trim();
                const headers = {
                    'Content-Type': 'application/json',
                    apikey: SUPABASE_KEY,
                    'x-help-key': HELP_NOTIFY_SHARED_KEY
                };
                if (authToken) {
                    headers.Authorization = `Bearer ${authToken}`;
                }
                return fetch(`${SUPABASE_URL}/functions/v1/help-notify`, {
                    method: 'POST',
                    headers,
                    body: JSON.stringify(payload)
                });
            };

            const resp = await sendHelpNotify(authToken);
            if (resp.status === 401) {
                try {
                    localStorage.removeItem('sb_jwt');
                    localStorage.removeItem('sb_jwt_exp');
                } catch (e) {}
                try { localStorage.setItem(HELP_NOTIFY_AUTH_COOLDOWN_UNTIL_KEY, String(Date.now() + 10 * 60 * 1000)); } catch (e) {}
                console.warn('help-notify: авторизация отклонена (JWT/ключ), временный cooldown');
                return;
            }

            if (!resp.ok) {
                let bodyText = '';
                try { bodyText = await resp.text(); } catch(e) { bodyText = ''; }
                console.warn('help-notify вернул ошибку:', resp.status, bodyText || '(пустой ответ)');
                if (resp.status === 401) {
                    try { localStorage.setItem(HELP_NOTIFY_AUTH_COOLDOWN_UNTIL_KEY, String(Date.now() + 10 * 60 * 1000)); } catch (e) {}
                }
                return;
            }

            try { localStorage.removeItem(HELP_NOTIFY_AUTH_COOLDOWN_UNTIL_KEY); } catch (e) {}

            try {
                const payload = await resp.json();
                console.log('help-notify result:', payload);
                if (Number(payload?.sent || 0) <= 0) {
                    console.warn('help-notify: отправлено 0 уведомлений', payload);
                    const errors = Array.isArray(payload?.errors) ? payload.errors : [];
                    const has403 = errors.some(e => Number(e?.status) === 403);
                    const bodyJoin = errors.map(e => String(e?.body || '')).join(' | ');
                    if (has403 && /bot can't initiate conversation|blocked by the user|user is deactivated|Forbidden/i.test(bodyJoin)) {
                        console.warn('⚠️ Telegram не дал отправить сообщение. Откройте бота уведомлений @SafeDrive180_MCHS_bot и нажмите /start, затем повторите метку.');
                    }
                }
            } catch (e) {
                console.log('✅ Уведомление в Telegram отправлено через help-notify');
            }
        } catch (e) {
            console.warn('Не удалось отправить уведомление в Telegram-бота:', e?.message || e);
        }
    }

    function flushPatrolBatchNotification() {
        if (!patrolNotifBatch.count || !patrolNotifBatch.lastMarker) return;
        const count = patrolNotifBatch.count;
        const notif = buildMarkerNotification(
            patrolNotifBatch.lastMarker,
            patrolNotifBatch.lastDistance,
            `В вашем районе высокая активность патрулей (${count} новых меток за 5 минут)`
        );
        notif.title = '🛡️ Активность патрулей';
        pushAppNotification(notif);
        patrolNotifBatch.count = 0;
        patrolNotifBatch.lastMarker = null;
        patrolNotifBatch.lastDistance = null;
        if (patrolNotifBatch.timer) {
            clearTimeout(patrolNotifBatch.timer);
            patrolNotifBatch.timer = null;
        }
    }

    function queuePatrolBatchNotification(marker, distanceMeters) {
        patrolNotifBatch.count += 1;
        patrolNotifBatch.lastMarker = marker;
        patrolNotifBatch.lastDistance = distanceMeters;
        if (!patrolNotifBatch.timer) {
            patrolNotifBatch.timer = setTimeout(() => {
                flushPatrolBatchNotification();
            }, NOTIF_GROUP_WINDOW_MS);
        }
    }

    function handleRealtimeMarkerNotification(payload) {
        try {
            if (!payload || payload.eventType !== 'INSERT' || !payload.new) return;
            const marker = payload.new;
            if (String(marker.author_id || '') === String(uid || '')) return;

            const coords = extractMarkerCoordsForNotif(marker);
            if (!coords || !userLocation || !Array.isArray(userLocation) || userLocation.length < 2) return;
            const distance = calculateDistance(userLocation[0], userLocation[1], coords.lat, coords.lon);
            if (!Number.isFinite(distance) || distance > 10000) return;

            if (marker.type === 'sos') {
                pushAppNotification(buildMarkerNotification(marker, distance));
                return;
            }

            if (PATROL_TYPES.has(marker.type)) {
                queuePatrolBatchNotification(marker, distance);
                return;
            }

            pushAppNotification(buildMarkerNotification(marker, distance));
        } catch (e) {
            console.warn('Ошибка обработки realtime-уведомления:', e?.message || e);
        }
    }

    // Границы Донецкой области ДНР (примерные координаты)
    const DONETSK_REGION = {
        north: 49.2,    // Северная граница
        south: 47.3,    // Южная граница
        west: 36.4,     // Западная граница
        east: 40.4      // Восточная граница
    };

    // Дебаунс функция для предотвращения частых вызовов
    function debounce(func, delay) {
        let timeoutId;
        return function(...args) {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => func.apply(this, args), delay);
        };
    }
    
    // Оптимизированный дебаунс для loadMarkers
    const loadMarkersDebounced = debounce(() => loadMarkers(), 300);
    
    // ============= ФУНКЦИИ ДЛЯ УВЕДОМЛЕНИЙ О РАССТОЯНИИ И ОЗВУЧКИ =============
    
    /**
     * Вычисляет расстояние между двумя GPS-координатами (формула Хаверсина)
     * @param {number} lat1 - широта первой точки
     * @param {number} lon1 - долгота первой точки
     * @param {number} lat2 - широта второй точки
     * @param {number} lon2 - долгота второй точки
     * @returns {number} расстояние в метрах
     */
    function calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371000; // Радиус земли в метрах
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLon = (lon2 - lon1) * Math.PI / 180;
        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                  Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                  Math.sin(dLon / 2) * Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
    }

    function normalizeWarningDistanceMeters(value) {
        const v = Number(value);
        if (!Number.isFinite(v)) return 500;
        let best = MONOLITH_WARNING_OPTIONS[0];
        let bestDiff = Math.abs(v - best);
        for (const opt of MONOLITH_WARNING_OPTIONS) {
            const diff = Math.abs(v - opt);
            if (diff < bestDiff) {
                best = opt;
                bestDiff = diff;
            }
        }
        return best;
    }

    function getUserDistSettingMeters() {
        return normalizeWarningDistanceMeters(warningDistanceMeters);
    }

    function getDynamicWarningMaxMeters() {
        return getUserDistSettingMeters();
    }

    function getWarningMinMeters(maxMeters) {
        return Math.max(200, Math.round(maxMeters * 0.6));
    }

    function getNearThresholdMeters(maxMeters) {
        return Math.max(120, Math.round(maxMeters * 0.25));
    }

    function formatDistanceMeters(distance) {
        if (!isFinite(distance)) return '';
        if (distance >= 1000) return `${Math.round(distance / 10) * 10} м`;
        if (distance >= 100) return `${Math.round(distance / 10) * 10} м`;
        return `${Math.round(distance)} м`;
    }

    function formatMonolithVoiceDistance(distanceMeters) {
        let m = Math.max(0, Number(distanceMeters) || 0);
        if (m >= 100) m = Math.round(m / 10) * 10;
        else m = Math.round(m);
        if (m === 1000) return '1 километр';
        if (m === 2000) return '2 километра';
        return `${m} метров`;
    }

    function extractStreetFromAddressLine(line) {
        const raw = String(line || '').trim();
        if (!raw) return '';
        const firstPart = raw.split(',').map(s => String(s || '').trim()).find(Boolean) || raw;
        const cleaned = firstPart.replace(/^(Россия|Донецк|ДНР)\s*[,.]\s*/i, '').trim();
        return cleaned || firstPart;
    }

    function monolithGetTargetVoiceLabel(type) {
        const t = String(type || '');
        const labels = {
            specbat: 'Спецбат',
            dps: 'ДПС',
            sos: 'SOS',
            traffic_jam: 'Пробка'
        };
        return labels[t] || getMarkerLabel(t);
    }

    function monolithBuildApproachVoiceText(type, street, remainingDistanceMeters) {
        const target = monolithGetTargetVoiceLabel(type);
        const place = String(street || '').trim() || 'этой улице';
        return `Внимание! ${target} на ${place}. Осталось ${formatMonolithVoiceDistance(remainingDistanceMeters)}`;
    }

    function monolithBuildSosPriorityText(street) {
        const place = String(street || '').trim() || 'этой улице';
        return `Внимание! Нужна помощь брату на ${place}. Кто рядом — подтянитесь`;
    }

    function monolithResolveStreetForMarker(markerId, lat, lon) {
        if (!markerId) return '';
        const cached = monolithStreetCache.get(markerId);
        if (cached) return cached;
        if (!Number.isFinite(lat) || !Number.isFinite(lon)) return '';
        if (!window.ymaps || !ymaps.geocode) return '';
        if (monolithStreetInflight.has(markerId)) return '';

        const req = ymaps.geocode([lat, lon]).then(
            (res) => {
                const obj = res?.geoObjects?.get?.(0);
                const line = obj ? String(obj.getAddressLine() || '').trim() : '';
                const street = extractStreetFromAddressLine(line);
                if (street) monolithStreetCache.set(markerId, street);
                monolithStreetInflight.delete(markerId);
                return street;
            },
            () => {
                monolithStreetInflight.delete(markerId);
                return '';
            }
        );

        monolithStreetInflight.set(markerId, req);
        return '';
    }

    function getMarkerLabel(type) {
        const labels = {
            dps: 'ДПС (Стандарт)',
            patrol: 'Рейд',
            specbat: 'Спецбат',
            motobat: 'Мотобат',
            cargo_control: 'Грузовой контроль',
            camera: 'Наблюдение',
            dtp: 'ДТП',
            works: 'Работы',
            sos: 'SOS / Нужна помощь',
            danger: 'Опасность',
            traffic_jam: 'Пробка / Затор'
        };
        return labels[type] || 'Дорожное событие';
    }

    function getMarkerEmoji(type) {
        const icons = {
            dps: '👮',
            patrol: '🚔',
            specbat: '🛡️',
            motobat: '🏍️',
            cargo_control: '🚛',
            camera: '📸',
            dtp: '💥',
            works: '🛣️',
            sos: '🆘',
            danger: '⚠️',
            traffic_jam: '🚗'
        };
        return icons[type] || '⚠️';
    }

    async function getUserSosBonus(userId) {
        try {
            if (!userId) return 0;
            const { data, error } = await _sb.rpc('get_user_sos_bonus', { p_user_id: String(userId) });
            if (error) {
                console.warn('Не удалось получить SOS-бонус:', error?.message || error);
                return 0;
            }
            return Number(data) || 0;
        } catch (e) {
            console.warn('Ошибка получения SOS-бонуса:', e?.message || e);
            return 0;
        }
    }

    function updateProximityBanner(distance, type) {
        const banner = document.getElementById('proximityBanner');
        if (!banner) return;
        const label = getMarkerLabel(type);
        const emoji = getMarkerEmoji(type);
        const distanceText = formatDistanceMeters(distance);

        banner.innerHTML = `<span class="proximity-banner-title">${emoji} ${label}:</span> <span class="proximity-banner-distance">${distanceText}</span>`;
        banner.classList.add('visible');

        banner.classList.remove('proximity-banner--yellow', 'proximity-banner--orange', 'proximity-banner--red', 'proximity-banner--blink');
        if (distance <= 200) {
            banner.classList.add('proximity-banner--red', 'proximity-banner--blink');
        } else if (distance <= 500) {
            banner.classList.add('proximity-banner--orange');
        } else if (distance <= 1000) {
            banner.classList.add('proximity-banner--yellow');
        }
    }

    function hideProximityBanner() {
        const banner = document.getElementById('proximityBanner');
        if (!banner) return;
        banner.classList.remove('visible', 'proximity-banner--yellow', 'proximity-banner--orange', 'proximity-banner--red', 'proximity-banner--blink');
    }

    function stopWarningOutput() {
        try {
            if (currentWarningAudio) {
                currentWarningAudio.pause();
                currentWarningAudio.currentTime = 0;
                currentWarningAudio = null;
            }
        } catch (e) {
            console.warn('Не удалось остановить аудио:', e?.message || e);
        }
        // Важно для MONOLITH 180: не отменяем speechSynthesis, чтобы очередь не обрывалась.
    }

    // ===================== MONOLITH 180: Voice + WakeLock + Background keep-alive =====================
    const MONOLITH_VOICE_ENABLED_KEY = 'monolith180:voice_enabled';
    let monolithVoiceEnabled = true;

    let monolithWakeLock = null;
    let monolithNavigationActive = false;

    let monolithTtsQueue = [];
    let monolithTtsIsSpeaking = false;
    let monolithSelectedRuVoice = null;

    let monolithKeepAliveAudio = null;
    let monolithAudioCtx = null;
    let monolithKeepAliveOsc = null;
    let monolithKeepAliveGain = null;
    let monolithKeepAliveTimerId = null;
    let monolithTtsResumeTimerId = null;
    let monolithAudioPrimed = false;

    // very small silent WAV (short) as data URI
    const MONOLITH_SILENT_WAV = 'data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABAAZGF0YQAAAAA=';

    function isMonolithVoiceEnabled() {
        return !!monolithVoiceEnabled;
    }

    function loadMonolithVoiceEnabled() {
        try {
            const raw = localStorage.getItem(MONOLITH_VOICE_ENABLED_KEY);
            if (raw === 'true' || raw === 'false') monolithVoiceEnabled = (raw === 'true');
        } catch (e) {}
    }

    function saveMonolithVoiceEnabled() {
        try { localStorage.setItem(MONOLITH_VOICE_ENABLED_KEY, monolithVoiceEnabled ? 'true' : 'false'); } catch (e) {}
    }

    function applyMonolithVoiceToggleUI() {
        const el = document.getElementById('voice-enable');
        if (!el) return;
        el.checked = !!monolithVoiceEnabled;
    }

    function initMonolithVoiceToggle() {
        loadMonolithVoiceEnabled();
        applyMonolithVoiceToggleUI();
        const el = document.getElementById('voice-enable');
        if (!el) return;
        el.addEventListener('change', () => {
            monolithVoiceEnabled = !!el.checked;
            saveMonolithVoiceEnabled();
            if (!monolithVoiceEnabled) {
                try { monolithClearTtsQueue(true); } catch (e) {}
                try { monolithStopKeepAliveAudio(); } catch (e) {}
                try { monolithReleaseWakeLock(); } catch (e) {}
            } else {
                try { monolithMaybeUpdateWakeLock(); } catch (e) {}
            }
        });
    }

    function monolithPickRussianVoice() {
        if (!window.speechSynthesis) return null;
        try {
            const voices = window.speechSynthesis.getVoices ? (window.speechSynthesis.getVoices() || []) : [];
            const ru = voices.filter(v => String(v?.lang || '').toLowerCase().startsWith('ru'));
            if (!ru.length) return null;
            const preferred = ru.find(v => /google|yandex|windows|microsoft/i.test(String(v?.name || '')));
            return preferred || ru[0];
        } catch (e) {
            return null;
        }
    }

    function monolithEnsureVoicesReady() {
        if (!window.speechSynthesis) return;
        try { window.speechSynthesis.getVoices(); } catch (e) {}
        try {
            window.speechSynthesis.onvoiceschanged = () => {
                monolithSelectedRuVoice = monolithPickRussianVoice();
            };
        } catch (e) {}
        monolithSelectedRuVoice = monolithPickRussianVoice();
    }

    function monolithSpeakNextFromQueue() {
        if (!isMonolithVoiceEnabled()) return;
        if (!window.speechSynthesis) return;
        if (monolithTtsIsSpeaking) return;
        if (!monolithTtsQueue.length) return;

        const next = monolithTtsQueue.shift();
        if (!next) return;

        monolithTtsIsSpeaking = true;
        const utterance = new SpeechSynthesisUtterance(String(next));
        utterance.lang = 'ru-RU';
        utterance.rate = 1.0;
        utterance.pitch = 1.0;
        utterance.volume = 1.0;
        if (!monolithSelectedRuVoice) monolithSelectedRuVoice = monolithPickRussianVoice();
        if (monolithSelectedRuVoice) utterance.voice = monolithSelectedRuVoice;

        utterance.onend = () => {
            monolithTtsIsSpeaking = false;
            monolithSpeakNextFromQueue();
        };
        utterance.onerror = () => {
            monolithTtsIsSpeaking = false;
            monolithSpeakNextFromQueue();
        };

        try {
            window.speechSynthesis.speak(utterance);
        } catch (e) {
            monolithTtsIsSpeaking = false;
        }
    }

    function monolithClearTtsQueue(cancelNow = false) {
        monolithTtsQueue = [];
        monolithTtsIsSpeaking = false;
        if (cancelNow && window.speechSynthesis) {
            try { window.speechSynthesis.cancel(); } catch (e) {}
        }
    }

    // Требование: если синтез уже говорит — новые фразы в очередь, не прерывать.
    function aiSpeak(text) {
        const t = String(text || '').trim();
        if (!t) return;
        if (!isMonolithVoiceEnabled()) return;
        if (!window.speechSynthesis) return;

        monolithSoftResumeSpeech();
        monolithEnsureVoicesReady();
        monolithTtsQueue.push(t);

        // при старте озвучки пытаемся удержать процесс живым (в пределах возможностей браузера)
        try { monolithMaybeUpdateWakeLock(); } catch (e) {}
        try { monolithMaybeStartKeepAliveAudio(); } catch (e) {}

        monolithSpeakNextFromQueue();
    }

    async function monolithRequestWakeLock() {
        if (!('wakeLock' in navigator)) return;
        if (!isFeatureAllowedByPolicy('screen-wake-lock')) {
            if (!monolithRequestWakeLock.__policyWarned) {
                monolithRequestWakeLock.__policyWarned = true;
                console.info('Wake Lock недоступен в текущем контейнере Telegram/WebView — работаем без него.');
            }
            return;
        }
        if (!monolithIsVoiceSessionActive()) return;
        if (!isMonolithVoiceEnabled()) return;
        if (document.hidden) return; // screen wake lock обычно требует видимую вкладку

        try {
            if (monolithWakeLock) return;
            monolithWakeLock = await navigator.wakeLock.request('screen');
            monolithWakeLock.addEventListener('release', () => {
                monolithWakeLock = null;
            });
        } catch (e) {
            monolithWakeLock = null;
        }
    }

    function monolithReleaseWakeLock() {
        try {
            if (monolithWakeLock) {
                monolithWakeLock.release();
                monolithWakeLock = null;
            }
        } catch (e) {
            monolithWakeLock = null;
        }
    }

    function monolithSetNavigationActive(active) {
        monolithNavigationActive = !!active;
        monolithMaybeUpdateWakeLock();
        if (!monolithIsVoiceSessionActive()) {
            monolithStopKeepAliveAudio();
        }
    }

    function monolithIsVoiceSessionActive() {
        const gpsActive = (typeof gpsWatchId !== 'undefined' && gpsWatchId !== null && gpsWatchId !== undefined);
        return !!(isMonolithVoiceEnabled() && (monolithNavigationActive || gpsActive || monolithTtsIsSpeaking || monolithTtsQueue.length > 0));
    }

    function monolithMaybeUpdateWakeLock() {
        if (!monolithIsVoiceSessionActive()) {
            monolithReleaseWakeLock();
            return;
        }
        monolithRequestWakeLock();
    }

    function monolithSoftResumeSpeech() {
        try {
            if (!window.speechSynthesis) return;
            try { window.speechSynthesis.getVoices(); } catch (e) {}
            try { window.speechSynthesis.resume(); } catch (e) {}
        } catch (e) {}
    }

    function monolithPrimeAudioOnce() {
        if (monolithAudioPrimed) return;

        // Android/WebView: часто нужно "разбудить" speechSynthesis после user gesture.
        try {
            if (window.speechSynthesis) {
                try { window.speechSynthesis.getVoices(); } catch(e) {}
                try { window.speechSynthesis.resume(); } catch(e) {}
            }
        } catch (e) {}
        try {
            const a = new Audio(MONOLITH_SILENT_WAV);
            a.volume = 0.001;
            a.play().then(() => {
                try { a.pause(); } catch(e) {}
            }).catch(() => {
                // ignore
            });
        } catch (e) {}

        monolithAudioPrimed = true;
        try { monolithStartAudioContextKeepAlive(); } catch (e) {}
    }

    function monolithEnsureAudioContext() {
        if (monolithAudioCtx) return monolithAudioCtx;
        const Ctx = window.AudioContext || window.webkitAudioContext;
        if (!Ctx) return null;
        try {
            monolithAudioCtx = new Ctx();
            return monolithAudioCtx;
        } catch (e) {
            monolithAudioCtx = null;
            return null;
        }
    }

    function monolithStartAudioContextKeepAlive() {
        if (!monolithIsVoiceSessionActive() || !monolithAudioPrimed) return;
        const ctx = monolithEnsureAudioContext();
        if (!ctx) return;

        try {
            if (ctx.state === 'suspended' && typeof ctx.resume === 'function') {
                ctx.resume().catch(() => {});
            }
        } catch (e) {}

        if (monolithKeepAliveOsc) return;

        try {
            const gain = ctx.createGain();
            gain.gain.value = 0.00001;
            const osc = ctx.createOscillator();
            osc.type = 'sine';
            osc.frequency.value = 24;
            osc.connect(gain);
            gain.connect(ctx.destination);
            osc.start();
            monolithKeepAliveGain = gain;
            monolithKeepAliveOsc = osc;
        } catch (e) {
            monolithKeepAliveOsc = null;
            monolithKeepAliveGain = null;
        }
    }

    function monolithStopAudioContextKeepAlive() {
        try {
            if (monolithKeepAliveOsc) {
                monolithKeepAliveOsc.stop();
                monolithKeepAliveOsc.disconnect();
            }
        } catch (e) {}
        monolithKeepAliveOsc = null;
        try {
            if (monolithKeepAliveGain) monolithKeepAliveGain.disconnect();
        } catch (e) {}
        monolithKeepAliveGain = null;
    }

    function monolithMaybeStartKeepAliveAudio() {
        if (!monolithIsVoiceSessionActive()) return;

        // многие браузеры запрещают autoplay без user gesture
        if (!monolithAudioPrimed) return;

        monolithStartAudioContextKeepAlive();

        if (!monolithKeepAliveAudio) {
            monolithKeepAliveAudio = new Audio(MONOLITH_SILENT_WAV);
            monolithKeepAliveAudio.loop = true;
            monolithKeepAliveAudio.volume = 0.001;
        }

        if (monolithKeepAliveTimerId) return;
        monolithKeepAliveTimerId = setInterval(() => {
            try {
                if (!monolithKeepAliveAudio) return;
                if (!document.hidden) return; // keep-alive нужен именно при сворачивании
                monolithKeepAliveAudio.play().catch(() => {});
            } catch (e) {}
        }, 25000);

        // первый старт
        try {
            if (document.hidden) monolithKeepAliveAudio.play().catch(() => {});
        } catch (e) {}

        // небольшой "пинок" для TTS в фоне (мягко)
        if (!monolithTtsResumeTimerId) {
            monolithTtsResumeTimerId = setInterval(() => {
                try {
                    if (!document.hidden) return;
                    if (!window.speechSynthesis) return;
                    if (window.speechSynthesis.speaking) {
                        window.speechSynthesis.resume();
                    }
                } catch (e) {}
            }, 3000);
        }
    }

    function monolithStopKeepAliveAudio() {
        if (monolithKeepAliveTimerId) {
            clearInterval(monolithKeepAliveTimerId);
            monolithKeepAliveTimerId = null;
        }
        if (monolithTtsResumeTimerId) {
            clearInterval(monolithTtsResumeTimerId);
            monolithTtsResumeTimerId = null;
        }
        try {
            if (monolithKeepAliveAudio) {
                monolithKeepAliveAudio.pause();
                monolithKeepAliveAudio.currentTime = 0;
            }
        } catch (e) {}
        monolithStopAudioContextKeepAlive();
    }

    // Prime audio on first user interaction (needed for background keep-alive hacks)
    window.addEventListener('touchstart', monolithPrimeAudioOnce, { passive: true });
    window.addEventListener('click', monolithPrimeAudioOnce, { passive: true });
    window.addEventListener('pointerdown', monolithPrimeAudioOnce, { passive: true });

    document.addEventListener('visibilitychange', () => {
        // Требование: при сворачивании звук продолжал работать.
        // Реальность: браузер/ОС могут всё равно душить TTS. Здесь — best-effort.
        try {
            if (document.hidden) {
                monolithMaybeStartKeepAliveAudio();
            } else {
                monolithStopKeepAliveAudio();
                monolithMaybeUpdateWakeLock();
                if (window.speechSynthesis) {
                    try { window.speechSynthesis.resume(); } catch(e) {}
                }
            }
        } catch (e) {}
    });

    function speakSmartHintText(text) {
        const t = String(text || '').trim();
        if (!t) return;
        try { aiSpeak(t); } catch(e) {}
    }

    let lastSmartHintCheckAt = 0;
    async function maybeCheckSmartHint(lat, lon) {
        try {
            if (!uid) return;
            if (!gpsReliable) return;
            const speed = Number(userSpeedKmh) || 0;
            if (speed < 10) return;

            const now = Date.now();
            if (now - lastSmartHintCheckAt < 45000) return;
            lastSmartHintCheckAt = now;

            let token = localStorage.getItem('sb_jwt') || '';
            if (!token) {
                const refreshed = await ensureSupabaseAuth();
                token = refreshed || localStorage.getItem('sb_jwt') || '';
            }
            if (!token) return;

            const resp = await fetch(`${SUPABASE_URL}/functions/v1/smart-hints?action=check`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    Authorization: `Bearer ${token}`
                },
                body: JSON.stringify({ lat: Number(lat), lon: Number(lon), ts_ms: now })
            });

            if (!resp.ok) return;
            const data = await resp.json().catch(()=>null);
            const hint = data?.hint;
            if (!hint || !hint.key) return;

            const hintKey = String(hint.key || '').trim();
            if (!hintKey) return;

            const lastKey = String(localStorage.getItem('last_smart_hint_key') || '').trim();
            const lastTs = Number(localStorage.getItem('last_smart_hint_ts') || 0);
            if (lastKey === hintKey && (now - lastTs) < 60 * 60 * 1000) return; // 1h cooldown per same hint

            localStorage.setItem('last_smart_hint_key', hintKey);
            localStorage.setItem('last_smart_hint_ts', String(now));

            showInAppNotification({
                title: String(hint.title || '🧠 Подсказка'),
                body: String(hint.body || ''),
                priority: 'high'
            });
            speakSmartHintText(String(hint.voice || ''));
        } catch (e) {
            console.warn('maybeCheckSmartHint error:', e?.message || e);
        }
    }

    function setActiveProximityMarker(markerId, markerType, markerCoords, distance) {
        if (!markerId) return;
        if (!markerCoords || !Array.isArray(markerCoords) || markerCoords.length < 2) return;

        const currentId = proximityBannerState.markerId;
        if (!currentId || currentId === markerId || distance < (proximityBannerState.lastDistance || Infinity)) {
            proximityBannerState.markerId = markerId;
            proximityBannerState.markerType = markerType;
            proximityBannerState.markerCoords = markerCoords;
            proximityBannerState.lastDistance = distance;
            proximityBannerState.lastUpdateTs = Date.now();
            updateProximityBanner(distance, markerType);
        }
    }

    function clearActiveProximityMarker(markerId) {
        if (proximityBannerState.markerId === markerId) {
            proximityBannerState.markerId = null;
            proximityBannerState.markerType = null;
            proximityBannerState.markerCoords = null;
            proximityBannerState.lastDistance = null;
            proximityBannerState.lastUpdateTs = 0;
            hideProximityBanner();
        }
    }

    function refreshProximityBanner() {
        if (!proximityBannerState.markerId || !proximityBannerState.markerCoords || !userLocation) return;
        const coords = proximityBannerState.markerCoords;
        const lat = Number(coords[0]);
        const lon = Number(coords[1]);
        if (!isFinite(lat) || !isFinite(lon)) return;

        const distance = calculateDistance(userLocation[0], userLocation[1], lat, lon);
        const prev = proximityBannerState.lastDistance;
        const warningMax = getDynamicWarningMaxMeters();

        if (isFinite(prev) && distance > prev + 25) {
            distanceNotifications.delete(proximityBannerState.markerId);
            markerDistanceState.set(proximityBannerState.markerId, { lastDistance: distance, lastTrend: 'away', lastUpdate: Date.now() });
            clearActiveProximityMarker(proximityBannerState.markerId);
            stopWarningOutput();
            return;
        }

        if (distance > warningMax) {
            clearActiveProximityMarker(proximityBannerState.markerId);
            return;
        }

        proximityBannerState.lastDistance = distance;
        proximityBannerState.lastUpdateTs = Date.now();
        updateProximityBanner(distance, proximityBannerState.markerType);
    }

    function startProximityBannerLoop() {
        if (proximityBannerIntervalId) return;
        proximityBannerIntervalId = setInterval(() => {
            try { refreshProximityBanner(); } catch (e) { /* ignore */ }
        }, 2500);
    }
    
    /**
    * Озвучивает предупреждение о дорожном событии
     * @param {number} distance - расстояние в метрах
    * @param {string} type - тип метки (dps, patrol, sos и т.д.)
     * @param {string} comment - комментарий к метке
     */
    /**
     * Воспроизводит готовое аудио предупреждение
     * @param {string} audioUrl - URL аудиофайла
     */
    function playAudioWarning(audioUrl) {
        try {
            stopWarningOutput();
            const audio = new Audio(audioUrl);
            currentWarningAudio = audio;
            audio.volume = 1;
            audio.play().catch(err => {
                console.warn('Ошибка воспроизведения аудио:', err);
                // Если аудио не работает, пытаемся синтез речи
                useSpeechSynthesis = true;
            });
        } catch (e) {
            console.warn('Не удалось загрузить аудио:', e);
        }
    }
    
    async function speakWarning(distance, type, comment) {
        if (!voiceStyle) voiceStyle = 'standard';
        stopWarningOutput();

        // v2: по умолчанию используем «живую» озвучку на лету (можно подставлять улицы/время/любые фразы).
        // MP3 оставляем как запасной вариант (на случай, если Web Speech API недоступен).
        if (window.speechSynthesis) {
            useWebSpeechAPI(distance, type);
            return;
        }
        
        // Определяем категорию расстояния
        const distanceCategory = distance < 200 ? 'close' : 'far';
        
        // Определяем MP3 файл
        const audioFile = voiceStyle === 'cheeky' 
            ? `warning_cheeky_${distanceCategory}.mp3` 
            : `warning_standard_${distanceCategory}.mp3`;
        
        try {
            // Пытаемся загрузить MP3 из Supabase Storage
            if (typeof _sb !== 'undefined' && _sb.storage) {
                const { data } = await _sb.storage
                    .from('audio')
                    .createSignedUrl(audioFile, 3600);
                
                if (data?.signedUrl) {
                    const audio = new Audio(data.signedUrl);
                    currentWarningAudio = audio;
                    audio.volume = 1.0;
                    audio.play().catch(e => {
                        console.warn('Не удалось воспроизвести MP3:', e);
                        useWebSpeechAPI(distance, type);
                    });
                    console.log(`🔊 Проигрывается: ${audioFile}`);
                    return;
                }
            }
        } catch (e) {
            console.warn(`⚠️ Ошибка загрузки ${audioFile}:`, e?.message);
        }
        
        // Если синтез речи недоступен, и MP3 тоже не удалось — просто молча выходим.
    }
    
    /**
     * Использует Web Speech API как fallback (с новым текстом озвучки)
     */
    function useWebSpeechAPI(distance, type) {
        if (!window.speechSynthesis) {
            console.warn('Web Speech API не поддерживается');
            console.warn('Попробуйте проверить браузер, возможно, нужен Chrome, Edge или Safari');
            return;
        }

        // Пытаемся выбрать русский голос (если он установлен в системе)
        try {
            if (!window.__ttsVoicesReady) {
                window.__ttsVoicesReady = true;
                try {
                    // Инициируем загрузку списка голосов
                    window.speechSynthesis.getVoices();
                } catch(e) {}
                try {
                    window.speechSynthesis.onvoiceschanged = () => {
                        try { window.__ttsVoices = window.speechSynthesis.getVoices() || []; } catch(e) {}
                    };
                } catch(e) {}
                try { window.__ttsVoices = window.speechSynthesis.getVoices() || []; } catch(e) {}
            }
        } catch (e) {}

        function pickRussianVoice() {
            try {
                const voices = (window.__ttsVoices && Array.isArray(window.__ttsVoices))
                    ? window.__ttsVoices
                    : (window.speechSynthesis.getVoices() || []);
                const ru = voices.filter(v => String(v?.lang || '').toLowerCase().startsWith('ru'));
                if (!ru.length) return null;
                // Стараемся выбрать наиболее "приятный" (часто Google/Яндекс/Windows)
                const preferred = ru.find(v => /google|yandex|windows|microsoft/i.test(String(v?.name || '')));
                return preferred || ru[0];
            } catch (e) {
                return null;
            }
        }
        
        // Округляем расстояние
        let distancePretty;
        if (distance > 1000) {
            distancePretty = Math.round(distance / 100) * 100;
        } else if (distance > 100) {
            distancePretty = Math.round(distance / 10) * 10;
        } else {
            distancePretty = Math.round(distance);
        }
        
        let text;
        const messageByType = {
            dps: `Впереди пост ДПС через ${distancePretty} метров. Соблюдайте правила и будьте внимательны.`,
            patrol: `Впереди дорожный рейд через ${distancePretty} метров. Двигайтесь спокойно и без нарушений.`,
            specbat: `Впереди усиленный контроль (спецбат) через ${distancePretty} метров. Соблюдайте требования инспекторов.`,
            motobat: `Впереди патруль мотобата через ${distancePretty} метров. Снизьте скорость и держите дистанцию.`,
            cargo_control: `Впереди грузовой контроль через ${distancePretty} метров. Проверьте документы и параметры груза.`,
            camera: `Впереди участок наблюдения через ${distancePretty} метров. Будьте внимательны.`,
            dtp: `Впереди ДТП через ${distancePretty} метров. Снизьте скорость и соблюдайте дистанцию.`,
            works: `Впереди дорожные работы через ${distancePretty} метров. Двигайтесь внимательно.`,
            sos: `Впереди SOS-запрос помощи через ${distancePretty} метров. При возможности окажите поддержку.`,
            danger: `Впереди опасность на дороге через ${distancePretty} метров. Будьте особенно осторожны.`,
            traffic_jam: `Впереди пробка через ${distancePretty} метров. По возможности выберите объезд.`
        };

        if (voiceStyle === 'cheeky') {
            text = messageByType[type] || `Впереди дорожное событие через ${distancePretty} метров. Будьте внимательны.`;
        } else {
            text = messageByType[type] || `Впереди дорожное событие через ${distancePretty} метров. Будьте внимательны.`;
        }
        
        // Требование MONOLITH 180: не прерывать друг друга — ставим в очередь
        console.log(`🔊 Озвучка (${voiceStyle}): ${text.substring(0, 50)}...`);
        aiSpeak(text);
    }
    
    /**
     * Проверяет расстояние до маркера и выдает уведомление если нужно
     * @param {Object} marker - объект маркера из БД
     * @param {Array} userCoords - координаты пользователя [lat, lon]
     */
    function checkMarkerDistance(marker, userCoords) {
            if (!userCoords || userCoords.length < 2) return;
            const followOkForBanner = !(proximityRequiresFollow && !autoFollow);

            // Поддерживаем разные форматы координат маркера: coords: [lat,lon] или latitude/longitude
            let mLat = null, mLon = null;
            if (marker.coords && Array.isArray(marker.coords) && marker.coords.length >= 2) {
                // Некоторые маркеры хранят координаты в виде [lon, lat] или [lat, lon] — попробуем угадать.
                // Если значение похоже на долготу в первом элементе (|value| > 90), меняем порядок.
                const a = Number(marker.coords[0]);
                const b = Number(marker.coords[1]);
                if (Math.abs(a) <= 90 && Math.abs(b) <= 180) {
                    // считаем coords = [lat, lon]
                    mLat = a; mLon = b;
                } else if (Math.abs(a) <= 180 && Math.abs(b) <= 90) {
                    // возможно coords = [lon, lat]
                    mLat = b; mLon = a;
                } else {
                    // fallback: используем второй как долготу
                    mLat = a; mLon = b;
                }
            } else if (typeof marker.latitude === 'number' && typeof marker.longitude === 'number') {
                mLat = marker.latitude; mLon = marker.longitude;
            } else if (marker.lat && marker.lon) {
                mLat = Number(marker.lat); mLon = Number(marker.lon);
            }
            if (mLat === null || mLon === null) return;

            const distance = calculateDistance(userCoords[0], userCoords[1], mLat, mLon);
            const markerType = String(marker?.type || '');
            const userDistSetting = getUserDistSettingMeters();

            if (distance <= Math.max(userDistSetting + 600, MONOLITH_SOS_PRIORITY_RADIUS_METERS + 300)) {
                monolithResolveStreetForMarker(marker.id, mLat, mLon);
            }
            const knownStreet = monolithResolveStreetForMarker(marker.id, mLat, mLon);
        
        const markerId = marker.id;
        const currentNotification = distanceNotifications.get(markerId) || {};
        const warningMax = getDynamicWarningMaxMeters();

        const prevState = markerDistanceState.get(markerId);
        let trend = prevState?.lastTrend || 'approaching';
        if (prevState && typeof prevState.lastDistance === 'number') {
            if (distance > prevState.lastDistance + 25) trend = 'away';
            else if (distance < prevState.lastDistance - 25) trend = 'approaching';
        }
        markerDistanceState.set(markerId, { lastDistance: distance, lastTrend: trend, lastUpdate: Date.now() });

        // Crowdsourcing: если проехали мимо и начинаем удаляться — спросить "Тут ещё стоят?"
        try {
            if (shouldCrowdConfirmType(marker.type)) {
                const now = Date.now();
                const st = crowdConfirmState.get(markerId) || { askedAt: 0, wasNear: false };

                // Только при нормальном GPS и движении (иначе будет спрашивать пешком/на месте)
                const speed = Number(userSpeedKmh) || 0;
                if (!gpsReliable || speed < 10) {
                    crowdConfirmState.set(markerId, st);
                } else {
                    const passNearMeters = Math.max(80, Math.min(180, Math.round(userDistSetting * 0.35)));
                    if (distance <= passNearMeters) st.wasNear = true;

                    const cooldownOk = !st.askedAt || (now - st.askedAt) > CROWD_CONFIRM_COOLDOWN_MS;
                    if (trend === 'away' && st.wasNear && cooldownOk && distance >= MONOLITH_POST_PASS_ASK_METERS) {
                        st.askedAt = now;
                        st.wasNear = false;
                        crowdConfirmState.set(markerId, st);
                        crowdConfirmShow(markerId, marker.type, knownStreet);
                    } else {
                        crowdConfirmState.set(markerId, st);
                    }
                }
            }
        } catch (e) {}

        if (trend === 'away') {
            if (currentNotification) {
                distanceNotifications.delete(markerId);
                stopWarningOutput();
            }
            if (proximityBannerState.markerId === markerId) {
                clearActiveProximityMarker(markerId);
            }
            return;
        }

        if (followOkForBanner) {
            if (distance <= warningMax) {
                setActiveProximityMarker(markerId, marker.type, [mLat, mLon], distance);
            } else if (proximityBannerState.markerId === markerId) {
                clearActiveProximityMarker(markerId);
            }
        }

        if (!isMonolithVoiceEnabled()) return;
        const threshold = userDistSetting;
        const hysteresis = threshold + 140;
        const prevDistance = Number(prevState?.lastDistance);
        const crossedThreshold = Number.isFinite(prevDistance) && prevDistance > threshold && distance <= threshold;
        const street = knownStreet || 'этой улице';

        if (markerType === 'sos') {
            if (distance <= MONOLITH_SOS_PRIORITY_RADIUS_METERS && !currentNotification.sosPriorityAnnounced) {
                aiSpeak(monolithBuildSosPriorityText(street));
                currentNotification.sosPriorityAnnounced = true;
                currentNotification.sosPriorityAt = Date.now();
                distanceNotifications.set(markerId, currentNotification);
            } else if (distance > (MONOLITH_SOS_PRIORITY_RADIUS_METERS + 500) && currentNotification.sosPriorityAnnounced) {
                currentNotification.sosPriorityAnnounced = false;
                if (!currentNotification.mainAnnounced) distanceNotifications.delete(markerId);
                else distanceNotifications.set(markerId, currentNotification);
            }
            return;
        }

        if (crossedThreshold || (!currentNotification.mainAnnounced && distance <= threshold && trend !== 'away')) {
            if (markerType === 'specbat') {
                try { playSpecbatSound(); } catch (e) {}
                try { navigator.vibrate([90, 60, 90, 60, 140]); } catch (e) {}
            }

            aiSpeak(monolithBuildApproachVoiceText(markerType, street, distance));
            currentNotification.mainAnnounced = true;
            currentNotification.mainAt = Date.now();
            distanceNotifications.set(markerId, currentNotification);
            console.log(`📍 Голос: маркер ${markerId} (${distance.toFixed(0)}м)`);
        } else if (distance > hysteresis && currentNotification.mainAnnounced) {
            currentNotification.mainAnnounced = false;
            if (!currentNotification.sosPriorityAnnounced) distanceNotifications.delete(markerId);
            else distanceNotifications.set(markerId, currentNotification);
        }
    }

    /**
     * Устанавливает стиль озвучки уведомлений о расстоянии
     * @param {string} style - 'standard' или 'cheeky'
     */
    function setVoiceStyle(style) {
        if (!isViewingOwnProfile) return;
        voiceStyle = style;
        
        // Обновляем визуальное состояние кнопок
        const standardBtn = document.getElementById('voiceStyleStandard');
        const cheekyBtn = document.getElementById('voiceStyleCheeky');
        const descriptionEl = document.getElementById('voiceStyleDescription');
        
        if (style === 'standard') {
            standardBtn.style.background = '#34c759';
            standardBtn.style.color = 'white';
            cheekyBtn.style.background = '#9c9c9c';
            cheekyBtn.style.color = 'white';
            descriptionEl.textContent = '✨ Выбран: Стандартный стиль озвучки';
        } else if (style === 'cheeky') {
            standardBtn.style.background = '#9c9c9c';
            standardBtn.style.color = 'white';
            cheekyBtn.style.background = '#34c759';
            cheekyBtn.style.color = 'white';
            descriptionEl.textContent = '😎 Выбран: Дерзкий стиль озвучки';
        }
        
        // Сохраняем выбор в localStorage
        try {
            localStorage.setItem('voiceStyle', style);
        } catch (e) {
            console.warn('Не удалось сохранить стиль озвучки:', e);
        }
        // Обновляем внешний вид маркера сразу
        try { updateUserLocationMarker(); } catch(e){}
        
        console.log(`🔊 Стиль озвучки изменен на: ${style}`);
    }
    
    /**
     * Загружает сохраненный стиль озвучки при инициализации
     */
    function loadVoiceStyle() {
        try {
            const savedStyle = localStorage.getItem('voiceStyle');
            if (savedStyle === 'cheeky' || savedStyle === 'standard') {
                voiceStyle = savedStyle;
            }
        } catch (e) {
            console.warn('Не удалось загрузить стиль озвучки:', e);
        }
    }

    function updateWarningDistanceUI() {
        const label = document.getElementById('warningDistanceLabel');
        const range = document.getElementById('warningDistanceRange');
        const meters = getUserDistSettingMeters();
        if (label) {
            label.textContent = meters >= 1000 ? `${(meters / 1000).toFixed(1)} км` : `${meters} м`;
        }
        if (range && String(range.value) !== String(meters)) {
            range.value = meters;
        }
    }

    function setWarningDistance(value) {
        if (!isViewingOwnProfile) return;
        warningDistanceMeters = normalizeWarningDistanceMeters(value);
        updateWarningDistanceUI();
        distanceNotifications.clear();
        try {
            localStorage.setItem('warningDistanceMeters', String(warningDistanceMeters));
        } catch (e) {
            console.warn('Не удалось сохранить дистанцию предупреждения:', e);
        }
    }

    function loadWarningDistance() {
        try {
            const saved = localStorage.getItem('warningDistanceMeters');
            if (saved) warningDistanceMeters = normalizeWarningDistanceMeters(saved);
        } catch (e) {
            console.warn('Не удалось загрузить дистанцию предупреждения:', e);
        }
        updateWarningDistanceUI();
    }

    function setProximityMode(requireFollow) {
        if (!isViewingOwnProfile) return;
        proximityRequiresFollow = !!requireFollow;
        const alwaysBtn = document.getElementById('proximityModeAlways');
        const followBtn = document.getElementById('proximityModeFollow');
        const descriptionEl = document.getElementById('proximityModeDescription');

        if (proximityRequiresFollow) {
            if (alwaysBtn) { alwaysBtn.style.background = '#9c9c9c'; alwaysBtn.style.color = 'white'; }
            if (followBtn) { followBtn.style.background = '#34c759'; followBtn.style.color = 'white'; }
            if (descriptionEl) descriptionEl.textContent = 'Выбран: Только при автослежении';
        } else {
            if (alwaysBtn) { alwaysBtn.style.background = '#34c759'; alwaysBtn.style.color = 'white'; }
            if (followBtn) { followBtn.style.background = '#9c9c9c'; followBtn.style.color = 'white'; }
            if (descriptionEl) descriptionEl.textContent = 'Выбран: Всегда';
        }

        try {
            localStorage.setItem('proximityRequiresFollow', proximityRequiresFollow ? 'true' : 'false');
        } catch (e) {
            console.warn('Не удалось сохранить режим оповещений:', e);
        }

        updateFollowButton();
    }

    function loadProximityMode() {
        try {
            const saved = localStorage.getItem('proximityRequiresFollow');
            if (saved === 'true' || saved === 'false') {
                proximityRequiresFollow = (saved === 'true');
            }
        } catch (e) {
            console.warn('Не удалось загрузить режим оповещений:', e);
        }
        setProximityMode(proximityRequiresFollow);
    }

    function updateMarkerRenderModeUI() {
        const allBtn = document.getElementById('markerRenderAllBtn');
        const nearbyBtn = document.getElementById('markerRenderNearbyBtn');
        const isAll = markerRenderMode === 'all';
        if (allBtn) {
            allBtn.style.background = isAll ? '#34c759' : '#9c9c9c';
            allBtn.style.color = 'white';
        }
        if (nearbyBtn) {
            nearbyBtn.style.background = isAll ? '#9c9c9c' : '#34c759';
            nearbyBtn.style.color = 'white';
        }
    }

    function setMarkerRenderMode(mode) {
        const next = (mode === 'all') ? 'all' : 'nearby';
        markerRenderMode = next;
        updateMarkerRenderModeUI();
        try { localStorage.setItem(MARKER_RENDER_MODE_KEY, markerRenderMode); } catch (e) {}
        if (typeof loadMarkersDebounced === 'function') loadMarkersDebounced();
    }

    function loadMarkerRenderMode() {
        try {
            const saved = String(localStorage.getItem(MARKER_RENDER_MODE_KEY) || '').trim();
            if (saved === 'all' || saved === 'nearby') markerRenderMode = saved;
        } catch (e) {}
        updateMarkerRenderModeUI();
    }

    function loadDynamicCourseEnabled() {
        try {
            const raw = localStorage.getItem(DYNAMIC_COURSE_ENABLED_KEY);
            if (raw === 'true' || raw === 'false') dynamicCourseEnabled = (raw === 'true');
        } catch (e) {}
    }

    function saveDynamicCourseEnabled() {
        try { localStorage.setItem(DYNAMIC_COURSE_ENABLED_KEY, dynamicCourseEnabled ? 'true' : 'false'); } catch (e) {}
    }

    function updateCourseBtnUiState() {
        const btn = document.getElementById('ccCourseBtn');
        if (!btn) return;
        btn.classList.toggle('active', !!dynamicCourseEnabled);
        btn.classList.toggle('off', !dynamicCourseEnabled);
        btn.textContent = dynamicCourseEnabled ? '🧭' : '🧱';
        btn.title = dynamicCourseEnabled ? 'Динамический курс: ВКЛ' : 'Динамический курс: ВЫКЛ';
    }

    function toggleDynamicCourseFromUI() {
        dynamicCourseEnabled = !dynamicCourseEnabled;
        saveDynamicCourseEnabled();
        if (dynamicCourseEnabled) {
            requestDynamicCourseOrientationPermission().catch(()=>{});
            try { updateDynamicCourseCamera(); } catch (e) {}
        }
        updateCourseBtnUiState();
    }

        function isReliableGeoPosition(lat, lon, accuracyMeters) {
                const a = Number(accuracyMeters);
                if (!Number.isFinite(lat) || !Number.isFinite(lon)) return false;
                if (!Number.isFinite(a)) return false;
                // Если погрешность очень большая — это почти всегда IP/кэш-локация (Telegram Desktop/Web)
                if (a > 5000) return false;
                // Если точка не в ДНР — скорее всего неверные данные
                if (!isInDonetskRegion([lat, lon])) return false;
                return true;
        }

    function initGPS() {
        if (!navigator.geolocation) {
            console.warn('Geolocation не поддерживается браузером');
            return;
        }
        
        // Опции для geolocation
        const options = {
            enableHighAccuracy: true,
            timeout: 15000,            // Оптимизация: увеличили таймаут
            maximumAge: 0              // Не берём кэш — в WebView он часто даёт неверные координаты
        };
        
        // Начинаем отслеживание местоположения с вычислением скорости
        try {
            // Если доступна Permissions API — логируем состояние (полезно для iOS/Android в WebView)
            if (navigator.permissions && navigator.permissions.query) {
                try {
                    navigator.permissions.query({ name: 'geolocation' }).then(p => {
                        console.log('GPS permission state:', p.state);
                        p.onchange = () => console.log('GPS permission changed:', p.state);
                    }).catch(()=>{});
                } catch(e){}
            }

            gpsWatchId = navigator.geolocation.watchPosition(
                (position) => {
                    // Успешное получение координат
                    const { latitude, longitude, accuracy } = position.coords;
                    const now = Date.now();
                    const heading = position?.coords?.heading;

                    lastGpsAccuracyMeters = Number(accuracy);
                    const latNum = Number(latitude);
                    const lonNum = Number(longitude);
                    const reliableNow = isReliableGeoPosition(latNum, lonNum, Number(accuracy));
                    gpsReliable = reliableNow;

                    if (!reliableNow) {
                        if (!gpsWarnedUnreliable) {
                            gpsWarnedUnreliable = true;
                            console.warn('⚠️ Геолокация неточная (большая погрешность или точка вне ДНР). Включите GPS и разрешите доступ к местоположению для Telegram, затем подождите 10–20 секунд.');
                        }
                        if (lastReliableUserLocation) {
                            // Не перетираем точные координаты мусором
                            return;
                        }
                        // Если точных ещё нет — покажем хотя бы маркер, но без синка радиуса и автоследования
                        userSpeedKmh = 0;
                        userLocation = [latNum, lonNum];
                        updateUserLocationMarker();
                        updateSpeedometerUI(userSpeedKmh);
                        console.log(`📍 GPS (не точно): ${latNum.toFixed(4)}, ${lonNum.toFixed(4)} (точность: ${Number(accuracy).toFixed(0)}м)`);
                        return;
                    }

                    // Вычисляем скорость на основе предыдущей позиции (м/c -> км/ч)
                    const prev = lastUserPositionCoords;
                    if (prev && lastUserPositionTime) {
                        const dt = (now - lastUserPositionTime) / 1000; // сек
                        if (dt > 0) {
                            const dist = calculateDistance(prev[0], prev[1], latitude, longitude); // метры
                            const speedMs = dist / dt; // м/с
                            userSpeedKmh = Math.round(speedMs * 3.6);
                        }
                    }

                    // heading в WebView часто null — тогда считаем курс по двум точкам
                    try {
                        if (Number.isFinite(Number(heading))) {
                            userHeadingDeg = (Number(heading) + 360) % 360;
                        } else if (prev && Array.isArray(prev) && prev.length >= 2) {
                            userHeadingDeg = (calculateBearingDeg(prev[0], prev[1], latitude, longitude) + 360) % 360;
                        }
                        if (Number.isFinite(Number(userHeadingDeg))) {
                            dynamicCourseGpsDeg = normalizeDeg(userHeadingDeg);
                        }
                    } catch(e) {}

                    lastUserPositionCoords = [latitude, longitude];
                    lastUserPositionTime = now;

                    userLocation = [latitude, longitude];
                    lastReliableUserLocation = [latitude, longitude];

                    // Рация: отправляем координаты на сервер (для радиуса 5 км)
                    try {
                        if (pttSocket && typeof pttSocket.emit === 'function') {
                            pttSocket.emit('ptt:loc', { lat: Number(latitude), lon: Number(longitude) });
                        }
                    } catch (e) {}

                    // Пишем последнюю координату в service worker (как "фоновой" источник правды)
                    // Важно: сам service worker не может запрашивать геолокацию.
                    try {
                        if (window.SafeDrivePwa && typeof window.SafeDrivePwa.postLocationToServiceWorker === 'function') {
                            window.SafeDrivePwa.postLocationToServiceWorker(position);
                        }
                    } catch (e) {}

                    // обновляем опорную точку для радиуса Telegram-уведомлений (если пользователь подписан)
                    syncHelpSubscriberHomeCoords(false).catch(()=>{});

                    // Обновляем маркер на карте (включая визуализацию скорости/ачивок/стиля)
                    updateUserLocationMarker();
                    updateSpeedometerUI(userSpeedKmh);

                    // Интеллектуальные подсказки по истории меток ДПС/Спецбат
                    maybeCheckSmartHint(latitude, longitude);

                    // Центрируем карту если автоследование включено
                    if (autoFollow && myMap && userLocation && !disableAutoFollowOnce) {
                        try { updateDynamicCourseCamera(); } catch (e) {
                            try { myMap.setCenter(userLocation, 17); } catch (e2) { console.warn(e2); }
                        }
                    }
                    if (disableAutoFollowOnce) disableAutoFollowOnce = false;
                    console.log(`📍 GPS: ${latitude.toFixed(4)}, ${longitude.toFixed(4)} (точность: ${accuracy.toFixed(0)}м) speed: ${userSpeedKmh} km/h`);
                },
                (error) => {
                    // Ошибка получения координат
                    console.warn('Ошибка GPS:', error.message);
                    switch(error.code) {
                        case error.PERMISSION_DENIED:
                            console.warn('Разрешение на доступ к GPS отклонено');
                            // Для мобильных WebView полезно показать инструкцию
                            if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
                                console.warn('iOS: откройте настройки приложения и разрешите доступ к местоположению.');
                            }
                            break;
                        case error.POSITION_UNAVAILABLE:
                            console.warn('Информация о местоположении недоступна — пробую один раз получить позицию');
                            // однократная попытка
                            navigator.geolocation.getCurrentPosition((pos) => {
                                const { latitude, longitude } = pos.coords;
                                try {
                                    const h = pos?.coords?.heading;
                                    if (Number.isFinite(Number(h))) {
                                        userHeadingDeg = (Number(h) + 360) % 360;
                                        dynamicCourseGpsDeg = normalizeDeg(userHeadingDeg);
                                    }
                                } catch(e) {}
                                userLocation = [latitude, longitude];
                                lastUserPositionCoords = [latitude, longitude];
                                lastUserPositionTime = Date.now();
                                updateUserLocationMarker();
                            }, ()=>{}, { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 });
                            break;
                        case error.TIMEOUT:
                            console.warn('Истекло время ожидания GPS — попробуйте ещё раз');
                            break;
                    }
                },
                options
            );
        } catch (e) {
            console.warn('watchPosition failed:', e);
        }
    }

    function calculateBearingDeg(lat1, lon1, lat2, lon2) {
        const toRad = (v) => (Number(v) || 0) * Math.PI / 180;
        const toDeg = (v) => v * 180 / Math.PI;
        const phi1 = toRad(lat1);
        const phi2 = toRad(lat2);
        const dLam = toRad(Number(lon2) - Number(lon1));
        const y = Math.sin(dLam) * Math.cos(phi2);
        const x = Math.cos(phi1) * Math.sin(phi2) - Math.sin(phi1) * Math.cos(phi2) * Math.cos(dLam);
        const theta = Math.atan2(y, x);
        return (toDeg(theta) + 360) % 360;
    }

    function normalizeDeg(v) {
        const n = Number(v);
        if (!Number.isFinite(n)) return 0;
        return ((n % 360) + 360) % 360;
    }

    function shortestAngleDeltaDeg(fromDeg, toDeg) {
        let d = normalizeDeg(toDeg) - normalizeDeg(fromDeg);
        if (d > 180) d -= 360;
        if (d < -180) d += 360;
        return d;
    }

    function smoothAngleDeg(currentDeg, targetDeg, alpha = 0.18) {
        if (!Number.isFinite(Number(currentDeg))) return normalizeDeg(targetDeg);
        const delta = shortestAngleDeltaDeg(currentDeg, targetDeg);
        return normalizeDeg(Number(currentDeg) + delta * Math.max(0.02, Math.min(1, Number(alpha) || 0.18)));
    }

    function blendCircularDeg(aDeg, aWeight, bDeg, bWeight) {
        const aw = Math.max(0, Number(aWeight) || 0);
        const bw = Math.max(0, Number(bWeight) || 0);
        if (aw <= 0 && bw <= 0) return null;
        const a = normalizeDeg(aDeg) * Math.PI / 180;
        const b = normalizeDeg(bDeg) * Math.PI / 180;
        const x = Math.cos(a) * aw + Math.cos(b) * bw;
        const y = Math.sin(a) * aw + Math.sin(b) * bw;
        if (Math.abs(x) < 1e-6 && Math.abs(y) < 1e-6) return null;
        return normalizeDeg(Math.atan2(y, x) * 180 / Math.PI);
    }

    function destinationPointByBearing(lat, lon, bearingDeg, distanceMeters) {
        const R = 6371000;
        const br = normalizeDeg(bearingDeg) * Math.PI / 180;
        const d = Math.max(0, Number(distanceMeters) || 0);
        const phi1 = Number(lat) * Math.PI / 180;
        const lam1 = Number(lon) * Math.PI / 180;
        const sinPhi1 = Math.sin(phi1);
        const cosPhi1 = Math.cos(phi1);
        const sinD = Math.sin(d / R);
        const cosD = Math.cos(d / R);
        const sinPhi2 = sinPhi1 * cosD + cosPhi1 * sinD * Math.cos(br);
        const phi2 = Math.asin(Math.max(-1, Math.min(1, sinPhi2)));
        const y = Math.sin(br) * sinD * cosPhi1;
        const x = cosD - sinPhi1 * Math.sin(phi2);
        const lam2 = lam1 + Math.atan2(y, x);
        return [phi2 * 180 / Math.PI, ((lam2 * 180 / Math.PI + 540) % 360) - 180];
    }

    function extractCompassHeadingDeg(e) {
        if (!e) return null;
        if (Number.isFinite(Number(e.webkitCompassHeading))) {
            return normalizeDeg(Number(e.webkitCompassHeading));
        }
        if (Number.isFinite(Number(e.alpha))) {
            return normalizeDeg(360 - Number(e.alpha));
        }
        return null;
    }

    function onDynamicCourseOrientation(e) {
        const compass = extractCompassHeadingDeg(e);
        if (compass === null) return;
        const now = Date.now();
        dynamicCourseLastCompassTs = now;

        const speed = Number(userSpeedKmh) || 0;
        const alpha = speed > 80 ? 0.10 : 0.20;
        dynamicCourseCompassDeg = (dynamicCourseCompassDeg === null)
            ? compass
            : smoothAngleDeg(dynamicCourseCompassDeg, compass, alpha);
    }

    async function requestDynamicCourseOrientationPermission() {
        try {
            const D = window.DeviceOrientationEvent;
            if (!D || typeof D.requestPermission !== 'function') return true;
            const state = await D.requestPermission();
            return state === 'granted';
        } catch (e) {
            return false;
        }
    }

    function getDynamicCourseHeadingDeg() {
        const speed = Number(userSpeedKmh) || 0;
        const gpsDeg = Number.isFinite(Number(dynamicCourseGpsDeg)) ? normalizeDeg(dynamicCourseGpsDeg) : null;
        const compassFresh = (Date.now() - Number(dynamicCourseLastCompassTs || 0)) < 6000;
        const compassDeg = (compassFresh && Number.isFinite(Number(dynamicCourseCompassDeg))) ? normalizeDeg(dynamicCourseCompassDeg) : null;

        if (gpsDeg === null && compassDeg === null) return null;
        if (gpsDeg !== null && compassDeg === null) return gpsDeg;
        if (gpsDeg === null && compassDeg !== null) return compassDeg;

        let gpsWeight = Math.max(0.1, Math.min(0.95, (speed - 10) / 90));
        if (speed >= 140) gpsWeight = 0.97;
        const compassWeight = Math.max(0.05, 1 - gpsWeight);
        return blendCircularDeg(compassDeg, compassWeight, gpsDeg, gpsWeight);
    }

    function getDynamicFollowZoomBySpeed(speedKmh) {
        const s = Number(speedKmh) || 0;
        if (s > 80) return 14;
        if (s < 20) return 17;
        return 16;
    }

    function attachYandexCameraCompat(map) {
        if (!map || typeof map !== 'object') return;

        if (typeof map.setBehaviors !== 'function') {
            map.setBehaviors = function(behaviors) {
                try {
                    if (map.behaviors && typeof map.behaviors.enable === 'function') {
                        map.behaviors.enable(Array.isArray(behaviors) ? behaviors : []);
                    }
                } catch (e) {}
            };
        }

        if (typeof map.setCamera !== 'function') {
            map.setCamera = function(camera = {}) {
                const center = Array.isArray(camera.center) && camera.center.length >= 2
                    ? [Number(camera.center[0]), Number(camera.center[1])]
                    : null;
                const zoom = Number.isFinite(Number(camera.zoom)) ? Number(camera.zoom) : (map.getZoom ? map.getZoom() : 16);
                const duration = Number.isFinite(Number(camera.duration)) ? Number(camera.duration) : 500;

                try {
                    if (map.options && typeof map.options.set === 'function') {
                        if (Number.isFinite(Number(camera.azimuth))) map.options.set('azimuth', normalizeDeg(camera.azimuth));
                        if (Number.isFinite(Number(camera.tilt))) map.options.set('tilt', Number(camera.tilt));
                    }
                } catch (e) {}

                if (center && map.setCenter) {
                    try {
                        map.setCenter(center, zoom, { duration, timingFunction: 'ease-out' });
                        return;
                    } catch (e) {
                        try { map.setCenter(center, zoom); return; } catch (e2) {}
                    }
                }
            };
        }
    }

    function loadMapEnginePreference() {
        try {
            const qs = new URLSearchParams(window.location.search || '');
            const forceLegacyByQuery = qs.get('map2') === '1' || qs.get('engine') === 'ymaps2';
            const forceYm3ByQuery = qs.get('map3') === '1' || qs.get('engine') === 'ymaps3';
            const forceLegacyByStorage = localStorage.getItem(MAP_ENGINE_LEGACY_FORCE_KEY) === 'true';
            const ym3FailedBefore = localStorage.getItem(MAP_ENGINE_YM3_FAIL_KEY) === '1';

            if (forceYm3ByQuery) {
                preferredMapEngine = 'ymaps3';
                return;
            }

            if (forceLegacyByQuery || forceLegacyByStorage || ym3FailedBefore) {
                preferredMapEngine = 'ymaps2';
                return;
            }

            const raw = String(localStorage.getItem(MAP_ENGINE_STORAGE_KEY) || '').trim().toLowerCase();
            preferredMapEngine = (raw === 'ymaps3') ? 'ymaps3' : 'ymaps2';
        } catch (e) {
            preferredMapEngine = 'ymaps2';
        }
        updateMapEngineBadge();
    }

    function loadMap3dPreference() {
        try {
            map3dEnabled = localStorage.getItem(MAP_3D_MODE_KEY) === '1';
        } catch (e) {
            map3dEnabled = false;
        }
    }

    function saveMap3dPreference() {
        try { localStorage.setItem(MAP_3D_MODE_KEY, map3dEnabled ? '1' : '0'); } catch (e) {}
    }

    function updateMap3dToggleUi() {
        const isYm3Active = String(activeMapEngine || preferredMapEngine || '').includes('ymaps3');
        const effectiveOn = !!(map3dEnabled && isYm3Active);

        const floatingBtn = document.getElementById('map3dToggleFloating');
        if (floatingBtn) {
            floatingBtn.classList.toggle('is-on', effectiveOn);
            floatingBtn.textContent = effectiveOn ? '3D ON' : '3D OFF';
            floatingBtn.title = isYm3Active ? (effectiveOn ? 'Отключить 3D режим карты' : 'Включить 3D режим карты') : '3D доступно только в ymaps3';
        }

        const settingsBtn = document.getElementById('map3dSettingsBtn');
        if (settingsBtn) {
            settingsBtn.classList.toggle('active', effectiveOn);
            settingsBtn.textContent = `3D: ${effectiveOn ? 'ВКЛ' : 'ВЫКЛ'}`;
        }

        const hint = document.getElementById('map3dSettingsHint');
        if (hint) {
            hint.textContent = isYm3Active
                ? `Режим карты: ${effectiveOn ? '3D (наклон + здания)' : '2D (плоский режим)'}`
                : '3D доступно только в ymaps3';
        }
    }

    function ensureYm3BuildingsLayer(enabled) {
        try {
            const root = myMap?.__ym3Root;
            if (!root) return false;
            const YMapLayerCtor = myMap?.__ym3Core?.YMapLayer || ymaps3?.YMapLayer;
            if (!YMapLayerCtor) return false;

            if (enabled) {
                if (!myMap.__ym3BuildingsLayer) {
                    myMap.__ym3BuildingsLayer = new YMapLayerCtor({ source: 'scheme', type: 'buildings', zIndex: 1800 });
                    root.addChild(myMap.__ym3BuildingsLayer);
                }
            } else if (myMap.__ym3BuildingsLayer) {
                try { root.removeChild(myMap.__ym3BuildingsLayer); } catch (e) {}
                myMap.__ym3BuildingsLayer = null;
            }
            return true;
        } catch (e) {
            return false;
        }
    }

    function applyMap3dMode(options = {}) {
        const animate = options?.animate !== false;
        const root = myMap?.__ym3Root;
        const isYm3Active = String(activeMapEngine || '').includes('ymaps3') && !!root;
        if (!isYm3Active) {
            updateMap3dToggleUi();
            return false;
        }

        const center = Array.isArray(myMap.__ym3LastCenter) ? myMap.__ym3LastCenter : (typeof myMap.getCenter === 'function' ? myMap.getCenter() : [48.01, 37.8]);
        const currentZoom = Number.isFinite(Number(myMap.__ym3LastZoom)) ? Number(myMap.__ym3LastZoom) : (typeof myMap.getZoom === 'function' ? Number(myMap.getZoom() || 16) : 16);
        const zoom = map3dEnabled ? Math.max(MAP_3D_MIN_ZOOM, currentZoom) : currentZoom;
        const lat = Number(center?.[0]);
        const lon = Number(center?.[1]);
        if (!Number.isFinite(lat) || !Number.isFinite(lon)) return false;

        const tilt = map3dEnabled ? Math.PI / 3 : 0;
        const azimuth = Number.isFinite(Number(myMap.__ym3LastAzimuth)) ? Number(myMap.__ym3LastAzimuth) : 0;
        ensureYm3BuildingsLayer(map3dEnabled);

        const location = {
            center: [lon, lat],
            zoom,
            azimuth,
            tilt,
            duration: animate ? 650 : 0
        };

        try {
            if (typeof root.setLocation === 'function') root.setLocation(location);
            else root.update({ location });
            myMap.__ym3LastTilt = tilt;
            myMap.__ym3LastAzimuth = azimuth;
            myMap.__ym3LastZoom = zoom;
        } catch (e) {}

        updateMap3dToggleUi();
        return true;
    }

    function toggleMap3dFromUI() {
        map3dEnabled = !map3dEnabled;
        saveMap3dPreference();
        const applied = applyMap3dMode({ animate: true });
        if (!applied) {
            updateMap3dToggleUi();
            showInAppNotification({ title: '3D режим', body: '3D доступен только при активном ymaps3.', priority: 'low' });
        }
    }

    window.toggleMap3dFromUI = toggleMap3dFromUI;

    function updateMapEngineBadge() {
        try {
            const badge = document.getElementById('mapEngineBadge');
            if (!badge) return;

            const engine = String(activeMapEngine || preferredMapEngine || '').toLowerCase();
            const isV3 = engine.includes('ymaps3');
            badge.classList.toggle('is-v3', isV3);
            badge.classList.toggle('is-v2', !isV3);
            badge.textContent = isV3 ? '🗺️ ymaps3' : '🗺️ ymaps2 legacy';
        } catch (e) {}
    }

    function saveMapEnginePreference() {
        try { localStorage.setItem(MAP_ENGINE_STORAGE_KEY, preferredMapEngine); } catch (e) {}
    }

    function setMapEnginePreference(engine) {
        preferredMapEngine = (String(engine || '').toLowerCase() === 'ymaps3') ? 'ymaps3' : 'ymaps2';
        if (preferredMapEngine === 'ymaps2') activeMapEngine = 'ymaps2';
        try {
            localStorage.setItem(MAP_ENGINE_LEGACY_FORCE_KEY, preferredMapEngine === 'ymaps2' ? 'true' : 'false');
        } catch (e) {}
        saveMapEnginePreference();
        updateMapEngineBadge();
        updateMap3dToggleUi();
        try {
            showInAppNotification({
                title: '🗺 Движок карты',
                body: preferredMapEngine === 'ymaps3' ? 'Режим ymaps3 сохранён. Перезапустите страницу.' : 'Режим ymaps2 (legacy) сохранён. Перезапустите страницу.',
                priority: 'low'
            });
        } catch (e) {}
        return preferredMapEngine;
    }

    window.setMapEnginePreference = setMapEnginePreference;

    function ensureLegacyMapHost() {
        let host = document.getElementById('mapLegacyHost');
        if (host) return host;
        host = document.createElement('div');
        host.id = 'mapLegacyHost';
        host.style.cssText = 'position:fixed;left:-99999px;top:-99999px;width:1px;height:1px;opacity:0;pointer-events:none;';
        document.body.appendChild(host);
        return host;
    }

    async function initPrimaryMapInstance() {
        loadMapEnginePreference();
        loadMap3dPreference();
        activeMapEngine = 'ymaps2';

        if (preferredMapEngine === 'ymaps3') {
            try {
                if (window.ymaps3 && ymaps3.ready) {
                    await ymaps3.ready;
                    activeMapEngine = 'ymaps3-compat';
                }
            } catch (e) {
                activeMapEngine = 'ymaps2';
            }
        }

        const visualMapHost = document.getElementById('map');
        const mapInitTarget = (activeMapEngine === 'ymaps3-compat') ? ensureLegacyMapHost() : "map";
        myMap = new ymaps.Map(mapInitTarget, { center: [48.01, 37.80], zoom: 16, controls: [] });
        attachYandexCameraCompat(myMap);
        applyDynamicCourseBehaviors();

        if (activeMapEngine === 'ymaps3-compat') {
            try {
                let ym3Core = null;
                let ym3Markers = null;
                let ym3DefaultUi = null;
                try { ym3Core = await ymaps3.import('@yandex/ymaps3'); } catch (e) { ym3Core = null; }
                try { ym3Markers = await ymaps3.import('@yandex/ymaps3-markers@0.0.1'); } catch (e) {
                    try { ym3Markers = await ymaps3.import('@yandex/ymaps3-markers'); } catch (e2) { ym3Markers = null; }
                }
                try { ym3DefaultUi = await ymaps3.import('@yandex/ymaps3-default-ui-theme@0.0.1'); } catch (e) {
                    try { ym3DefaultUi = await ymaps3.import('@yandex/ymaps3-default-ui-theme'); } catch (e2) { ym3DefaultUi = null; }
                }

                const YMapCtor = ym3Core?.YMap || ymaps3?.YMap;
                const SchemeCtor = ym3Core?.YMapDefaultSchemeLayer || ymaps3?.YMapDefaultSchemeLayer;
                const FeaturesCtor = ym3Core?.YMapDefaultFeaturesLayer || ymaps3?.YMapDefaultFeaturesLayer;
                const MarkerCtor = ym3Markers?.YMapMarker || ymaps3?.YMapMarker;
                if (YMapCtor && SchemeCtor && FeaturesCtor && MarkerCtor) {
                    const root = new YMapCtor(visualMapHost, {
                        location: { center: [37.80, 48.01], zoom: map3dEnabled ? Math.max(16, MAP_3D_MIN_ZOOM) : 16, azimuth: 0, tilt: map3dEnabled ? Math.PI / 3 : 0 }
                    });
                    const scheme = new SchemeCtor({});
                    root.addChild(scheme);
                    const features = new ymaps3.YMapDefaultFeaturesLayer({});
                    root.addChild(features);
                    try {
                        const ZoomControlCtor = ym3DefaultUi?.YMapZoomControl;
                        if (ZoomControlCtor) root.addChild(new ZoomControlCtor({}));
                    } catch (e) {}
                    myMap.__ym3Root = root;
                    myMap.__ym3Core = ym3Core || ymaps3;
                    myMap.__ym3MarkerLayer = features;
                    myMap.__ym3BuildingsLayer = null;
                    myMap.__ym3LastCenter = [48.01, 37.80];
                    myMap.__ym3LastZoom = 16;
                    myMap.__ym3LastTilt = map3dEnabled ? Math.PI / 3 : 0;
                    myMap.__ym3LastAzimuth = 0;

                    const approximateBoundsFromCenterZoom = (center, zoom) => {
                        const lat = Number(center?.[0]);
                        const lon = Number(center?.[1]);
                        const z = Number(zoom);
                        if (!Number.isFinite(lat) || !Number.isFinite(lon) || !Number.isFinite(z)) return null;
                        const lonSpan = Math.max(0.01, 360 / Math.pow(2, z + 1));
                        const latSpan = Math.max(0.01, 180 / Math.pow(2, z + 1));
                        return [
                            [lat - latSpan, lon - lonSpan],
                            [lat + latSpan, lon + lonSpan]
                        ];
                    };
                    myMap.__ym3LastBounds = approximateBoundsFromCenterZoom(myMap.__ym3LastCenter, myMap.__ym3LastZoom);

                    const originalSetCenter = (typeof myMap.setCenter === 'function') ? myMap.setCenter.bind(myMap) : null;
                    const originalGetCenter = (typeof myMap.getCenter === 'function') ? myMap.getCenter.bind(myMap) : null;
                    const originalGetZoom = (typeof myMap.getZoom === 'function') ? myMap.getZoom.bind(myMap) : null;
                    const originalGetBounds = (typeof myMap.getBounds === 'function') ? myMap.getBounds.bind(myMap) : null;

                    myMap.setCenter = (center, zoom, options = {}) => {
                        try { if (originalSetCenter) originalSetCenter(center, zoom, options); } catch (e) {}
                        const lat = Number(center?.[0]);
                        const lon = Number(center?.[1]);
                        const nextZoom = Number.isFinite(Number(zoom)) ? Number(zoom) : Number(myMap.__ym3LastZoom || 16);
                        if (!Number.isFinite(lat) || !Number.isFinite(lon)) return myMap;
                        myMap.__ym3LastCenter = [lat, lon];
                        myMap.__ym3LastZoom = nextZoom;
                        myMap.__ym3LastAzimuth = Number.isFinite(Number(options?.azimuth)) ? Number(options.azimuth) : Number(myMap.__ym3LastAzimuth || 0);
                        myMap.__ym3LastBounds = approximateBoundsFromCenterZoom(myMap.__ym3LastCenter, myMap.__ym3LastZoom);
                        try {
                            root.update({
                                location: {
                                    center: [lon, lat],
                                    zoom: nextZoom,
                                    azimuth: Number(options?.azimuth || 0),
                                    tilt: Number.isFinite(Number(options?.tilt)) ? Number(options.tilt) : (map3dEnabled ? Math.PI / 3 : 0)
                                }
                            });
                        } catch (e) {}
                        return myMap;
                    };

                    myMap.getCenter = () => {
                        if (Array.isArray(myMap.__ym3LastCenter) && myMap.__ym3LastCenter.length >= 2) return myMap.__ym3LastCenter;
                        try { if (originalGetCenter) return originalGetCenter(); } catch (e) {}
                        return [48.01, 37.80];
                    };
                    myMap.getZoom = () => {
                        if (Number.isFinite(Number(myMap.__ym3LastZoom))) return Number(myMap.__ym3LastZoom);
                        try { if (originalGetZoom) return Number(originalGetZoom()); } catch (e) {}
                        return 16;
                    };
                    myMap.getBounds = () => {
                        if (Array.isArray(myMap.__ym3LastBounds) && myMap.__ym3LastBounds.length >= 2) return myMap.__ym3LastBounds;
                        try { if (originalGetBounds) return originalGetBounds(); } catch (e) {}
                        return approximateBoundsFromCenterZoom(myMap.getCenter(), myMap.getZoom());
                    };
                } else {
                    activeMapEngine = 'ymaps2';
                }
            } catch (e) {
                console.warn('ymaps3 marker layer init skipped:', e?.message || e);
                activeMapEngine = 'ymaps2';
            }
            if (activeMapEngine === 'ymaps3-compat' && (!myMap.__ym3Root || !myMap.__ym3MarkerLayer)) {
                activeMapEngine = 'ymaps2';
            }
        }

        markersCollection = new ymaps.GeoObjectCollection();
        myMap.geoObjects.add(markersCollection);
        mapAdapter = createMapAdapter(activeMapEngine, myMap, markersCollection);
        updateMapEngineBadge();
        updateMap3dToggleUi();
        if (activeMapEngine === 'ymaps3-compat') {
            try { applyMap3dMode({ animate: false }); } catch (e) {}
        }

        if (activeMapEngine === 'ymaps3-compat') {
            console.info('🧭 ymaps3 active: running staged adapter mode with legacy-safe fallback.');
        }
    }

    function createMapAdapter(engine, map, markerCollection) {
        let runtimeMode = String(engine || 'ymaps2');
        const ym3Markers = [];
        const ym3ActionEndHandlers = [];
        const ym3ActionStartHandlers = [];
        const ym3ClickHandlers = [];
        let ym3ListenerEntity = null;
        let ym3MapInAction = false;

        function forceLegacyFromYm3(reason = '') {
            if (runtimeMode !== 'ymaps3-compat') return;
            runtimeMode = 'ymaps2';
            activeMapEngine = 'ymaps2';
            try {
                localStorage.setItem(MAP_ENGINE_LEGACY_FORCE_KEY, 'true');
                localStorage.setItem(MAP_ENGINE_YM3_FAIL_KEY, '1');
            } catch (e) {}
            try {
                const root = map?.__ym3Root;
                if (root && typeof root.destroy === 'function') root.destroy();
            } catch (e) {}
            try {
                map.__ym3Root = null;
                map.__ym3MarkerLayer = null;
            } catch (e) {}
            updateMapEngineBadge();
            console.warn('ymaps3 отключён, fallback на ymaps2:', reason || 'marker render failure');
        }

        function approximateBoundsFromCenterZoom(center, zoom) {
            const lat = Number(center?.[0]);
            const lon = Number(center?.[1]);
            const z = Number(zoom);
            if (!Number.isFinite(lat) || !Number.isFinite(lon) || !Number.isFinite(z)) return null;

            const lonSpan = Math.max(0.01, 360 / Math.pow(2, z + 1));
            const latSpan = Math.max(0.01, 180 / Math.pow(2, z + 1));
            return [
                [lat - latSpan, lon - lonSpan],
                [lat + latSpan, lon + lonSpan]
            ];
        }

        function ensureYmaps3Popup() {
            let popup = document.getElementById('ym3MarkerPopup');
            if (popup) return popup;
            popup = document.createElement('div');
            popup.id = 'ym3MarkerPopup';
            popup.style.cssText = 'position:fixed;left:12px;top:12px;z-index:4100;display:none;background:rgba(20,20,24,0.96);color:#fff;border-radius:14px;border:1px solid rgba(255,255,255,0.18);box-shadow:0 12px 26px rgba(0,0,0,0.35);max-height:46vh;overflow:auto;width:min(360px,calc(100vw - 24px));';
            popup.innerHTML = '<div style="display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-bottom:1px solid rgba(255,255,255,0.12);"><strong style="font-size:13px;">Метка</strong><button id="ym3MarkerPopupClose" style="background:none;border:none;color:#fff;font-size:22px;line-height:1;cursor:pointer;">×</button></div><div id="ym3MarkerPopupBody" style="padding:10px 12px;"></div>';
            document.body.appendChild(popup);
            const closeBtn = document.getElementById('ym3MarkerPopupClose');
            if (closeBtn) closeBtn.addEventListener('click', () => { popup.style.display = 'none'; });
            return popup;
        }

        function showYmaps3Popup(html, anchorRect = null) {
            try {
                const popup = ensureYmaps3Popup();
                const body = document.getElementById('ym3MarkerPopupBody');
                if (body) body.innerHTML = String(html || '');

                popup.style.visibility = 'hidden';
                popup.style.display = 'block';

                const viewportW = Math.max(320, window.innerWidth || 0);
                const viewportH = Math.max(320, window.innerHeight || 0);
                const popupW = Math.min(360, Math.max(220, viewportW - 24));
                popup.style.width = `${popupW}px`;

                const popupH = Math.min(popup.offsetHeight || 260, Math.floor(viewportH * 0.46));
                let left = 12;
                let top = Math.max(12, viewportH - popupH - 100);

                if (anchorRect && Number.isFinite(Number(anchorRect.left)) && Number.isFinite(Number(anchorRect.top))) {
                    const anchorCenterX = Number(anchorRect.left) + Number(anchorRect.width || 0) / 2;
                    const preferLeft = Math.round(anchorCenterX - popupW / 2);
                    left = Math.max(8, Math.min(preferLeft, viewportW - popupW - 8));

                    const above = Math.round(Number(anchorRect.top) - popupH - 14);
                    const below = Math.round(Number(anchorRect.bottom) + 14);
                    if (above >= 8) top = above;
                    else if (below + popupH <= viewportH - 8) top = below;
                }

                popup.style.left = `${left}px`;
                popup.style.top = `${top}px`;
                popup.style.visibility = 'visible';
            } catch (e) {}
        }

        function ensureYmaps3Listener() {
            if (runtimeMode !== 'ymaps3-compat') return;
            if (!map?.__ym3Root || !window.ymaps3 || ym3ListenerEntity) return;
            try {
                const YMapListenerCtor = ymaps3?.YMapListener;
                if (!YMapListenerCtor) return;
                ym3ListenerEntity = new YMapListenerCtor({
                    onClick: () => {
                        ym3ClickHandlers.forEach(fn => { try { fn(); } catch (e) {} });
                    },
                    onUpdate: (obj) => {
                        const loc = obj?.location || obj?.camera || {};
                        const isAction = !!(obj?.mapInAction || obj?.isInteracting || obj?.inAction || false);
                        if (isAction && !ym3MapInAction) {
                            ym3MapInAction = true;
                            ym3ActionStartHandlers.forEach(fn => { try { fn(); } catch (e) {} });
                        }
                        if (!isAction && ym3MapInAction) {
                            ym3MapInAction = false;
                            ym3ActionEndHandlers.forEach(fn => { try { fn(); } catch (e) {} });
                        }
                        if (loc && Array.isArray(loc.center) && map && typeof map.setCenter === 'function') {
                            try {
                                const lon = Number(loc.center[0]);
                                const lat = Number(loc.center[1]);
                                const zoom = Number(loc.zoom);
                                if (Number.isFinite(lat) && Number.isFinite(lon)) {
                                    map.__ym3LastCenter = [lat, lon];
                                    if (Number.isFinite(zoom)) map.__ym3LastZoom = zoom;
                                    if (Number.isFinite(Number(loc?.azimuth))) map.__ym3LastAzimuth = Number(loc.azimuth);
                                    if (Number.isFinite(Number(loc?.tilt))) map.__ym3LastTilt = Number(loc.tilt);
                                    map.__ym3LastBounds = approximateBoundsFromCenterZoom([lat, lon], map.__ym3LastZoom || 16);
                                }
                            } catch (e) {}
                        }
                    }
                });
                map.__ym3Root.addChild(ym3ListenerEntity);
            } catch (e) {}
        }

        function addYmaps3MarkerFromDescriptor(descriptor) {
            try {
                if (!descriptor || !window.ymaps3 || !map || !map.__ym3Root) {
                    forceLegacyFromYm3('no ymaps3 root');
                    return false;
                }
                const coords = Array.isArray(descriptor.coords) ? descriptor.coords : null;
                if (!coords || coords.length < 2) return false;
                const lon = Number(coords[0]);
                const lat = Number(coords[1]);
                if (!Number.isFinite(lat) || !Number.isFinite(lon)) return false;

                const isAdminRole = String(descriptor.author_role || descriptor.authorRole || '').toLowerCase() === 'admin';
                const safeAuthorName = String(descriptor.author_name || descriptor.authorName || 'ADMIN')
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;');
                const iconText = String(descriptor.icon || '📍');
                const safeIconText = iconText
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;');
                const iconImgSrc = 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 64 64"><text x="50%" y="52%" dominant-baseline="middle" text-anchor="middle" font-size="44">${safeIconText}</text></svg>`);

                const markerEl = document.createElement('div');
                if (isAdminRole) {
                    markerEl.style.cssText = 'position:relative;transform:translate(-50%,-100%);cursor:pointer;user-select:none;pointer-events:auto;';
                    markerEl.innerHTML = `<div class="ym3-admin-marker-shell"><div class="ym3-admin-marker-crown">👑</div><div class="ym3-admin-marker-center"><div class="ym3-admin-marker-pulse-bg"></div><img src="${iconImgSrc}" alt="event" class="ym3-admin-marker-icon" /></div><div class="ym3-admin-marker-name">${safeAuthorName}</div></div>`;
                } else {
                    markerEl.style.cssText = 'width:30px;height:30px;border-radius:50%;background:#fff;border:2px solid #0a84ff;display:flex;align-items:center;justify-content:center;font-size:16px;box-shadow:0 2px 10px rgba(0,0,0,0.28);cursor:pointer;';
                    markerEl.innerHTML = `${String(descriptor.icon || '📍')}`;
                }
                if (descriptor.hint) markerEl.title = String(descriptor.hint);
                if (isAdminRole) {
                    markerEl.addEventListener('click', (event) => {
                        try { event?.preventDefault?.(); event?.stopPropagation?.(); } catch (e) {}
                        try {
                            if (typeof window.openBottomWidget === 'function') {
                                window.openBottomWidget(descriptor.markerData || descriptor);
                                return;
                            }
                            const rect = markerEl.getBoundingClientRect ? markerEl.getBoundingClientRect() : null;
                            showYmaps3Popup(String(descriptor.balloonHtml || ''), rect);
                            console.warn('openBottomWidget недоступна, использован fallback popup для админ-метки');
                        } catch (e) {}
                    });
                } else if (descriptor.balloonHtml) {
                    markerEl.addEventListener('click', () => {
                        try {
                            const rect = markerEl.getBoundingClientRect ? markerEl.getBoundingClientRect() : null;
                            showYmaps3Popup(String(descriptor.balloonHtml), rect);
                        } catch (e) {}
                    });
                }

                const YMapMarkerCtor = ymaps3?.YMapMarker;
                if (!YMapMarkerCtor) {
                    forceLegacyFromYm3('YMapMarker unavailable');
                    return false;
                }
                const marker = new YMapMarkerCtor({ coordinates: [lon, lat] }, markerEl);
                const parent = map.__ym3MarkerLayer || map.__ym3Root;
                parent.addChild(marker);
                ym3Markers.push({ marker, parent });
                return true;
            } catch (e) {
                forceLegacyFromYm3(e?.message || 'ymaps3 marker error');
                return false;
            }
        }

        const adapter = {
            get mode() { return runtimeMode; },
            map,
            markerCollection,
            clearMarkers() {
                try {
                    if (runtimeMode === 'ymaps3-compat') {
                        while (ym3Markers.length) {
                            const entry = ym3Markers.pop();
                            try { entry?.parent?.removeChild(entry?.marker); } catch (e) {}
                        }
                        return;
                    }
                    if (this.markerCollection && typeof this.markerCollection.removeAll === 'function') this.markerCollection.removeAll();
                } catch (e) {}
            },
            addMarker(marker, descriptor = null) {
                try {
                    if (runtimeMode === 'ymaps3-compat' && addYmaps3MarkerFromDescriptor(descriptor)) return;
                    if (this.markerCollection && typeof this.markerCollection.add === 'function') this.markerCollection.add(marker);
                } catch (e) {}
            },
            getCenter() {
                try {
                    if (runtimeMode === 'ymaps3-compat') {
                        if (Array.isArray(this.map?.__ym3LastCenter) && this.map.__ym3LastCenter.length >= 2) return this.map.__ym3LastCenter;
                    }
                    if (this.map && typeof this.map.getCenter === 'function') return this.map.getCenter();
                } catch (e) {}
                return null;
            },
            getZoom() {
                try {
                    if (runtimeMode === 'ymaps3-compat' && Number.isFinite(Number(this.map?.__ym3LastZoom))) return Number(this.map.__ym3LastZoom);
                    if (this.map && typeof this.map.getZoom === 'function') return Number(this.map.getZoom());
                } catch (e) {}
                return null;
            },
            getBounds() {
                try {
                    if (runtimeMode === 'ymaps3-compat') {
                        if (Array.isArray(this.map?.__ym3LastBounds) && this.map.__ym3LastBounds.length >= 2) return this.map.__ym3LastBounds;
                        const c = this.getCenter();
                        const z = this.getZoom();
                        return approximateBoundsFromCenterZoom(c, Number.isFinite(Number(z)) ? z : 16);
                    }
                    if (this.map && typeof this.map.getBounds === 'function') return this.map.getBounds();
                } catch (e) {}
                return null;
            },
            onActionEnd(handler) {
                try {
                    if (runtimeMode === 'ymaps3-compat') {
                        ym3ActionEndHandlers.push(handler);
                        ensureYmaps3Listener();
                        return;
                    }
                    if (this.map?.events?.add) this.map.events.add('actionend', handler);
                } catch (e) {}
            },
            onActionStart(handler) {
                try {
                    if (runtimeMode === 'ymaps3-compat') {
                        ym3ActionStartHandlers.push(handler);
                        ensureYmaps3Listener();
                        return;
                    }
                    if (this.map?.events?.add) this.map.events.add('actionstart', handler);
                } catch (e) {}
            },
            onClick(handler) {
                try {
                    if (runtimeMode === 'ymaps3-compat') {
                        ym3ClickHandlers.push(handler);
                        ensureYmaps3Listener();
                        return;
                    }
                    if (this.map?.events?.add) this.map.events.add('click', handler);
                } catch (e) {}
            }
        };
        return adapter;
    }

    function bindMapCoreEvents() {
        const a = mapAdapter;
        if (!a || !a.map) return;

        a.onActionEnd(() => {
            const targetCoords = getTargetPlacementCoords();
            ymaps.geocode(targetCoords).then(res => {
                const obj = res.geoObjects.get(0);
                document.getElementById('addr-text').innerText = obj ? obj.getAddressLine() : "Местоположение";

                const coords = targetCoords;
                if (isInDonetskRegion(coords)) {
                    document.getElementById('addr-text').style.color = '#34c759';
                } else {
                    document.getElementById('addr-text').style.color = '#ff3b30';
                }
            });
            if (dtpHeatmapEnabled) scheduleDtpHeatmapRender();
            if (patrolHeatmapEnabled) schedulePatrolHeatmapRender();
            loadMarkersDebounced();
        });

        a.onActionStart(() => {
            if (autoFollow) {
                autoFollow = false;
                try { updateFollowButton(); } catch(e) {}
            }
        });

        a.onClick(() => {
            try {
                if (!actionCardVisible) toggleActionCard();
            } catch (e) {}
        });
    }

    function applyDynamicCourseBehaviors() {
        if (!myMap) return;
        attachYandexCameraCompat(myMap);
        try {
            if (typeof myMap.setBehaviors === 'function') {
                myMap.setBehaviors(['drag', 'scrollZoom', 'tilt', 'rotate']);
                return;
            }
        } catch (e) {}
        try {
            if (myMap.behaviors && typeof myMap.behaviors.enable === 'function') {
                myMap.behaviors.enable(['drag', 'scrollZoom', 'tilt', 'rotate']);
            }
        } catch (e) {}
    }

    function updateDynamicCourseCamera() {
        if (!dynamicCourseEnabled) return;
        if (!myMap || !autoFollow || !userLocation) return;

        const heading = getDynamicCourseHeadingDeg();
        if (!Number.isFinite(Number(heading))) return;

        const speed = Number(userSpeedKmh) || 0;
        const targetZoom = getDynamicFollowZoomBySpeed(speed);
        const aheadMeters = Math.max(
            DYNAMIC_COURSE_AHEAD_MIN_M,
            Math.min(DYNAMIC_COURSE_AHEAD_MAX_M, 650 + speed * 10)
        );
        const cameraTarget = destinationPointByBearing(userLocation[0], userLocation[1], heading, aheadMeters);

        const smoothedHeading = (dynamicCourseFusedDeg === null)
            ? normalizeDeg(heading)
            : smoothAngleDeg(dynamicCourseFusedDeg, heading, 0.22);
        dynamicCourseFusedDeg = smoothedHeading;
        userHeadingDeg = smoothedHeading;

        try {
            const mapAny = myMap;
            if (typeof mapAny?.setCamera === 'function') {
                mapAny.setCamera({
                    center: cameraTarget,
                    azimuth: smoothedHeading,
                    tilt: DYNAMIC_COURSE_TILT,
                    zoom: targetZoom,
                    duration: 500
                });
            } else if (mapAny?.options?.set) {
                mapAny.options.set('rotation', smoothedHeading);
                mapAny.options.set('azimuth', smoothedHeading);
                mapAny.options.set('tilt', DYNAMIC_COURSE_TILT);
            }
        } catch (e) {}

        const canMove = !Number.isFinite(dynamicCourseLastCameraDeg)
            || Math.abs(shortestAngleDeltaDeg(dynamicCourseLastCameraDeg, smoothedHeading)) >= 1.2
            || speed >= 12;
        if (!canMove) return;

        dynamicCourseLastCameraDeg = smoothedHeading;
        try {
            myMap.setCenter(cameraTarget, targetZoom, { duration: 500, timingFunction: 'ease-out' });
        } catch (e) {
            try { myMap.setCenter(cameraTarget, targetZoom); } catch (e2) {}
        }
    }

    function startDynamicCourseLoop() {
        if (dynamicCourseCameraTimerId) return;
        dynamicCourseCameraTimerId = setInterval(() => {
            try { updateDynamicCourseCamera(); } catch (e) {}
        }, DYNAMIC_COURSE_UPDATE_MS);
    }

    function initDynamicCourseSensors() {
        if (dynamicCourseCompassInit) return;
        dynamicCourseCompassInit = true;
        const orientationAllowed = isFeatureAllowedByPolicy('accelerometer') && isFeatureAllowedByPolicy('gyroscope');
        if (!orientationAllowed) {
            if (!initDynamicCourseSensors.__policyWarned) {
                initDynamicCourseSensors.__policyWarned = true;
                console.info('Компасные сенсоры недоступны по policy — курс остаётся по GPS.');
            }
            startDynamicCourseLoop();
            return;
        }
        try {
            window.addEventListener('deviceorientationabsolute', onDynamicCourseOrientation, true);
            window.addEventListener('deviceorientation', onDynamicCourseOrientation, true);
        } catch (e) {}
        startDynamicCourseLoop();
    }
    
    // Функция обновления маркера текущего местоположения на карте
    function updateUserLocationMarker() {
        if (!userLocation || !myMap) return;

        if (isAdmin && adminInvisible) {
            if (userLocationMarker) {
                try { myMap.geoObjects.remove(userLocationMarker); } catch(e) {}
                userLocationMarker = null;
            }
            return;
        }

        // Удаляем старый маркер если он есть
        if (userLocationMarker) {
            try { myMap.geoObjects.remove(userLocationMarker); } catch(e){}
        }

                const speed = Number(userSpeedKmh) || 0; // km/h
                const size = 46;
                const heading = (Number(userHeadingDeg) || 0) % 360;

                // Кастомный маркер: чёрная стрелка-треугольник + поворот по курсу
                const svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 ${size} ${size}">
    <rect width="100%" height="100%" fill="transparent"/>
    <g transform="rotate(${heading.toFixed(1)} ${size/2} ${size/2})">
        <path d="M ${size/2} ${size*0.10} L ${size*0.78} ${size*0.86} L ${size/2} ${size*0.70} L ${size*0.22} ${size*0.86} Z"
                    fill="#0b0b0b" stroke="rgba(255,255,255,0.88)" stroke-width="1.6" stroke-linejoin="round"/>
    </g>
    <circle cx="${size/2}" cy="${size/2}" r="${size*0.49}" fill="none" stroke="rgba(0,0,0,0.06)" stroke-width="1"/>
</svg>`;

        if (isAdmin) {
            const adminSize = 36;
            const adminIconHtml = `
                <div class="admin-marker admin-marker--self">
                    <span class="admin-siren admin-siren-left"></span>
                    <span class="admin-siren admin-siren-right"></span>
                    <span class="admin-marker-core">🚗</span>
                    <span class="admin-marker-badge">♛</span>
                </div>
            `;
            userLocationMarker = new ymaps.Placemark(userLocation,
                {
                    hintContent: 'Вы здесь (Админ)',
                    balloonContent: `👑 Админ на связи<br>Скорость: ${speed} км/ч`
                },
                {
                    iconLayout: 'default#imageWithContent',
                    iconContent: adminIconHtml,
                    iconImageSize: [adminSize, adminSize],
                    iconImageOffset: [-(adminSize/2), -(adminSize/2)],
                    zIndex: 1100
                }
            );
        } else {
            const svgUrl = 'data:image/svg+xml;utf8,' + encodeURIComponent(svg);

            let pulseLayout = null;
            try {
                pulseLayout = window.__userPulseLayout || (window.__userPulseLayout = ymaps.templateLayoutFactory.createClass('<div class="user-marker-wrap"><div class="user-pulse"></div></div>'));
            } catch (e) {
                pulseLayout = null;
            }

            userLocationMarker = new ymaps.Placemark(userLocation,
                {
                    hintContent: 'Вы здесь',
                    balloonContent: `📍 Ваше текущее местоположение<br>Скорость: ${speed} км/ч`
                },
                {
                    iconLayout: 'default#imageWithContent',
                    iconImageHref: svgUrl,
                    iconImageSize: [size, size],
                    iconImageOffset: [-(size/2), -(size/2)],
                    iconContentLayout: pulseLayout || undefined,
                    iconContentOffset: [-(size/2), -(size/2)],
                    iconContentSize: [size, size],
                    zIndex: 1000
                }
            );
        }

        myMap.geoObjects.add(userLocationMarker);

        // Центрируем карту на текущем местоположении (если это первый раз)
        if (!myMap.lastUserLocationUpdate) {
            try { myMap.setCenter(userLocation, 17); } catch(e){}
            myMap.lastUserLocationUpdate = true;
        }
    }
    
    // Центрирует карту на текущем местоположении и включает автоследование
    function centerOnMyLocation() {
        if (!userLocation) {
            alert('Позиция недоступна. Включите GPS.');
            return;
        }
        autoFollow = true;
        updateFollowButton();
        requestDynamicCourseOrientationPermission().catch(()=>{});
        try { monolithSetNavigationActive(autoFollow); } catch(e) {}
        try { updateDynamicCourseCamera(); } catch (e) {
            try { myMap.setCenter(userLocation, 17); } catch (e2) { console.warn(e2); }
        }
    }

    // Переключатель автослежения GPS
    function toggleFollow() {
        autoFollow = !autoFollow;
        updateFollowButton();
        try { monolithSetNavigationActive(autoFollow); } catch(e) {}
        if (autoFollow && userLocation && myMap) {
            requestDynamicCourseOrientationPermission().catch(()=>{});
            try { updateDynamicCourseCamera(); } catch(e) {
                try { myMap.setCenter(userLocation, 17); } catch(e2) { console.warn(e2); }
            }
        }
    }

    function updateFollowButton() {
        const btn = document.getElementById('followToggleBtn');
        if (!btn) {
            try { updateLocateBtnUiState(); } catch(e) {}
            return;
        }
        const modeText = proximityRequiresFollow ? 'Оповещения: только при автослежении' : 'Оповещения: всегда';
        if (autoFollow) {
            btn.classList.remove('inactive');
            btn.classList.add('active');
            btn.title = `Я на карте (автослежение ВКЛ)\n${modeText}`;
        } else {
            btn.classList.remove('active');
            btn.classList.add('inactive');
            btn.title = `Я не на карте (автослежение ВЫКЛ)\n${modeText}`;
        }
        const icon = autoFollow ? '👁️' : '🚫';
        const badge = proximityRequiresFollow ? '<span class="follow-badge">P</span>' : '';
        btn.innerHTML = `<span class="follow-icon">${icon}</span>${badge}`;
        try { monolithSetNavigationActive(autoFollow); } catch(e) {}
        try { updateLocateBtnUiState(); } catch(e) {}
    }

    function updateLocateBtnUiState() {
        const locate = document.getElementById('locateBtn');
        if (!locate) return;
        locate.classList.toggle('active', !!autoFollow);
        locate.title = autoFollow ? 'Отслеживание: ВКЛ' : 'Отслеживание: ВЫКЛ';
    }

    function updateVoiceBtnUiState() {
        const btn = document.getElementById('ccVoiceBtn');
        if (!btn) return;
        btn.classList.toggle('off', !isMonolithVoiceEnabled());
        btn.classList.toggle('active', isMonolithVoiceEnabled());
        btn.textContent = isMonolithVoiceEnabled() ? '🔊' : '🔇';
    }

    function toggleMonolithVoiceFromUI() {
        monolithVoiceEnabled = !monolithVoiceEnabled;
        saveMonolithVoiceEnabled();
        applyMonolithVoiceToggleUI();
        if (!monolithVoiceEnabled) {
            try { monolithClearTtsQueue(true); } catch (e) {}
            try { monolithStopKeepAliveAudio(); } catch (e) {}
            try { monolithReleaseWakeLock(); } catch (e) {}
        } else {
            try { monolithPrimeAudioOnce(); } catch (e) {}
            try { monolithSoftResumeSpeech(); } catch (e) {}
            try { monolithMaybeUpdateWakeLock(); } catch (e) {}
        }
        updateVoiceBtnUiState();
    }

    function updateMapEngineBtnUiState() {
        const btn = document.getElementById('ccMapEngineBtn');
        if (!btn) return;
        btn.style.display = '';
        const isV3 = String(preferredMapEngine || '').toLowerCase() === 'ymaps3';
        btn.classList.toggle('active', isV3);
        btn.classList.toggle('off', !isV3);
        btn.textContent = isV3 ? '🗺️3' : '🗺️2';
        btn.title = isV3 ? 'Тест движка: ymaps3 (нажмите для ymaps2)' : 'Тест движка: ymaps2 (нажмите для ymaps3)';
        const hint = document.getElementById('mapEngineSettingsHint');
        if (hint) hint.textContent = `Текущий режим: ${isV3 ? 'ymaps3' : 'ymaps2'}`;
        updateMap3dToggleUi();
    }

    function toggleMapEngineFromUI() {
        const next = String(preferredMapEngine || '').toLowerCase() === 'ymaps3' ? 'ymaps2' : 'ymaps3';
        try {
            if (next === 'ymaps3') {
                localStorage.removeItem(MAP_ENGINE_LEGACY_FORCE_KEY);
                localStorage.removeItem(MAP_ENGINE_YM3_FAIL_KEY);
            }
        } catch (e) {}
        setMapEnginePreference(next);
        updateMapEngineBtnUiState();
        const url = new URL(window.location.href);
        url.searchParams.delete('map2');
        url.searchParams.delete('map3');
        url.searchParams.set('engine', next);
        window.location.replace(url.toString());
    }

    function updateLayersBtnUiState() {
        const btn = document.getElementById('ccLayersBtn');
        if (!btn) return;
        const mode = dtpHeatmapEnabled ? 'dtp' : patrolHeatmapEnabled ? 'patrol' : 'off';
        btn.classList.toggle('active', mode !== 'off');
        // Подсказка режима: Засады / ДТП / Выкл
        btn.textContent = mode === 'patrol' ? '🛡️' : mode === 'dtp' ? '💥' : '🗂️';
        btn.title = mode === 'patrol' ? 'Слои: Засады (ДПС/Спецбат)' : mode === 'dtp' ? 'Слои: ДТП' : 'Слои: выкл';
    }

    function toggleMainLayers() {
        // Цикл: Засады -> ДТП -> Выкл
        const mode = dtpHeatmapEnabled ? 'dtp' : patrolHeatmapEnabled ? 'patrol' : 'off';

        if (mode === 'off') {
            // включаем Засады
            toggleDtpHeatmap(false).catch(()=>{});
            togglePatrolHeatmap(true).catch(()=>{});
        } else if (mode === 'patrol') {
            // переключаем на ДТП
            togglePatrolHeatmap(false).catch(()=>{});
            toggleDtpHeatmap(true).catch(()=>{});
        } else {
            // выключаем всё
            togglePatrolHeatmap(false).catch(()=>{});
            toggleDtpHeatmap(false).catch(()=>{});
        }

        // Обновим UI после асинхронных тумблеров
        setTimeout(() => { try { updateLayersBtnUiState(); } catch(e) {} }, 120);
    }
    
    // Функция для расчета расстояния между двумя точками (формула гаверсинусов)
    // coords1 и coords2 - массивы [широта, долгота]
    // Возвращает расстояние в метрах
    function calculateDistanceFromArrays(coords1, coords2) {
        const R = 6371000; // Радиус Земли в метрах
        const lat1 = coords1[0] * Math.PI / 180;
        const lat2 = coords2[0] * Math.PI / 180;
        const deltaLat = (coords2[0] - coords1[0]) * Math.PI / 180;
        const deltaLon = (coords2[1] - coords1[1]) * Math.PI / 180;
        
        const a = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
                  Math.cos(lat1) * Math.cos(lat2) * Math.sin(deltaLon / 2) * Math.sin(deltaLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
    }

    // Функция для воспроизведения звукового уведомления
    function playAlertSound() {
        try {
            // Используем Web Audio API для создания простого звука "бип"
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = 800; // Частота звука в Hz
            oscillator.type = 'sine';
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.3);
        } catch (e) {
            console.warn('Ошибка при воспроизведении звука:', e?.message);
        }
    }

    // Спецбат: отдельный короткий сигнал (двойной бип). Best-effort (в iOS может быть ограничен политикой autoplay)
    function playSpecbatSound() {
        try {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const gainNode = audioContext.createGain();
            gainNode.connect(audioContext.destination);
            gainNode.gain.setValueAtTime(0.0001, audioContext.currentTime);

            const now = audioContext.currentTime;
            const makeBeep = (t, freq, dur) => {
                const osc = audioContext.createOscillator();
                osc.type = 'square';
                osc.frequency.setValueAtTime(freq, t);
                osc.connect(gainNode);
                gainNode.gain.setValueAtTime(0.0001, t);
                gainNode.gain.exponentialRampToValueAtTime(0.22, t + 0.015);
                gainNode.gain.exponentialRampToValueAtTime(0.0001, t + dur);
                osc.start(t);
                osc.stop(t + dur);
            };

            makeBeep(now + 0.00, 1160, 0.085);
            makeBeep(now + 0.12, 880, 0.11);
        } catch (e) {
            // тихо игнорируем
        }
    }

    // Функция проверки, забанен ли пользователь
    async function isUserBanned(userId) {
        try {
            // Проверяем наличие пользователя в таблице bans с таймаутом 8 сек
            const { data: banned, error } = await Promise.race([
                _sb.from('bans').select('*').eq('user_id', userId).maybeSingle(),
                new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('Ban check timeout')), 8000)
                )
            ]);
            if (error && error.code !== 'PGRST116') {
                console.warn('Ошибка при проверке баня:', error?.message);
                return { isBanned: false, reason: null };
            }
            return {
                isBanned: banned ? true : false,
                reason: banned?.reason || null
            };
        } catch (e) {
            console.warn('Ошибка при проверке баня (timeout или error):', e?.message || e);
            return { isBanned: false, reason: null };
        }
    }

    // Функция инициализации приложения
    async function initApp() {
        // Предотвращаем двойной вызов
        if (initAppInProgress) return;
        initAppInProgress = true;

        // ПЕРВАЯ ПРОВЕРКА: Нужен ли код приглашения для ЗБТ?
        const hasBetaAccess = localStorage.getItem('beta_access_granted') === 'true';
        if (!hasBetaAccess) {
            // Показываем экран ввода кода
            const betaOverlay = document.getElementById('betaInviteOverlay');
            if (betaOverlay) betaOverlay.style.display = 'flex';
            // Скрываем splash screen
            const splash = document.getElementById('splashScreen');
            if (splash) splash.classList.add('hidden');
            initAppInProgress = false;
            return;
        }

        // Если бета-доступ есть - скрываем overlay
        const betaOverlay = document.getElementById('betaInviteOverlay');
        if (betaOverlay) betaOverlay.style.display = 'none';

        // Auth Variant B: Telegram Mini App или Web/PWA login
        const env = await checkAppEnvironment();
        const isTelegram = !!env?.isTelegram;
        const authedToken = env?.token;
        const overlay = document.getElementById('tgAuthOverlay');
        const tgUser = window.Telegram?.WebApp?.initDataUnsafe?.user;
        const displayUser = isTelegram ? tgUser : siteTelegramUser;

        // Если токена нет — пользователь должен войти через Telegram (модалка уже показана)
        if (!authedToken) {
            if (overlay) overlay.style.display = 'flex';
            initAppInProgress = false;
            return;
        }

        // Если токен есть — определяем админа по Telegram ID (и в Mini App, и в Web/PWA)
        isAdmin = !!uid && String(uid) === String(ADMIN_ID);

        // Если пользователь уже в ЗБТ — гарантируем ачивку "Первопроходец"
        try {
            if (localStorage.getItem('beta_access_granted') === 'true') {
                await ensureUserAchievement(uid, 'beta_tester');
            }
        } catch(e) {}

        if (authedToken) {
            try {
                // Проверяем, не забанен ли пользователь (с таймаутом)
                const banInfo = await Promise.race([
                    isUserBanned(uid),
                    new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('Ban check timeout')), 5000)
                    )
                ]).catch(() => ({ isBanned: false })); // Если ошибка, продолжаем работу
                
                if (banInfo.isBanned) {
                    let banMessage = '❌ Вы заблокированы администратором и не можете использовать приложение.';
                    if (banInfo.reason) {
                        banMessage += `\n\nПричина: ${banInfo.reason}`;
                    }
                    alert(banMessage);
                    return;
                }

                // ПРОВЕРЯЕМ ТЕХНИЧЕСКОЕ ОБСЛУЖИВАНИЕ
                const isMaintenanceActive = await checkMaintenanceStatus(isAdmin);
                if (isMaintenanceActive) {
                    initAppInProgress = false;
                    return; // Оверлей ТО заблокирует интерфейс
                }

            } catch (e) {
                console.warn('Ошибка проверки блокировки:', e?.message || e);
                // Продолжаем работу при ошибке
            }
        }

        // Проверяем, является ли пользователь администратором
        // isAdmin уже определен выше
        if (isAdmin) {
            try { document.getElementById('adminBtn')?.classList?.add('visible'); } catch(e) {}
        }

        // Показываем онлайн-бейдж (если поддерживается)
        try { document.getElementById('onlineCountBadge')?.classList?.add('visible'); } catch(e) {}

        if (authedToken) {
            // Проверяем, зарегистрирован ли пользователь (запрашиваем только базовые колонки)
            try {
                const { data: driver } = await Promise.race([
                    _sb.from('drivers').select('user_id,name,car_model,car_plate').eq('user_id', uid).maybeSingle(),
                    new Promise((_, reject) => 
                        setTimeout(() => reject(new Error('Driver check timeout')), 8000)
                    )
                ]);
                if (!driver) {
                    // Если нет, показываем форму для добавления данных об авто
                    const first = String(displayUser?.first_name || '').trim();
                    const last = String(displayUser?.last_name || '').trim();
                    document.getElementById('reg-user-name').textContent = `${first} ${last}`.trim() || 'Водитель';
                    openRegistrationModal();
                } else {
                    // Если да, загружаем его данные
                    currentDriver = driver;
                }
            } catch (e) {
                // Если запрос к таблице drivers падает из-за несинхронизированной схемы, всё равно покажем форму
                console.warn('drivers table read failed:', e.message || e);
                const first = String(displayUser?.first_name || '').trim();
                const last = String(displayUser?.last_name || '').trim();
                document.getElementById('reg-user-name').textContent = `${first} ${last}`.trim() || 'Водитель';
                openRegistrationModal();
            }
        }

        // Начинаем обновлять last_seen и загружать онлайн-статистику
        try {
            await Promise.race([
                updateLastSeen(),
                new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('LastSeen timeout')), 5000)
                )
            ]).catch(() => console.warn('updateLastSeen timeout'));
            
            // heartbeat каждую минуту
            setInterval(() => { updateLastSeen().catch(()=>{}); }, 60*1000);
            // обновление счётчика онлайн каждые 30 секунд
            await Promise.race([
                loadOnlineCount(),
                new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('OnlineCount timeout')), 5000)
                )
            ]).catch(() => console.warn('loadOnlineCount timeout'));
            
            setInterval(() => { loadOnlineCount().catch(()=>{}); }, 30*1000);
        } catch (e) {
            console.warn('Не удалось запустить heartbeat/online count:', e?.message || e);
        }

        // Загружаем сохраненный стиль озвучки
        loadVoiceStyle();
        try { initMonolithVoiceToggle(); } catch(e) {}
        loadProximityMode();
        loadMarkerRenderMode();
        loadDynamicCourseEnabled();
        loadWarningDistance();
        loadSpeedometerPreference();
        restoreTypeCategoryPreference();
        loadNotificationsState();
        seedSafeDriveNewsNotifications();
        syncImportantNotificationsFeed({ silent: true }).catch(()=>{});
        if (!notifFeedSyncIntervalId) {
            notifFeedSyncIntervalId = setInterval(() => {
                syncImportantNotificationsFeed({ silent: true }).catch(()=>{});
            }, NOTIF_FEED_SYNC_INTERVAL_MS);
        }
        updateSpeedometerUI(userSpeedKmh);
        registerServiceWorker();
        // Авто-подключаем Web Push, если разрешение уже выдано (без новых диалогов)
        try {
            if ('Notification' in window && Notification.permission === 'granted') {
                if (window.SafeDrivePwa && typeof window.SafeDrivePwa.enableWebPush === 'function') {
                    window.SafeDrivePwa.enableWebPush().catch(()=>{});
                }
            }
        } catch (e) {}
        startProximityBannerLoop();

        // Рация: держим подключение постоянно, чтобы реплики приходили без открытой модалки.
        try { pttConnectSocket(); } catch (e) {}
        try { pttAttachFabHandlers(); } catch (e) {}

        // Ergo UI: синхронизируем состояния кнопок
        try { updateFollowButton(); } catch (e) {}
        try { updateVoiceBtnUiState(); } catch (e) {}
        try { updateMapEngineBtnUiState(); } catch (e) {}
        try { updateCourseBtnUiState(); } catch (e) {}
        try { updateLayersBtnUiState(); } catch (e) {}
        try { setRightActionsHidden(!!actionCardVisible); } catch (e) {}

        // Инициализируем админ-канал и статус невидимки
        initAdminBroadcastChannel();
        await refreshAdminInvisibleStatus();
        if (!adminInvisibleIntervalId) {
            adminInvisibleIntervalId = setInterval(() => {
                refreshAdminInvisibleStatus().catch(()=>{});
            }, 30000);
        }

        // Инициализация завершена
        initAppInProgress = false;
    }

    // Функция для установки выбранного типа маркера
    // t - тип маркера, el - элемент кнопки
    function setType(t, el) {
        selectedType = t;
        // Удаляем класс active со всех кнопок
        document.querySelectorAll('.type-btn').forEach(b => b.classList.remove('active'));
        // Добавляем класс active к выбранной кнопке
        el.classList.add('active');

        // Автопереключаем вкладку по выбранному типу
        const helpTypes = new Set(['sos', 'dtp', 'danger', 'works', 'traffic_jam']);
        const targetCategory = helpTypes.has(t) ? 'help' : 'patrol';
        switchTypeCategory(targetCategory);

        try {
            const comm = document.getElementById('m-comm');
            if (comm) {
                if (t === 'sos') comm.placeholder = 'SOS: Тип | Комментарий (например: Пробил колесо | Нужен домкрат)';
                else if (t === 'dps') comm.placeholder = 'ДПС: Статус (например: Работают / Проверка документов)';
                else if (t === 'specbat') comm.placeholder = 'Спецбат: Направление | Инфо (например: В сторону центра | Усиленная проверка)';
                else comm.placeholder = 'Комментарий...';
            }
        } catch (e) {}
    }

    function switchTypeCategory(category, tabEl = null) {
        document.querySelectorAll('.type-tab-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.category === category);
        });
        document.querySelectorAll('.type-group').forEach(group => {
            group.classList.toggle('active', group.dataset.category === category);
        });

        // Если активный тип не принадлежит вкладке — выбираем первый тип в этой вкладке
        const currentActive = document.querySelector('.type-btn.active');
        const currentCategory = currentActive?.closest('.type-group')?.dataset?.category;
        if (currentCategory !== category) {
            document.querySelectorAll('.type-btn').forEach(b => b.classList.remove('active'));
            const firstBtn = document.querySelector(`.type-group[data-category="${category}"] .type-btn`);
            if (firstBtn) {
                firstBtn.classList.add('active');
                selectedType = firstBtn.dataset.type || selectedType;
            }
        }

        try { localStorage.setItem(TYPE_CATEGORY_STORAGE_KEY, category); } catch(e) {}

        if (tabEl && tabEl.dataset?.category !== category) {
            tabEl.classList.remove('active');
        }
    }

    function restoreTypeCategoryPreference() {
        let saved = 'patrol';
        try {
            const raw = localStorage.getItem(TYPE_CATEGORY_STORAGE_KEY);
            if (raw === 'help' || raw === 'patrol') saved = raw;
        } catch(e) {}
        switchTypeCategory(saved);
    }

    // ============= ФУНКЦИИ ДЛЯ ЗБТ ПРИГЛАШЕНИЙ =============

    async function verifyBetaCode() {
        const codeInput = document.getElementById('betaInviteCode');
        const status = document.getElementById('betaStatus');
        const code = (codeInput.value || '').trim().toUpperCase();

        if (!code) {
            status.textContent = '❌ Пожалуйста, введите код';
            status.style.color = '#dc3545';
            status.style.display = 'block';
            return;
        }

        status.textContent = '⏳ Проверка...';
        status.style.color = '#007aff';
        status.style.display = 'block';

        try {
            // Проверяем код через Edge Function (без прямого RPC к beta_invites)
            const validate = await fetch(`${SUPABASE_URL}/functions/v1/beta-invite`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ action: 'validate', code })
            });
            const validatePayload = await validate.json().catch(() => null);

            if (!validate.ok) {
                throw new Error(validatePayload?.error || `Ошибка проверки (${validate.status})`);
            }

            if (!validatePayload?.is_valid) {
                status.textContent = '❌ ' + (validatePayload?.message || 'Код не валиден');
                status.style.color = '#dc3545';
                status.style.display = 'block';
                codeInput.style.borderColor = '#dc3545';
                return;
            }

            // Код валиден! Применяем его
            const claim = await fetch(`${SUPABASE_URL}/functions/v1/beta-invite`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ action: 'claim', code, userId: uid ? String(uid) : '' })
            });
            const claimPayload = await claim.json().catch(() => null);
            if (!claim.ok || !claimPayload?.success) {
                throw new Error(claimPayload?.error || `Ошибка активации (${claim.status})`);
            }

            // Успешно! Сохраняем в localStorage и перезагружаем
            localStorage.setItem('beta_access_granted', 'true');
            localStorage.setItem('beta_code_used', code);
            localStorage.setItem('beta_access_date', new Date().toISOString());

            // Ачивка за вход в ЗБТ
            try { await ensureUserAchievement(uid, 'beta_tester'); } catch(e) {}

            status.textContent = '✅ Доступ предоставлен! Загрузка...';
            status.style.color = '#28a745';
            status.style.display = 'block';

            // Скрываем overlay и инициализируем приложение
            setTimeout(() => {
                document.getElementById('betaInviteOverlay').style.display = 'none';
                initAppInProgress = false;  // Сбрасываем флаг перед инициализацией
                initApp();
            }, 800);

        } catch (err) {
            console.error('Ошибка при проверке кода:', err);
            status.textContent = '❌ ' + (err?.message || 'Ошибка сервера');
            status.style.color = '#dc3545';
            status.style.display = 'block';
            codeInput.style.borderColor = '#dc3545';
        }
    }

    // Функция открытия модального окна регистрации
    function openRegistrationModal() {
        const tgUser = getTelegramDisplayUser();
        if (!tgUser) {
            const overlay = document.getElementById('tgAuthOverlay');
            if (overlay) overlay.style.display = 'flex';
            try { ensureTelegramLoginWidgetRendered(); } catch(e) {}
            return;
        }
        const target = document.querySelector('.target');
        if (target) target.style.visibility = 'hidden';
        document.getElementById('registrationModal').classList.add('active');
    }

    // Функция закрытия модального окна регистрации
    function closeRegistrationModal() {
        const target = document.querySelector('.target');
        if (target) target.style.visibility = 'visible';
        document.getElementById('registrationModal').classList.remove('active');
    }

    // Функция регистрации нового водителя (данные пользователя берутся из Telegram)
    async function registerDriver(event) {
        event.preventDefault();

        // Получаем данные Telegram (Mini App или Login Widget)
        const tgUser = getTelegramDisplayUser();
        if (!tgUser || !uid) {
            const overlay = document.getElementById('tgAuthOverlay');
            if (overlay) overlay.style.display = 'flex';
            try { ensureTelegramLoginWidgetRendered(); } catch(e) {}
            return;
        }
        const name = (tgUser?.first_name || '') + ' ' + (tgUser?.last_name || '');
        const car = document.getElementById('driver-car').value;
        const plate = document.getElementById('driver-plate').value;

        try {
            // Проверяем, существует ли уже пользователь с этим user_id
            const { data: existingDriver } = await queryWithTimeout(
                _sb.from('drivers').select('user_id').eq('user_id', uid).maybeSingle(),
                10000
            );
            
            if (existingDriver) {
                // Если водитель существует, обновляем его данные
                const { error } = await queryWithTimeout(
                    _sb.from('drivers').update({
                        name: name,
                        car_model: car,
                        car_plate: plate
                    }).eq('user_id', uid),
                    10000
                );

                if (!error) {
                    currentDriver = {
                        user_id: uid,
                        name: name,
                        car_model: car,
                        car_plate: plate,
                        votes_up: 0,
                        votes_down: 0,
                        markers_count: 0
                    };
                    closeRegistrationModal();
                    alert('✅ Профиль обновлен, ' + name + '!');
                } else {
                    alert('❌ Ошибка обновления: ' + (error?.message || 'попытайте еще раз'));
                }
            } else {
                // Если водителя нет, вставляем его
                const { error } = await queryWithTimeout(
                    _sb.from('drivers').insert([{
                        user_id: uid,
                        name: name,
                        car_model: car,
                        car_plate: plate
                    }]),
                    10000
                );

                if (!error) {
                    currentDriver = {
                        user_id: uid,
                        name: name,
                        car_model: car,
                        car_plate: plate,
                        votes_up: 0,
                        votes_down: 0,
                        markers_count: 0
                    };
                    closeRegistrationModal();
                    alert('✅ Спасибо за регистрацию, ' + name + '!');
                } else {
                    alert('❌ Ошибка регистрации: ' + (error?.message || 'попытайте еще раз'));
                }
            }
        } catch (e) {
            // Обработка AbortError и timeout
            if (e?.name === 'AbortError' || e?.message?.includes('AbortError')) {
                alert('❌ Ошибка состояния сети\n\nУбедитесь, что:\n- Включена мобильная связь или Wi-Fi\n- Есть подключение к интернету\n\nПопробуйте еще раз.');
            } else if (e?.message?.includes('Timeout')) {
                alert('❌ Сервер не отвечает\n\nСервер работает слишком долго. Попробуйте еще раз через минуту.');
            } else {
                alert('❌ Ошибка регистрации:\n\n' + (e?.message || String(e)));
            }
            console.error('Ошибка регистрации:', e);
        }
    }

    // Функция открытия профиля
    async function openProfileModal(viewUserId = null) {
        // Если передан ID другого пользователя, смотрим его профиль
        if (viewUserId && String(viewUserId) !== String(uid)) {
            return openOtherUserProfile(viewUserId);
        }

        isViewingOwnProfile = true;

        const voiceStandardBtn = document.getElementById('voiceStyleStandard');
        const voiceCheekyBtn = document.getElementById('voiceStyleCheeky');
        const warningDistanceRange = document.getElementById('warningDistanceRange');
        const proximityAlwaysBtn = document.getElementById('proximityModeAlways');
        const proximityFollowBtn = document.getElementById('proximityModeFollow');
        if (voiceStandardBtn) { voiceStandardBtn.disabled = false; voiceStandardBtn.style.opacity = '1'; }
        if (voiceCheekyBtn) { voiceCheekyBtn.disabled = false; voiceCheekyBtn.style.opacity = '1'; }
        if (warningDistanceRange) { warningDistanceRange.disabled = false; warningDistanceRange.style.opacity = '1'; }
        if (proximityAlwaysBtn) { proximityAlwaysBtn.disabled = false; proximityAlwaysBtn.style.opacity = '1'; }
        if (proximityFollowBtn) { proximityFollowBtn.disabled = false; proximityFollowBtn.style.opacity = '1'; }

        // Загружаем базовую информацию профиля
        try {
            const { data: driver } = await _sb.from('drivers').select('user_id,name,car_model,car_plate,avatar_url').eq('user_id', uid).maybeSingle();
            if (driver) currentDriver = driver;
        } catch (e) {
            console.warn('Не удалось получить данные из drivers:', e?.message || e);
        }

        if (!currentDriver) {
            // Показываем форму регистрации, если профиля нет
            openRegistrationModal();
            return;
        }

        // Считаем статистику по маркерам напрямую из таблицы markers
        let marks_count = 0, likes = 0, dislikes = 0;
        try {
            const { data: markers } = await _sb.from('markers').select('votes_up,votes_down').eq('author_id', uid);
            if (markers) {
                marks_count = markers.length;
                markers.forEach(m => {
                    likes += m.votes_up || 0;
                    dislikes += m.votes_down || 0;
                });
            }
        } catch (e) {
            console.warn('Ошибка при подсчёте маркеров:', e?.message || e);
        }

        // Получаем серверный SOS-бонус (+50 за подтвержденную помощь)
        const sosBonus = await getUserSosBonus(uid);

        // Подготовка отображаемых данных
        const displayName = currentDriver.name || ((window.Telegram?.WebApp?.initDataUnsafe?.user?.first_name) || '');
        const safeCurrentAvatarUrl = sanitizeMediaUrl(currentDriver.avatar_url);
        
        // Отображаем аватар (только фото если есть)
        const avatarEl = document.getElementById('profile-avatar-display');
        if (safeCurrentAvatarUrl) {
            avatarEl.style.backgroundImage = `url('${safeCurrentAvatarUrl}')`;
            avatarEl.style.backgroundSize = 'cover';
            avatarEl.style.backgroundPosition = 'center';
            avatarEl.textContent = '';
            document.getElementById('profile-avatar-url').value = safeCurrentAvatarUrl;
            document.getElementById('profile-avatar-value').value = '';
        } else {
            // По умолчанию показываем emoji
            avatarEl.style.backgroundImage = 'none';
            avatarEl.textContent = '👤';
            document.getElementById('profile-avatar-display').textContent = '👤';
            document.getElementById('profile-avatar-value').value = '👤';
            document.getElementById('profile-avatar-url').value = '';
        }
        
        // Обновляем поля редактирования
        document.getElementById('edit-car-model').value = currentDriver.car_model || '';
        document.getElementById('edit-car-plate').value = currentDriver.car_plate || '';
        
        // Определяем, является ли пользователь "Проверенным водителем"
        const isTrusted = (likes >= (typeof TRUST_LIKES_THRESHOLD !== 'undefined' ? TRUST_LIKES_THRESHOLD : 20));
        const isAdminProfile = isAdminUserId(uid);
        const profileNameEl = document.getElementById('profile-name-text');
        if (isAdminProfile) {
            profileNameEl.textContent = displayName;
            profileNameEl.classList.add('admin-name');
            profileNameEl.classList.remove('trusted');
        } else {
            profileNameEl.textContent = (isTrusted ? '⭐ ' : '') + displayName;
            if (isTrusted) profileNameEl.classList.add('trusted'); else profileNameEl.classList.remove('trusted');
            profileNameEl.classList.remove('admin-name');
        }
        updateProfileAdminBadges(isAdminProfile);
        const karmaPoints = Math.max(0, (likes - dislikes) + marks_count + sosBonus);
        document.getElementById('profile-rating').textContent = `${karmaPoints}`;
        document.getElementById('profile-marks-count').textContent = marks_count;
        document.getElementById('profile-votes-sum').textContent = karmaPoints;
        document.getElementById('profile-likes').textContent = likes;
        document.getElementById('profile-dislikes').textContent = dislikes;
        
        // Отображаем статус доверия
        const trustStatusEl = document.getElementById('profile-trust-status');
        if (isAdminProfile) {
            trustStatusEl.innerHTML = `👑 ${ADMIN_TITLE_LABEL}`;
            trustStatusEl.style.color = '#d4af37';
        } else if (karmaPoints >= 50) {
            trustStatusEl.innerHTML = '🛟 Выручатор';
            trustStatusEl.style.color = '#1e88e5';
        } else if (isTrusted) {
            trustStatusEl.innerHTML = '⭐ Проверенный водитель';
            trustStatusEl.style.color = '#b8860b';
        } else {
            trustStatusEl.innerHTML = `🤝 Участник взаимопомощи (${karmaPoints} очков)`;
            trustStatusEl.style.color = 'var(--blue)';
        }

        // Загружаем и отображаем достижения
        try {
            const ach = await loadAchievements();
            const profileNameEl = document.getElementById('profile-name-text');
            profileNameEl.title = `Статус: ${ach.title}`;

            // Удаляем предыдущий блок достижений, если есть
            const existingAchBlock = document.getElementById('profile-achievements-block');
            if (existingAchBlock) existingAchBlock.remove();

            // Создаем блок достижений с прогрессом
            let achievementsHTML = '<div id="profile-achievements-block" style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #e0e0e0;">';
            achievementsHTML += `<div style="font-size: 13px; font-weight: 700; margin-bottom: 6px; color: var(--blue);">🏅 Статус: ${ach.title}</div>`;
            achievementsHTML += `<div style="font-size: 12px; color: var(--gray); margin-bottom: 10px;">Выполнено: ${ach.completedCount}/${ach.totalCount}</div>`;
            achievementsHTML += '<div class="achievement-grid">';

            ach.allAchievements.forEach(a => {
                const cls = a.completed ? 'achievement done' : 'achievement locked';
                const progressText = `${Math.min(a.progress, a.required)}/${a.required}${a.metric ? ' ' + a.metric : ''}`;
                achievementsHTML += `<div class="${cls}" title="${a.desc}"><div class="achievement-icon">${a.icon}</div><div class="achievement-title">${a.title}</div><div class="achievement-progress">${progressText}</div></div>`;
            });

            achievementsHTML += '</div></div>';

            // Вставляем достижения перед блоком доверия
            const trustBlock = document.getElementById('profile-trust-status').parentElement;
            trustBlock.insertAdjacentHTML('afterend', achievementsHTML);
        } catch (e) {
            console.warn('Ошибка при загрузке достижений:', e?.message || e);
        }

        // Попытка сохранить вычисленные значения взаимовыручки в таблице drivers (если колонки есть)
        try {
            await _sb.from('drivers').upsert([
                { user_id: uid, likes_sum: (likes + sosBonus), is_trusted: isTrusted }
            ], { onConflict: 'user_id' });
        } catch (e) {
            // Если таблица или колонки отсутствуют — просто логируем, приложение продолжит работать
            console.warn('Не удалось обновить показатели взаимовыручки в drivers (возможно, колонки likes_sum/is_trusted отсутствуют):', e?.message || e);
        }

        const target = document.querySelector('.target');
        if (target) target.style.visibility = 'hidden';
        
        // Обновляем состояние кнопок стиля озвучки в профиле
        document.getElementById('voiceStyleStandard').style.background = voiceStyle === 'standard' ? '#34c759' : '#9c9c9c';
        document.getElementById('voiceStyleCheeky').style.background = voiceStyle === 'cheeky' ? '#34c759' : '#9c9c9c';
        const descEl = document.getElementById('voiceStyleDescription');
        if (voiceStyle === 'cheeky') {
            descEl.textContent = '😎 Выбран: Дерзкий стиль озвучки';
        } else {
            descEl.textContent = '✨ Выбран: Стандартный стиль озвучки';
        }
        
        document.getElementById('profileModal').classList.add('active');
    }

    // Функция закрытия профиля
    function closeProfileModal() {
        isViewingOwnProfile = true;

        const target = document.querySelector('.target');
        if (target) target.style.visibility = 'visible';
        
        // Восстанавливаем элементы редактирования профиля
        const avatarDisplay = document.getElementById('profile-avatar-display');
        avatarDisplay.style.cursor = 'pointer';
        avatarDisplay.title = 'Нажмите чтобы изменить';
        avatarDisplay.onclick = () => changeAvatar();
        
        // Показываем кнопку загрузки фото
        const uploadPhotoBtn = document.querySelector('button[onclick="document.getElementById(\'profile-photo-input\').click()"]');
        if (uploadPhotoBtn) uploadPhotoBtn.style.display = '';
        
        // Показываем форму редактирования авто
        const carEditForm = document.querySelector('div[style*="border: 1px solid #ddd"]');
        if (carEditForm) carEditForm.style.display = '';
        
        // Показываем кнопку "ВЫЙТИ"
        const logoutBtn = document.querySelector('button[onclick="logout()"]');
        if (logoutBtn) logoutBtn.style.display = '';
        
        // Удаляем секцию модерации
        const adminSection = document.getElementById('profile-admin-section');
        if (adminSection) adminSection.remove();

        const profileNameEl = document.getElementById('profile-name-text');
        if (profileNameEl) profileNameEl.classList.remove('admin-name');
        updateProfileAdminBadges(false);
        
        // Удаляем информацию об авто других пользователей
        const carInfoEl = document.getElementById('other-user-car-info');
        if (carInfoEl) carInfoEl.remove();
        
        document.getElementById('profileModal').classList.remove('active');
    }

    // Функция просмотра профиля другого пользователя
    async function openOtherUserProfile(userId) {
        try {
            isViewingOwnProfile = false;

            // Загружаем данные пользователя
            const { data: driver } = await _sb.from('drivers').select('user_id,name,car_model,car_plate,avatar_url').eq('user_id', userId).maybeSingle();
            
            if (!driver) {
                alert('Профиль пользователя не найден');
                return;
            }

            // Считаем статистику по маркерам этого пользователя
            let marks_count = 0, likes = 0, dislikes = 0;
            try {
                const { data: markers } = await _sb.from('markers').select('votes_up,votes_down').eq('author_id', userId);
                if (markers) {
                    marks_count = markers.length;
                    markers.forEach(m => {
                        likes += m.votes_up || 0;
                        dislikes += m.votes_down || 0;
                    });
                }
            } catch (e) {
                console.warn('Ошибка при подсчёте маркеров:', e?.message || e);
            }

            // Скрываем элементы редактирования профиля
            document.getElementById('profile-avatar-display').style.cursor = 'default';
            document.getElementById('profile-avatar-display').title = '';
            document.getElementById('profile-avatar-display').onclick = null;
            document.querySelector('button[onclick="document.getElementById(\'profile-photo-input\').click()"]').style.display = 'none';
            
            // Скрываем форму редактирования авто
            const carEditForm = document.querySelector('div[style*="border: 1px solid #ddd"]');
            if (carEditForm) carEditForm.style.display = 'none';

            // Блокируем персональные настройки в чужом профиле
            const voiceStandardBtn = document.getElementById('voiceStyleStandard');
            const voiceCheekyBtn = document.getElementById('voiceStyleCheeky');
            const warningDistanceRange = document.getElementById('warningDistanceRange');
            const proximityAlwaysBtn = document.getElementById('proximityModeAlways');
            const proximityFollowBtn = document.getElementById('proximityModeFollow');
            if (voiceStandardBtn) { voiceStandardBtn.disabled = true; voiceStandardBtn.style.opacity = '0.5'; }
            if (voiceCheekyBtn) { voiceCheekyBtn.disabled = true; voiceCheekyBtn.style.opacity = '0.5'; }
            if (warningDistanceRange) { warningDistanceRange.disabled = true; warningDistanceRange.style.opacity = '0.5'; }
            if (proximityAlwaysBtn) { proximityAlwaysBtn.disabled = true; proximityAlwaysBtn.style.opacity = '0.5'; }
            if (proximityFollowBtn) { proximityFollowBtn.disabled = true; proximityFollowBtn.style.opacity = '0.5'; }

            // Отображаем аватар
            const avatarEl = document.getElementById('profile-avatar-display');
            const safeDriverAvatarUrl = sanitizeMediaUrl(driver.avatar_url);
            if (safeDriverAvatarUrl) {
                avatarEl.style.backgroundImage = `url('${safeDriverAvatarUrl}')`;
                avatarEl.style.backgroundSize = 'cover';
                avatarEl.style.backgroundPosition = 'center';
                avatarEl.textContent = '';
            } else {
                avatarEl.style.backgroundImage = 'none';
                avatarEl.textContent = '👤';
            }
            
            // Определяем, является ли пользователь "Проверенным водителем"
            const isTrusted = (likes >= (typeof TRUST_LIKES_THRESHOLD !== 'undefined' ? TRUST_LIKES_THRESHOLD : 20));
            const isAdminProfile = isAdminUserId(userId);
            const profileNameEl = document.getElementById('profile-name-text');
            if (isAdminProfile) {
                profileNameEl.textContent = (driver.name || 'Admin');
                profileNameEl.classList.add('admin-name');
                profileNameEl.classList.remove('trusted');
            } else {
                profileNameEl.textContent = (isTrusted ? '⭐ ' : '') + (driver.name || 'Аноним');
                if (isTrusted) profileNameEl.classList.add('trusted'); else profileNameEl.classList.remove('trusted');
                profileNameEl.classList.remove('admin-name');
            }
            updateProfileAdminBadges(isAdminProfile);
            
            // Обновляем уровень взаимовыручки и статистику
            const sosBonus = await getUserSosBonus(userId);
            const karmaPoints = Math.max(0, (likes - dislikes) + marks_count + sosBonus);
            document.getElementById('profile-rating').textContent = `${karmaPoints}`;
            document.getElementById('profile-marks-count').textContent = marks_count;
            document.getElementById('profile-votes-sum').textContent = karmaPoints;
            document.getElementById('profile-likes').textContent = likes;
            document.getElementById('profile-dislikes').textContent = dislikes;
            
            // Отображаем статус доверия
            const trustStatusEl = document.getElementById('profile-trust-status');
            if (isAdminProfile) {
                trustStatusEl.innerHTML = `👑 ${ADMIN_TITLE_LABEL}`;
                trustStatusEl.style.color = '#d4af37';
            } else if (karmaPoints >= 50) {
                trustStatusEl.innerHTML = '🛟 Выручатор';
                trustStatusEl.style.color = '#1e88e5';
            } else if (isTrusted) {
                trustStatusEl.innerHTML = '⭐ Проверенный водитель';
                trustStatusEl.style.color = '#b8860b';
            } else {
                trustStatusEl.innerHTML = `🤝 Участник взаимопомощи (${karmaPoints} очков)`;
                trustStatusEl.style.color = '#999';
            }

            // Добавляем карточку информации об авто
            const carInfoHtml = `
                <div style="background: #f9f9f9; border-radius: 12px; padding: 12px; margin-bottom: 15px;">
                    <div style="font-size: 12px; color: var(--gray); margin-bottom: 8px; font-weight: 600;">🚗 Автомобиль</div>
                    <div style="font-weight: 700; color: #000; font-size: 15px;">${driver.car_model || 'Не указан'}</div>
                    <div style="font-size: 13px; color: var(--gray); margin-top: 6px;"><strong>Номер:</strong> ${driver.car_plate || 'Не указана'}</div>
                </div>
            `;
            
            // Вставляем инфо об авто временно
            const statsGrid = document.querySelector('.stats-grid');
            let carInfoEl = document.getElementById('other-user-car-info');
            if (!carInfoEl) {
                carInfoEl = document.createElement('div');
                carInfoEl.id = 'other-user-car-info';
                statsGrid.parentElement.insertBefore(carInfoEl, statsGrid);
            }
            carInfoEl.innerHTML = carInfoHtml;

            // Добавляем кнопку забана для админов перед кнопками выхода
            let adminSection = document.getElementById('profile-admin-section');
            if (adminSection) adminSection.remove();
            
            adminSection = document.createElement('div');
            adminSection.id = 'profile-admin-section';
            
            if (isAdmin) {
                adminSection.innerHTML = `
                    <div class="moderation-section" style="padding-top: 0; border-top: none; margin-bottom: 15px;">
                        <div class="moderation-title">⚙️ Модерация</div>
                        <div class="moderation-buttons">
                            <button class="mod-btn mod-btn-temp" onclick="moderateUserFromProfile(${userId}, '${(driver.name || 'Пользователь').replace(/'/g, "\\'")}', 'temp')">
                                <span style="font-size: 18px;">⏱️</span>
                                Временный бан
                            </button>
                            
                            <button class="mod-btn mod-btn-perm" onclick="moderateUserFromProfile(${userId}, '${(driver.name || 'Пользователь').replace(/'/g, "\\'")}', 'permanent')">
                                <span style="font-size: 18px;">🚫</span>
                                Постоянный бан
                            </button>
                        </div>
                        <div style="margin-top: 10px; display: flex; gap: 8px;">
                            <button class="main-btn" style="background: #666; flex: 1; font-size: 11px; padding: 10px;" onclick="deleteAllUserMarkers(${userId}, '${(driver.name || 'Пользователь').replace(/'/g, "\\'")}')">🗑️ Удалить метки</button>
                            <button class="main-btn" style="background: #666; flex: 1; font-size: 11px; padding: 10px;" onclick="deleteAllUserMessages(${userId}, '${(driver.name || 'Пользователь').replace(/'/g, "\\'")}')">💬 Удалить чат</button>
                        </div>
                    </div>
                `;
            } else {
                adminSection.innerHTML = `
                    <div style="padding-top: 15px; border-top: 1px solid #ddd; margin-bottom: 15px;">
                        <button class="main-btn" style="background: #ff9500; font-size: 12px;" onclick="reportUser(${userId}, '${(driver.name || 'Пользователь').replace(/'/g, "\\'")}', 'профиль', '')">⚠️ Пожаловаться</button>
                    </div>
                `;
            }

            // Вставляем перед кнопкой "ВЫЙТИ"
            const logoutBtn = document.querySelector('button[onclick="logout()"]');
            logoutBtn.parentElement.insertBefore(adminSection, logoutBtn);

            // Скрываем кнопку "ВЫЙТИ"
            logoutBtn.style.display = 'none';

            // Открываем модальное окно профиля
            const target = document.querySelector('.target');
            if (target) target.style.visibility = 'hidden';
            document.getElementById('profileModal').classList.add('active');

        } catch (e) {
            console.warn('Ошибка при загрузке профиля пользователя:', e?.message || e);
            alert('Ошибка при загрузке профиля: ' + (e?.message || 'неизвестная ошибка'));
        }
    }    // Функция открытия модала с глобальным уровнем взаимовыручки
    async function openRatingsModal() {
        const ratingsList = document.getElementById('ratingsList');
        ratingsList.innerHTML = '<div style="color: var(--gray);">⏳ Загрузка уровней взаимовыручки...</div>';
        
        try {
            // Загружаем всех водителей
            const { data: drivers } = await _sb.from('drivers').select('user_id,name,car_model,car_plate,likes_sum,is_trusted');
            
            if (!drivers || drivers.length === 0) {
                ratingsList.innerHTML = '<div style="color: var(--gray); padding: 20px;">Водители не найдены</div>';
                const target = document.querySelector('.target');
                if (target) target.style.visibility = 'hidden';
                document.getElementById('ratingsModal').classList.add('active');
                return;
            }
            
            // Загружаем SOS-бонусы для всех водителей
            const { data: sosRewards } = await _sb.from('sos_help_rewards').select('helper_id,bonus_points');
            const sosBonusByUser = {};
            if (sosRewards && sosRewards.length) {
                sosRewards.forEach(r => {
                    const key = String(r.helper_id || '');
                    sosBonusByUser[key] = (sosBonusByUser[key] || 0) + (Number(r.bonus_points) || 0);
                });
            }

            // Считаем очки кармы для каждого водителя (если likes_sum отсутствует)
            let driverStats = [];
            for (const d of drivers) {
                let likesSum = d.likes_sum || 0;
                let isTrusted = d.is_trusted || false;
                const sosBonus = Number(sosBonusByUser[String(d.user_id)] || 0);
                
                // Если likes_sum не заполнен, считаем из markers
                if (!d.likes_sum) {
                    const { data: markers } = await _sb.from('markers').select('votes_up').eq('author_id', d.user_id);
                    if (markers) {
                        likesSum = markers.reduce((sum, m) => sum + (m.votes_up || 0), 0);
                    }
                    isTrusted = likesSum >= (typeof TRUST_LIKES_THRESHOLD !== 'undefined' ? TRUST_LIKES_THRESHOLD : 20);
                }
                likesSum += sosBonus;
                
                driverStats.push({
                    user_id: d.user_id,
                    name: d.name || 'Аноним',
                    car_model: d.car_model || 'N/A',
                    likes: likesSum,
                    is_trusted: isTrusted
                });
            }
            
            // Сортируем по очкам кармы (по убыванию)
            driverStats.sort((a, b) => b.likes - a.likes);
            
            // Генерируем HTML
            let html = '';
            driverStats.forEach((driver, idx) => {
                const medal = idx === 0 ? '🥇' : (idx === 1 ? '🥈' : (idx === 2 ? '🥉' : ''));
                const trustBadge = driver.is_trusted ? ' ⭐' : '';
                const isAdminProfile = isAdminUserId(driver.user_id);
                const displayNameHtml = isAdminProfile
                    ? `<span class="admin-name">${driver.name}</span> <span class="admin-rank">${ADMIN_RANK_LABEL}</span>`
                    : `${driver.name}${trustBadge}`;
                html += `
                    <div style="padding: 12px; border-bottom: 1px solid #e0e0e0; display: flex; justify-content: space-between; align-items: center; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.background='#f9f9f9'; this.style.transform='translateX(4px)'" onmouseout="this.style.background=''; this.style.transform='translateX(0)'" onclick="openProfileModal(${driver.user_id}); closeRatingsModal();">
                        <div style="flex: 1;">
                            <div style="font-weight: 700; color: #000; font-size: 14px;">${medal} ${displayNameHtml}</div>
                            <div style="font-size: 11px; color: var(--gray);">${driver.car_model}</div>
                        </div>
                        <div style="text-align: right;">
                            <div style="font-weight: 800; color: var(--blue); font-size: 16px;">${driver.likes}</div>
                            <div style="font-size: 11px; color: var(--gray);">кармы</div>
                        </div>
                    </div>
                `;
            });
            
            ratingsList.innerHTML = html;
        } catch (e) {
            console.warn('Ошибка при загрузке уровней взаимовыручки:', e?.message || e);
            ratingsList.innerHTML = '<div style="color: red; padding: 20px;">Ошибка загрузки уровней взаимовыручки</div>';
        }
        
        const target = document.querySelector('.target');
        if (target) target.style.visibility = 'hidden';
        document.getElementById('ratingsModal').classList.add('active');
    }

    // Функция закрытия модала взаимовыручки
    function closeRatingsModal() {
        const target = document.querySelector('.target');
        if (target) target.style.visibility = 'visible';
        document.getElementById('ratingsModal').classList.remove('active');
    }

    // ============= ФУНКЦИИ ДЛЯ ОТПРАВКИ ОТЧЕТОВ О БАГАХ =============

    function openBugReportModal() {
        const target = document.querySelector('.target');
        if (target) target.style.visibility = 'hidden';
        
        // Предзаполняем имя если было указано ранее
        const driverName = currentDriver?.name || window.Telegram?.WebApp?.initDataUnsafe?.user?.first_name || '';
        document.getElementById('bugReporterName').value = driverName;
        
        // Очищаем поля
        document.getElementById('bugDescription').value = '';
        document.getElementById('bugCategory').value = 'ui';
        document.getElementById('bugReproducible').checked = false;
        document.getElementById('bugIncludeLogs').checked = false;
        document.getElementById('bugReportStatus').style.display = 'none';
        
        document.getElementById('bugReportModal').classList.add('active');
    }

    function closeBugReportModal() {
        const target = document.querySelector('.target');
        if (target) target.style.visibility = 'visible';
        document.getElementById('bugReportModal').classList.remove('active');
    }

    async function submitBugReport() {
        const category = document.getElementById('bugCategory').value;
        const description = document.getElementById('bugDescription').value.trim();
        const reporterName = document.getElementById('bugReporterName').value.trim();
        const reproducible = document.getElementById('bugReproducible').checked;
        const includeLogs = document.getElementById('bugIncludeLogs').checked;
        const status = document.getElementById('bugReportStatus');

        if (!description) {
            status.textContent = '❌ Пожалуйста, опишите проблему';
            status.style.color = '#dc3545';
            status.style.display = 'block';
            return;
        }

        status.textContent = '⏳ Отправка отчета...';
        status.style.color = '#007aff';
        status.style.display = 'block';

        try {
            // Собираем информацию о системе если нужна
            let additionalInfo = '';
            if (includeLogs) {
                additionalInfo = `\n\n---ТЕХНИЧЕСКАЯ ИНФОРМАЦИЯ---\n`;
                additionalInfo += `User ID: ${uid}\n`;
                additionalInfo += `Время: ${new Date().toISOString()}\n`;
                additionalInfo += `ОС: ${window.navigator.userAgent}\n`;
                additionalInfo += `Может быть повторена: ${reproducible ? 'Да' : 'Нет'}`;
            }

            const fullMessage = `${description}${additionalInfo}`;

            // Сохраняем в таблицу feedback
            const { error } = await _sb.from('feedback').insert({
                user_id: String(uid),
                user_name: reporterName || 'Анонимно',
                message: `[${category.toUpperCase()}] ${fullMessage}`,
                status: 'new'
            });

            if (error) {
                throw error;
            }

            status.textContent = '✅ Спасибо! Отчет отправлен модераторам';
            status.style.color = '#28a745';
            
            // Закрываем модальное окно через 2 секунды
            setTimeout(() => {
                closeBugReportModal();
            }, 2000);

        } catch (err) {
            console.error('Ошибка при отправке отчета:', err);
            status.textContent = '❌ Ошибка: ' + (err?.message || 'Неизвестная ошибка');
            status.style.color = '#dc3545';
        }
    }

    // Функция открытия просмотра фото
    function openPhotoViewer(photoUrl) {
        document.getElementById('photoViewerImage').src = photoUrl;
        document.getElementById('photoUrl').value = photoUrl;
        const target = document.querySelector('.target');
        if (target) target.style.visibility = 'hidden';
        document.getElementById('photoViewerModal').classList.add('active');
    }

    // Функция закрытия просмотра фото
    function closePhotoViewer() {
        const target = document.querySelector('.target');
        if (target) target.style.visibility = 'visible';
        document.getElementById('photoViewerModal').classList.remove('active');
    }
    
    // Функция удаления фото из чата
    async function deletePhotoFromChat() {
        const photoUrl = document.getElementById('photoUrl')?.value;
        if (!photoUrl) {
            alert('Фото не найдено');
            return;
        }
        
        if (!confirm('Удалить это фото?')) return;
        
        try {
            // Найти сообщение с этим фото и удалить его
            const { data: messages } = await _sb.from('messages').select('id, author_id').eq('photo_url', photoUrl);
            
            if (!messages || messages.length === 0) {
                alert('Сообщение с этим фото не найдено');
                return;
            }
            
            const msg = messages[0];
            const isOwnMessage = msg.author_id === uid;
            const isAdminDeleting = isAdmin && msg.author_id !== uid;
            
            if (!isOwnMessage && !isAdminDeleting) {
                alert('Вы можете удалять только свои фото');
                return;
            }
            
            // Удаляем сообщение с фото
            const { error } = await _sb.from('messages').delete().eq('id', msg.id);
            if (error) {
                alert('Ошибка удаления: ' + (error?.message || 'неизвестная ошибка'));
                return;
            }
            
            alert('✅ Фото и сообщение удалены');
            closePhotoViewer();
            await loadChatMessages();
        } catch (e) {
            console.error('Ошибка при удалении фото:', e);
            alert('Ошибка: ' + (e?.message || e));
        }
    }

    // Функция выхода из аккаунта
    function logout() {
        if (confirm('Вы уверены, что хотите выйти?')) {
            currentDriver = null;
            closeProfileModal();
            openRegistrationModal();
        }
    }

    // Аватар: Croppie модуль + загрузка в Supabase Storage
    let avatarEditorInstance = null;
    let avatarEditorInitPromise = null;

    async function blobToDataUrl(blob) {
        return await new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(String(reader.result || ''));
            reader.onerror = () => reject(new Error('Не удалось преобразовать изображение'));
            reader.readAsDataURL(blob);
        });
    }

    function isStorageBucketMissingError(error) {
        const msg = String(error?.message || error?.error || error?.details || '').toLowerCase();
        const status = Number(error?.statusCode || error?.status || 0);
        if (msg.includes('bucket not found')) return true;
        if (msg.includes('bucket') && msg.includes('not found')) return true;
        if (msg.includes('nosuchbucket')) return true;
        if ((status === 400 || status === 404) && msg.includes('bucket')) return true;
        return false;
    }

    async function uploadAvatarViaEdgeFunction(blob) {
        const dataUrl = await blobToDataUrl(blob);
        const headers = {
            'content-type': 'application/json',
            apikey: SUPABASE_KEY
        };
        const token = String(currentSupabaseToken || '').trim();
        if (token) headers['authorization'] = `Bearer ${token}`;

        const resp = await fetch(`${SUPABASE_URL}/functions/v1/avatar-upload`, {
            method: 'POST',
            headers,
            body: JSON.stringify({ image_data_url: dataUrl })
        });

        const payload = await resp.json().catch(() => ({}));
        if (!resp.ok || !payload?.ok || !payload?.public_url) {
            const err = new Error(String(payload?.error || `avatar-upload failed (${resp.status})`));
            err.status = resp.status;
            throw err;
        }

        return String(payload.public_url);
    }

    async function uploadAvatarBlobToStorage(blob, ext = 'jpg') {
        if (!uid) throw new Error('Пользователь не авторизован');
        try {
            return await uploadAvatarViaEdgeFunction(blob);
        } catch (error) {
            const message = String(error?.message || '').toLowerCase();
            const status = Number(error?.status || 0);
            const isExpectedFallback =
                message.includes('bucket') ||
                message.includes('row-level security') ||
                message.includes('rls') ||
                message.includes('failed to fetch') ||
                status === 400 || status === 401 || status === 404;
            if (!isExpectedFallback) throw error;

            console.warn('Edge upload недоступен, используем fallback data URL:', error?.message || error);
            return await blobToDataUrl(blob);
        }
    }

    async function ensureAvatarEditorReady() {
        if (avatarEditorInstance) return avatarEditorInstance;
        if (avatarEditorInitPromise) return avatarEditorInitPromise;

        avatarEditorInitPromise = (async () => {
            if (typeof window.TelegramAvatarEditor !== 'function') {
                throw new Error('Модуль редактора аватара не загружен');
            }

            const editor = new window.TelegramAvatarEditor({
                fileInput: '#profile-photo-input',
                cssPath: './avatar-editor.css',
                title: 'Редактор аватара',
                saveText: 'Обрезать и сохранить',
                onSave: async (blob) => {
                    const avatarUrl = await uploadAvatarBlobToStorage(blob, 'jpg');
                    const safeAvatarUrl = sanitizeMediaUrl(avatarUrl);
                    if (!safeAvatarUrl) throw new Error('Некорректный URL аватара');

                    const avatarEl = document.getElementById('profile-avatar-display');
                    if (avatarEl) {
                        avatarEl.style.backgroundImage = `url('${safeAvatarUrl}')`;
                        avatarEl.style.backgroundSize = 'cover';
                        avatarEl.style.backgroundPosition = 'center';
                        avatarEl.textContent = '';
                    }

                    const avatarUrlEl = document.getElementById('profile-avatar-url');
                    const avatarValueEl = document.getElementById('profile-avatar-value');
                    if (avatarUrlEl) avatarUrlEl.value = safeAvatarUrl;
                    if (avatarValueEl) avatarValueEl.value = '';
                    if (currentDriver) currentDriver.avatar_url = safeAvatarUrl;

                    alert('✅ Аватар сохранен');
                },
                onError: (error) => {
                    const msg = error?.message || 'Ошибка редактора аватара';
                    console.warn('Avatar editor error:', msg);
                }
            });

            await editor.init();
            avatarEditorInstance = editor;
            return editor;
        })();

        try {
            return await avatarEditorInitPromise;
        } finally {
            avatarEditorInitPromise = null;
        }
    }

    async function changeAvatar() {
        try {
            await ensureAvatarEditorReady();
            document.getElementById('profile-photo-input')?.click();
        } catch (e) {
            alert('Ошибка загрузки редактора: ' + (e?.message || e));
        }
    }

    function closeAvatarEditor() {
        try { avatarEditorInstance?.close?.(); } catch (e) {}
    }

    async function saveAvatarEdit() {
        try { await avatarEditorInstance?.save?.(); } catch (e) {}
    }

    // Функция сохранения изменений профиля
    async function saveProfileChanges() {
        const carModel = document.getElementById('edit-car-model').value.trim() || (currentDriver?.car_model || '');
        const carPlate = document.getElementById('edit-car-plate').value.trim() || (currentDriver?.car_plate || '');

        try {
            const updateData = {
                car_model: carModel,
                car_plate: carPlate
            };
            
            // Сохраняем URL аватара фото если есть (avatar_url колонка)
            const avatarUrl = document.getElementById('profile-avatar-url').value;
            if (avatarUrl) {
                updateData.avatar_url = avatarUrl;
            }

            // Выполняем update с обработкой ошибок schema cache
            let result = await _sb.from('drivers').update(updateData).eq('user_id', uid);
            let error = result.error;

            // Если ошибка связана со schema cache, пытаемся повторить без avatar_url
            if (error && error.message && error.message.includes('avatar')) {
                console.warn('Ошибка при сохранении avatar_url, пытаемся сохранить без него:', error.message);
                const updateDataWithoutAvatar = {
                    car_model: carModel,
                    car_plate: carPlate
                };
                result = await _sb.from('drivers').update(updateDataWithoutAvatar).eq('user_id', uid);
                error = result.error;
            }

            if (error) {
                alert('Ошибка сохранения: ' + (error?.message || 'неизвестная ошибка'));
                return;
            }

            // Обновляем локальные данные
            currentDriver.car_model = carModel;
            currentDriver.car_plate = carPlate;
            if (avatarUrl) {
                currentDriver.avatar_url = avatarUrl;
            }

            alert('✅ Изменения сохранены!');
            // Перезагружаем профиль
            await openProfileModal();
        } catch (e) {
            alert('Ошибка: ' + (e?.message || e));
        }
    }

    // Глобальные переменные для хранения полных данных админ-панели
    let adminAllDrivers = [];
    let adminBannedIds = new Set();
    let adminLikesMap = {};
    let adminAllMarkers = [];

    // Функция открытия админ-панели
    async function openAdminModal() {
        if (!isAdmin) {
            alert('У вас нет доступа к админ-панели');
            return;
        }

        // Загружаем список водителей
        try {
            const { data: drivers } = await _sb.from('drivers').select('user_id,name,car_model,car_plate');
            adminAllDrivers = drivers || [];
            const tbody = document.getElementById('admin-drivers-body');
            tbody.innerHTML = '';
            if (adminAllDrivers && adminAllDrivers.length > 0) {
                // Загружаем список забанненых пользователей
                adminBannedIds = new Set();
                try {
                    const { data: bans } = await _sb.from('bans').select('user_id');
                    if (bans) {
                        bans.forEach(b => adminBannedIds.add(b.user_id.toString()));
                    }
                } catch (e) {
                    console.warn('Ошибка при загрузке списка банов (возможно, таблица не существует):', e?.message);
                }
                
                // Соберем список ID водителей и подсчитаем лайки за один запрос
                const driverIds = adminAllDrivers.map(d => d.user_id.toString());
                adminLikesMap = {};
                try {
                    const { data: likesRows } = await _sb.from('markers').select('author_id,votes_up').in('author_id', driverIds);
                    if (likesRows) {
                        likesRows.forEach(r => {
                            const id = r.author_id.toString();
                            adminLikesMap[id] = (adminLikesMap[id] || 0) + (r.votes_up || 0);
                        });
                    }
                } catch (e) {
                    console.warn('Не удалось загрузить лайки для водителей:', e?.message || e);
                }

                // Рендерим все водителей в таблицу
                renderDriversTable(adminAllDrivers);
                document.getElementById('admin-drivers-count').textContent = adminAllDrivers.length;
            } else {
                tbody.innerHTML = '<tr><td colspan="5" style="text-align: center; color: var(--gray);">Водители не найдены</td></tr>';
            }
        } catch (e) {
            console.warn('Ошибка при загрузке водителей:', e?.message || e);
            document.getElementById('admin-drivers-body').innerHTML = '<tr><td colspan="5" style="text-align: center; color: red;">Ошибка загрузки</td></tr>';
        }

        // Загружаем список активных маркеров
        try {
            const { data: markers } = await _sb.from('markers').select('*');
            const now = Date.now();
            adminAllMarkers = (markers || []).filter(m => {
                if (m.exp === null || typeof m.exp === 'undefined') return true;
                if (typeof m.exp === 'number') return m.exp > now;
                const parsed = Date.parse(m.exp);
                return !isNaN(parsed) ? parsed > now : true;
            });
            
            // Рендерим все метки в таблицу
            renderMarkersTable(adminAllMarkers);
            document.getElementById('admin-markers-count').textContent = adminAllMarkers.length;
        } catch (e) {
            console.warn('Ошибка при загрузке маркеров:', e?.message || e);
            document.getElementById('admin-markers-body').innerHTML = '<tr><td colspan="6" style="text-align: center; color: red;">Ошибка загрузки</td></tr>';
        }

        // Добавляем обработчики событий для поиска и фильтрации
        const searchInput = document.getElementById('driverSearchInput');
        if (searchInput) {
            searchInput.value = '';
            searchInput.addEventListener('keyup', filterDriversTable);
        }

        const typeFilter = document.getElementById('markerTypeFilter');
        if (typeFilter) {
            typeFilter.value = '';
            typeFilter.addEventListener('change', filterMarkersTable);
        }

        await loadUnbanRequests();
        await refreshBugReports();
        await refreshMaintenanceStatus();

        const target = document.querySelector('.target');
        if (target) target.style.visibility = 'hidden';
        document.getElementById('adminModal').classList.add('active');
    }

    // Функция рендеринга таблицы водителей
    function renderDriversTable(drivers) {
        const tbody = document.getElementById('admin-drivers-body');
        tbody.innerHTML = '';
        
        if (!drivers || drivers.length === 0) {
            tbody.innerHTML = '<tr><td colspan="5" style="text-align: center; color: var(--gray);">Не найдено</td></tr>';
            return;
        }

        drivers.forEach(d => {
            const isBanned = adminBannedIds.has(d.user_id.toString());
            const statusBadge = isBanned ? '🚫 ЗАБАН' : '✅';
            const statusStyle = isBanned ? 'background: #ff3b30; color: white;' : '';
            const likes = adminLikesMap[d.user_id.toString()] || 0;
            const isTrustedDriver = likes >= (typeof TRUST_LIKES_THRESHOLD !== 'undefined' ? TRUST_LIKES_THRESHOLD : 20);
            const nameCell = `${isTrustedDriver ? '⭐ ' : ''}${d.name || 'N/A'}`;
            const row = `<tr style="${statusStyle}">
                <td>${nameCell}</td>
                <td>${d.car_model || 'N/A'}</td>
                <td>${d.car_plate || 'N/A'}</td>
                <td>${statusBadge}</td>
                <td style="display: flex; gap: 5px;">
                    <button class="delete-btn" onclick="deleteDriver('${d.user_id}')">Удалить</button>
                </td>
            </tr>`;
            tbody.innerHTML += row;
        });
    }

    // Функция рендеринга таблицы маркеров
    function renderMarkersTable(markers) {
        const tbody = document.getElementById('admin-markers-body');
        tbody.innerHTML = '';
        
        if (!markers || markers.length === 0) {
            tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; color: var(--gray);">Не найдено</td></tr>';
            return;
        }

        markers.forEach(m => {
            // format existing exp to local datetime-local value if possible
            let expVal = '';
            if (m.exp) {
                try {
                    const parsed = (typeof m.exp === 'number') ? new Date(Number(m.exp)) : new Date(m.exp);
                    if (!isNaN(parsed)) {
                        const pad = n => n.toString().padStart(2, '0');
                        const y = parsed.getFullYear();
                        const mo = pad(parsed.getMonth() + 1);
                        const d = pad(parsed.getDate());
                        const hh = pad(parsed.getHours());
                        const mm = pad(parsed.getMinutes());
                        expVal = `${y}-${mo}-${d}T${hh}:${mm}`;
                    }
                } catch (e) { expVal = ''; }
            }

            let readableExp = '';
            if (m.exp) {
                try {
                    const parsedExp = (typeof m.exp === 'number') ? new Date(Number(m.exp)) : new Date(m.exp);
                    if (!isNaN(parsedExp)) {
                        readableExp = parsedExp.toLocaleString('ru-RU', { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit' });
                    }
                } catch (e) { readableExp = ''; }
            }

            const row = `<tr>
                <td>${MAP_ICONS[m.type] || '?'}</td>
                <td>${m.comment || 'без комментария'}</td>
                <td>${m.votes_up || 0}</td>
                <td>${m.votes_down || 0}</td>
                <td style="width:260px;">
                    <input type="datetime-local" id="marker-exp-${m.id}" value="${expVal}" style="width:140px; padding:6px; border-radius:6px; border:1px solid #ddd;">
                    <button class="delete-btn" style="margin-left:6px;" onclick="setMarkerExpiry(${m.id})">Установить</button>
                    <button class="delete-btn" style="margin-left:6px; background:#999;" onclick="clearMarkerExpiry(${m.id})">Очистить</button>
                    <div style="font-size:12px; color: var(--gray); margin-top:6px;">${readableExp ? readableExp : ''}</div>
                </td>
                <td><button class="delete-btn" onclick="deleteMarkerAdmin(${m.id})">Удалить</button></td>
            </tr>`;
            tbody.innerHTML += row;
        });
    }

    // Функция поиска водителей
    function filterDriversTable() {
        const searchInput = document.getElementById('driverSearchInput');
        const query = searchInput.value.toLowerCase().trim();
        
        if (!query) {
            // Если поле пустое, показываем всех
            renderDriversTable(adminAllDrivers);
            return;
        }

        // Фильтруем по имени или ID
        const filtered = adminAllDrivers.filter(d => {
            const name = (d.name || '').toLowerCase();
            const id = String(d.user_id).toLowerCase();
            return name.includes(query) || id.includes(query);
        });

        renderDriversTable(filtered);
    }

    // Функция фильтрации маркеров по типу
    function filterMarkersTable() {
        const typeFilter = document.getElementById('markerTypeFilter');
        const selectedType = typeFilter.value;
        
        if (!selectedType) {
            // Если фильтр пустой, показываем все
            renderMarkersTable(adminAllMarkers);
            return;
        }

        // Фильтруем по типу
        const filtered = adminAllMarkers.filter(m => m.type === selectedType);
        renderMarkersTable(filtered);
    }

    // Функция сброса поиска водителей
    function clearDriverSearch() {
        const searchInput = document.getElementById('driverSearchInput');
        searchInput.value = '';
        renderDriversTable(adminAllDrivers);
    }

    // Функция сброса фильтра маркеров
    function clearMarkerFilter() {
        const typeFilter = document.getElementById('markerTypeFilter');
        typeFilter.value = '';
        renderMarkersTable(adminAllMarkers);
    }

    // ============= ФУНКЦИИ ДЛЯ УПРАВЛЕНИЯ ЗБТ КОДАМИ =============

    async function invokeAdminFunction(functionName, payload = {}) {
        function getJwtExp(token) {
            try {
                const parts = String(token || '').split('.');
                if (parts.length !== 3) return 0;
                const payloadPart = parts[1].replace(/-/g, '+').replace(/_/g, '/');
                const normalized = payloadPart + '='.repeat((4 - (payloadPart.length % 4)) % 4);
                const json = JSON.parse(atob(normalized));
                const exp = Number(json?.exp || 0);
                return Number.isFinite(exp) ? exp : 0;
            } catch (e) {
                return 0;
            }
        }

        let token = '';
        try {
            const stored = String(localStorage.getItem('sb_jwt') || '').trim();
            const expRaw = Number(localStorage.getItem('sb_jwt_exp') || 0);
            const expFromToken = getJwtExp(stored);
            const expSec = expRaw > 0 ? expRaw : expFromToken;
            const expired = !expSec || ((Date.now() / 1000) > (expSec - 60));
            if (stored && stored.split('.').length === 3 && !expired) token = stored;
        } catch (e) {
            token = '';
        }

        if (!token) {
            try {
                const refreshed = await ensureSupabaseAuth();
                if (refreshed && String(refreshed).split('.').length === 3) token = String(refreshed);
            } catch (e) {
                token = '';
            }
        }

        if (!token) {
            throw new Error('Нет авторизации для админ‑функций. Откройте приложение через Telegram Mini App и попробуйте снова.');
        }

        const callEdge = async (bearer) => {
            return fetch(`${SUPABASE_URL}/functions/v1/${functionName}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${bearer}`
                },
                body: JSON.stringify(payload || {})
            });
        };

        let resp = await callEdge(token);
        if (resp.status === 401) {
            try {
                localStorage.removeItem('sb_jwt');
                localStorage.removeItem('sb_jwt_exp');
            } catch (e) {}
            try {
                const refreshed = await ensureSupabaseAuth();
                if (refreshed && String(refreshed).split('.').length === 3) {
                    token = String(refreshed);
                    resp = await callEdge(token);
                }
            } catch (e) {
                // игнор, обработаем ниже через !resp.ok
            }
        }

        let data = null;
        let text = '';
        try {
            const ct = String(resp.headers.get('content-type') || '').toLowerCase();
            if (ct.includes('application/json')) data = await resp.json();
            else text = await resp.text();
        } catch (e) {}

        if (!resp.ok) {
            const detail = (data && typeof data === 'object' && data.error)
                ? String(data.error)
                : (text || `HTTP ${resp.status}`);
            throw new Error(`Edge Function ${functionName}: ${detail}`);
        }

        if (data && typeof data === 'object' && 'error' in data && data.error) {
            const errMsg = typeof data.error === 'string' ? data.error : JSON.stringify(data.error);
            throw new Error(errMsg || `Edge Function ${functionName} error`);
        }
        return data;
    }

    async function generateBetaCode() {
        const countInput = document.getElementById('betaCodeCountInput');
        const descInput = document.getElementById('betaCodeDescInput');
        const status = document.getElementById('betaCodeStatus');
        
        const count = Math.max(1, Math.min(100, parseInt(countInput.value) || 1));
        const desc = descInput.value.trim() || null;

        status.textContent = '⏳ Генерирование...';
        status.style.color = '#007aff';
        status.style.display = 'block';

        try {
            if (!isAdmin) {
                throw new Error('Недостаточно прав: только админ может создавать коды');
            }

            let code = '';
            let inserted = false;
            let lastError = null;
            let createdResponse = null;
            const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';

            // Делаем несколько попыток, чтобы не падать на редкой коллизии уникального code
            for (let attempt = 1; attempt <= 7; attempt++) {
                code = Array.from({ length: 6 }, () => alphabet[Math.floor(Math.random() * alphabet.length)]).join('');

                try {
                    createdResponse = await invokeAdminFunction('beta-invite', {
                        code,
                        maxUses: count,
                        description: desc
                    });
                    inserted = true;
                    break;
                } catch (fnError) {
                    lastError = fnError;
                    const msg = String(fnError?.message || '');
                    const isDuplicate = /duplicate key|unique constraint|already exists|409/.test(msg);
                    if (!isDuplicate) {
                        throw fnError;
                    }
                }
            }

            if (!inserted) {
                throw lastError || new Error('Не удалось создать уникальный код');
            }

            const createdCode = createdResponse?.code || code;
            status.textContent = `✅ Код создан: ${createdCode}`;
            status.style.color = '#28a745';
            
            countInput.value = '1';
            descInput.value = '';

            // Обновляем таблицу
            await refreshBetaCodes();

        } catch (err) {
            console.error('Ошибка при создании кода:', err);
            const msg = String(err?.message || 'Ошибка сервера');
            if (/admin|доступ|permission denied|forbidden|Access denied/i.test(msg)) {
                status.textContent = '❌ Edge Function beta-invite отклонила запрос (нет прав)';
            } else {
                status.textContent = '❌ ' + msg;
            }
            status.style.color = '#dc3545';
        }
    }

    async function refreshBetaCodes() {
        try {
            if (!isAdmin) throw new Error('Только для администратора');

            const response = await invokeAdminFunction('beta-invite', { action: 'list' });
            const data = Array.isArray(response?.data) ? response.data : [];

            const tbody = document.getElementById('betaCodesTableBody');
            if (!data || data.length === 0) {
                tbody.innerHTML = `
                    <tr style="background: #f9f9f9;">
                        <td colspan="6" style="padding: 20px; text-align: center; color: #888;">
                            Нет созданных кодов
                        </td>
                    </tr>
                `;
                return;
            }

            tbody.innerHTML = data.map(invite => {
                const isUsed = invite.current_uses >= invite.max_uses;
                const isActive = invite.is_active && !isUsed;
                
                return `
                    <tr style="background: ${isUsed ? '#fff3cd' : 'white'}; border-bottom: 1px solid #ddd;">
                        <td style="padding: 10px; border: 1px solid #ddd; font-weight: 700; font-family: monospace;">${invite.code}</td>
                        <td style="padding: 10px; text-align: center; border: 1px solid #ddd;">${invite.max_uses}</td>
                        <td style="padding: 10px; text-align: center; border: 1px solid #ddd;">${invite.current_uses}</td>
                        <td style="padding: 10px; text-align: center; border: 1px solid #ddd;">
                            ${invite.current_uses}/${invite.max_uses}
                        </td>
                        <td style="padding: 10px; text-align: center; border: 1px solid #ddd;">
                            <span style="display: inline-block; padding: 4px 8px; border-radius: 4px; font-size: 12px; font-weight: 700; background: ${isActive ? '#d4edda' : '#f8d7da'}; color: ${isActive ? '#28a745' : '#dc3545'};">
                                ${isActive ? '✓ Активен' : '✕ Использован'}
                            </span>
                        </td>
                        <td style="padding: 10px; text-align: center; border: 1px solid #ddd;">
                            <button onclick="copyBetaCode('${invite.code}')" style="background: #007aff; color: white; border: none; padding: 5px 10px; border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: 600; margin-right: 5px;">
                                📋 Скопир.
                            </button>
                            <button onclick="deactivateBetaCode(${invite.id})" style="background: #dc3545; color: white; border: none; padding: 5px 10px; border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: 600;">
                                ✕ Отклю.
                            </button>
                        </td>
                    </tr>
                `;
            }).join('');

        } catch (err) {
            console.error('Ошибка загрузки кодов:', err);
            document.getElementById('betaCodesTableBody').innerHTML = `
                <tr style="background: #fff3cd;">
                    <td colspan="6" style="padding: 20px; text-align: center; color: #dc3545;">
                        ❌ Ошибка загрузки кодов
                    </td>
                </tr>
            `;
        }
    }

    function copyBetaCode(code) {
        navigator.clipboard.writeText(code).then(() => {
            alert('✅ Код скопирован: ' + code);
        }).catch(() => {
            alert('❌ Ошибка копирования');
        });
    }

    async function deactivateBetaCode(inviteId) {
        if (!confirm('Деактивировать этот код?')) return;

        try {
            if (!isAdmin) throw new Error('Только для администратора');

            await invokeAdminFunction('beta-invite', {
                action: 'deactivate',
                inviteId
            });

            await refreshBetaCodes();
        } catch (err) {
            alert('❌ Ошибка: ' + (err?.message || 'Неизвестная ошибка'));
        }
    }

    // ============= ФУНКЦИИ ДЛЯ ПРОСМОТРА ОТЧЕТОВ О БАГАХ =============

    async function refreshBugReports() {
        try {
            const { data, error } = await _sb
                .from('feedback')
                .select('*')
                .order('created_at', { ascending: false });

            if (error) {
                throw error;
            }

            const reports = data || [];
            
            // Обновляем статистику
            const newCount = reports.filter(r => r.status === 'new').length;
            const readCount = reports.filter(r => r.status === 'read').length;
            const resolvedCount = reports.filter(r => r.status === 'resolved').length;
            
            document.getElementById('newBugsCount').textContent = newCount;
            document.getElementById('readBugsCount').textContent = readCount;
            document.getElementById('resolvedBugsCount').textContent = resolvedCount;

            // Рендерим таблицу
            const tbody = document.getElementById('bugReportsTableBody');
            if (reports.length === 0) {
                tbody.innerHTML = `<tr><td colspan="6" style="text-align: center; padding: 20px; color: #888;">Нет отчетов</td></tr>`;
                return;
            }

            tbody.innerHTML = reports.map(report => {
                const date = new Date(report.created_at).toLocaleString('ru-RU', { 
                    day: '2-digit', 
                    month: '2-digit', 
                    year: 'numeric', 
                    hour: '2-digit', 
                    minute: '2-digit' 
                });
                
                const message = report.message || '';
                let category = '❓ Другое';
                if (message.startsWith('[UI]')) category = '🎨 Интерфейс';
                else if (message.startsWith('[MAP]')) category = '🗺️ Карта';
                else if (message.startsWith('[MARKERS]')) category = '📍 Метки';
                else if (message.startsWith('[CHAT]')) category = '💬 Чат';
                else if (message.startsWith('[CRASH]')) category = '💥 Краш';
                else if (message.startsWith('[PERFORMANCE]')) category = '⚡ Производительность';
                
                const description = message.substring(message.indexOf(']') + 2, 60) + (message.length > 60 ? '...' : '');
                
                const statusBadge = report.status === 'new' ? '🔴 Новое' : 
                                   report.status === 'read' ? '🟡 Прочитано' : 
                                   '✅ Решено';
                const statusColor = report.status === 'new' ? '#dc3545' : 
                                   report.status === 'read' ? '#ff9500' : 
                                   '#28a745';

                return `<tr style="background: ${report.status === 'new' ? '#fff0f0' : 'white'};">
                    <td>${category}</td>
                    <td style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 200px;" title="${message}">${description}</td>
                    <td>${report.user_name || 'Аноним'}</td>
                    <td style="text-align: center;">
                        <span style="display: inline-block; padding: 4px 8px; border-radius: 4px; font-size: 11px; font-weight: 700; background: ${statusColor}; color: white;">
                            ${statusBadge}
                        </span>
                    </td>
                    <td style="text-align: center; font-size: 12px;">${date}</td>
                    <td style="text-align: center;">
                        ${report.status !== 'resolved' ? `<button onclick="markBugAsResolved('${report.id}')" style="background: #28a745; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: 600; margin-right: 3px;">✓ Решено</button>` : ''}
                        <button onclick="deleteBugReport('${report.id}')" style="background: #dc3545; color: white; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 11px; font-weight: 600;">🗑️ Удалить</button>
                    </td>
                </tr>`;
            }).join('');

        } catch (err) {
            console.error('Ошибка загрузки отчетов:', err);
            document.getElementById('bugReportsTableBody').innerHTML = `
                <tr><td colspan="6" style="text-align: center; padding: 20px; color: #dc3545;">
                    ❌ Ошибка загрузки отчетов
                </td></tr>
            `;
        }
    }

    async function markBugAsResolved(reportId) {
        try {
            const { error } = await _sb
                .from('feedback')
                .update({ status: 'resolved' })
                .eq('id', reportId);

            if (error) throw error;
            await refreshBugReports();
        } catch (err) {
            alert('❌ Ошибка: ' + (err?.message || 'Неизвестная ошибка'));
        }
    }

    async function deleteBugReport(reportId) {
        if (!confirm('Удалить этот отчет?')) return;

        try {
            const { error } = await _sb
                .from('feedback')
                .delete()
                .eq('id', reportId);

            if (error) throw error;
            await refreshBugReports();
        } catch (err) {
            alert('❌ Ошибка: ' + (err?.message || 'Неизвестная ошибка'));
        }
    }

    async function refreshMaintenanceStatus() {
        try {
            const { data } = await _sb
                .from('app_maintenance')
                .select('value')
                .eq('key', 'maintenance_mode')
                .maybeSingle();

            const statusEl = document.getElementById('maintenanceStatus');
            if (!statusEl) return;

            if (data) {
                const settings = JSON.parse(data.value);
                if (settings.active) {
                    statusEl.textContent = '🔴 Техническое обслуживание АКТИВно';
                    statusEl.style.background = '#dc3545';
                    const msgEl = document.getElementById('maintenanceMessage');
                    if (msgEl) msgEl.value = settings.message || '';
                } else {
                    statusEl.textContent = '🟢 Карта активна';
                    statusEl.style.background = '#28a745';
                }
            } else {
                statusEl.textContent = '🟢 Карта активна';
                statusEl.style.background = '#28a745';
            }
        } catch (err) {
            // Ключ не найден - это нормально
            const statusEl = document.getElementById('maintenanceStatus');
            if (statusEl) {
                statusEl.textContent = '🟢 Карта активна';
                statusEl.style.background = '#28a745';
            }
        }
    }

    // Функции управления техническим обслуживанием
    async function enableMaintenance() {
        const message = document.getElementById('maintenanceMessage').value || '⚠️ Техническое обслуживание. Приносим извинения.';
        
        try {
            await invokeAdminFunction('maintenance-toggle', {
                active: true,
                message: message,
                timestamp: Date.now()
            });
            alert('✅ Карта закрыта на техническое обслуживание!');
            await refreshMaintenanceStatus();
        } catch (err) {
            alert('❌ Ошибка Edge Function maintenance-toggle: ' + (err?.message || 'Неизвестная ошибка'));
        }
    }

    async function disableMaintenance() {
        try {
            await invokeAdminFunction('maintenance-toggle', { active: false });
            alert('✅ Карта открыта для пользователей!');
            
            // Скрываем оверлей ТО
            const overlay = document.getElementById('maintenanceOverlay');
            if (overlay) overlay.remove();
            
            // Показываем main контент
            const main = document.getElementById('main');
            if (main) main.style.display = 'flex';
            
            // Инициализируем приложение полностью
            await new Promise(r => setTimeout(r, 500));
            location.reload();
            
        } catch (err) {
            alert('❌ Ошибка Edge Function maintenance-toggle: ' + (err?.message || 'Неизвестная ошибка'));
        }
    }

    function updateMaintenanceStatus(isActive, message) {
        const status = document.getElementById('maintenanceStatus');
        if (isActive) {
            status.textContent = '🔴 Техническое обслуживание';
            status.style.background = '#dc3545';
        } else {
            status.textContent = '🟢 Карта активна';
            status.style.background = '#28a745';
        }
    }

    async function checkMaintenanceStatus(isUserAdmin = false) {
        try {
            const { data } = await _sb
                .from('app_maintenance')
                .select('value')
                .eq('key', 'maintenance_mode')
                .maybeSingle();

            if (data) {
                const settings = JSON.parse(data.value);
                if (settings.active) {
                    // Показываем оверлей ТО
                    showMaintenanceOverlay(settings.message, isUserAdmin);
                    return true;
                }
            }
        } catch (err) {
            // Ключ не найден, ТО не активно
        }
        return false;
    }

    function showMaintenanceOverlay(message, isUserAdmin = false) {
        // Удалим старый оверлей если есть
        const oldOverlay = document.getElementById('maintenanceOverlay');
        if (oldOverlay) oldOverlay.remove();

        const overlay = document.createElement('div');
        overlay.id = 'maintenanceOverlay';
        overlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            font-family: Arial, sans-serif;
        `;

        const content = document.createElement('div');
        content.style.cssText = `
            background: white;
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            max-width: 300px;
        `;

        let adminButton = '';
        if (isUserAdmin) {
            adminButton = `
                <button onclick="disableMaintenance()" style="background: #28a745; color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-weight: 600; margin-top: 15px; width: 100%;">
                    🔑 Отключить ТО (Админ)
                </button>
            `;
        }

        content.innerHTML = `
            <div style="font-size: 60px; margin-bottom: 15px;">⚙️</div>
            <h2 style="margin: 0 0 15px 0; font-size: 24px; font-weight: 800; color: #333;">Техническое обслуживание</h2>
            <p style="margin: 0; font-size: 16px; color: #666; line-height: 1.5;">${message}</p>
            <p style="margin: 15px 0 0 0; font-size: 12px; color: #999;">Приносим извинения за неудобства!</p>
            ${adminButton}
        `;

        overlay.appendChild(content);
        document.body.appendChild(overlay);

        // Повторяем проверку каждые 10 сек чтобы обновить статус
        setTimeout(() => {
            const latest = document.getElementById('maintenanceOverlay');
            if (latest) checkMaintenanceStatus(isUserAdmin);
        }, 10000);
    }

    function initAdminBroadcastChannel() {
        if (!_sb || adminBroadcastChannel) return;
        adminBroadcastChannel = _sb.channel('admin-broadcast', {
            config: { broadcast: { self: true } }
        });

        adminBroadcastChannel.on('broadcast', { event: 'admin-message' }, ({ payload }) => {
            if (!payload || !payload.text) return;
            showBroadcastBanner(payload.text, !!payload.withSignal);
        });

        adminBroadcastChannel.on('broadcast', { event: 'admin-visibility' }, ({ payload }) => {
            if (!payload || typeof payload.active !== 'boolean') return;
            const nextState = !!payload.active;
            if (adminInvisible !== nextState) {
                adminInvisible = nextState;
                updateAdminInvisibleButton();
                loadMarkersDebounced();
                if (isAdmin) updateUserLocationMarker();
            }
        });

        adminBroadcastChannel.subscribe();
    }

    function closeRealtimeChannels() {
        try {
            if (_sb && markersRealtimeChannel) _sb.removeChannel(markersRealtimeChannel);
            if (_sb && messagesRealtimeChannel) _sb.removeChannel(messagesRealtimeChannel);
        } catch (e) {
            console.warn('Ошибка отключения realtime каналов:', e?.message || e);
        }
        markersRealtimeChannel = null;
        messagesRealtimeChannel = null;
        if (markersRealtimeTimer) {
            clearTimeout(markersRealtimeTimer);
            markersRealtimeTimer = null;
        }
        if (messagesRealtimeTimer) {
            clearTimeout(messagesRealtimeTimer);
            messagesRealtimeTimer = null;
        }
    }

    function scheduleMarkersRealtimeReload() {
        if (markersRealtimeTimer) return;
        markersRealtimeTimer = setTimeout(() => {
            markersRealtimeTimer = null;
            if (typeof loadMarkers === 'function') loadMarkers().catch?.(()=>{});
        }, 120);
    }

    function scheduleMessagesRealtimeReload() {
        if (messagesRealtimeTimer) return;
        messagesRealtimeTimer = setTimeout(() => {
            messagesRealtimeTimer = null;
            const chatModal = document.getElementById('chatModal');
            if (chatModal && chatModal.classList.contains('active') && typeof loadChatMessages === 'function') {
                loadChatMessages().catch?.(()=>{});
            }
        }, 300);
    }

    function initRealtimeChannels() {
        if (!_sb) return;
        if (markersRealtimeChannel || messagesRealtimeChannel) return;

        markersRealtimeChannel = _sb
            .channel('realtime-markers')
            .on('postgres_changes', { event: '*', schema: 'public', table: 'markers' }, (payload) => {
                scheduleMarkersRealtimeReload();
                handleRealtimeMarkerNotification(payload);
            })
            .subscribe();

        messagesRealtimeChannel = _sb
            .channel('realtime-messages')
            .on('postgres_changes', { event: '*', schema: 'public', table: 'messages' }, () => {
                scheduleMessagesRealtimeReload();
            })
            .subscribe();
    }

    function showBroadcastBanner(text, withSignal) {
        const banner = document.getElementById('broadcastBanner');
        if (!banner) return;
        banner.textContent = `👑 ${text}`;
        banner.classList.add('visible');
        clearTimeout(banner._hideTimer);
        banner._hideTimer = setTimeout(() => {
            banner.classList.remove('visible');
        }, 8000);
        if (withSignal) playAdminSignal();
    }

    function playAdminSignal() {
        try {
            const ctx = new (window.AudioContext || window.webkitAudioContext)();
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.type = 'sine';
            osc.frequency.value = 880;
            gain.gain.value = 0.0001;
            osc.connect(gain);
            gain.connect(ctx.destination);
            osc.start();
            gain.gain.exponentialRampToValueAtTime(0.2, ctx.currentTime + 0.02);
            gain.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.5);
            osc.stop(ctx.currentTime + 0.55);
            osc.onended = () => ctx.close();
        } catch (e) {
            console.warn('Не удалось воспроизвести сигнал:', e?.message || e);
        }
    }

    async function sendAdminBroadcast(withSignal) {
        if (!isAdmin) {
            alert('Только администратор может отправлять уведомления');
            return;
        }
        const input = document.getElementById('adminBroadcastText');
        const statusEl = document.getElementById('adminBroadcastStatus');
        const text = (input?.value || '').trim();
        if (!text) {
            if (statusEl) statusEl.textContent = '❌ Введите текст уведомления';
            return;
        }
        if (statusEl) statusEl.textContent = '⏳ Отправляем...';
        try {
            initAdminBroadcastChannel();
            const res = await adminBroadcastChannel.send({
                type: 'broadcast',
                event: 'admin-message',
                payload: { text, withSignal: !!withSignal, ts: Date.now(), by: String(uid || '') }
            });
            if (res !== 'ok' && res?.status !== 'ok') throw new Error('Broadcast failed');
            if (statusEl) statusEl.textContent = '✅ Уведомление отправлено';
            input.value = '';
        } catch (e) {
            if (statusEl) statusEl.textContent = '❌ Ошибка отправки';
        }
    }

    function updateAdminInvisibleButton() {
        const toggle = document.getElementById('adminInvisibleToggle');
        if (!toggle) return;
        if (adminInvisible) {
            toggle.textContent = 'ВКЛ';
            toggle.style.background = '#111';
            toggle.style.color = '#fff';
        } else {
            toggle.textContent = 'ВЫКЛ';
            toggle.style.background = '#f0f0f5';
            toggle.style.color = '#333';
        }
    }

    async function refreshAdminInvisibleStatus() {
        let nextState = false;
        try {
            const { data } = await _sb
                .from('app_maintenance')
                .select('value')
                .eq('key', 'admin_invisible')
                .maybeSingle();
            if (data && data.value) {
                const settings = JSON.parse(data.value);
                nextState = !!settings.active;
            }
        } catch (err) {
            nextState = false;
        }
        if (adminInvisible !== nextState) {
            adminInvisible = nextState;
            updateAdminInvisibleButton();
            loadMarkersDebounced();
            if (isAdmin) updateUserLocationMarker();
        }
    }

    async function toggleAdminInvisible() {
        if (!isAdmin) return;
        const nextState = !adminInvisible;
        try {
            initAdminBroadcastChannel();
            if (nextState) {
                await _sb.from('app_maintenance').upsert({
                    key: 'admin_invisible',
                    value: JSON.stringify({ active: true, by: String(uid || ''), timestamp: Date.now() })
                }, { onConflict: 'key' });
            } else {
                await _sb.from('app_maintenance').delete().eq('key', 'admin_invisible');
            }
            adminInvisible = nextState;
            updateAdminInvisibleButton();
            loadMarkersDebounced();
            if (isAdmin) updateUserLocationMarker();
            if (adminBroadcastChannel) {
                await adminBroadcastChannel.send({
                    type: 'broadcast',
                    event: 'admin-visibility',
                    payload: { active: adminInvisible, ts: Date.now() }
                });
            }
        } catch (e) {
            alert('❌ Ошибка переключения режима невидимки');
        }
    }

    // Функция закрытия админ-панели
    function closeAdminModal() {
        const target = document.querySelector('.target');
        if (target) target.style.visibility = 'visible';
        document.getElementById('adminModal').classList.remove('active');
    }

    // ============================================
    // JAVASCRIPT КОД ДЛЯ УПРАВЛЕНИЯ ЗАПРОСАМИ НА РАЗБАН
    // ============================================

    let currentFilter = 'all';
    let currentReviewRequestId = null;
    let allUnbanRequests = [];

    // Загрузка запросов на разбан
    async function loadUnbanRequests() {
        try {
            const { data, error } = await _sb
                .from('unban_requests')
                .select('*')
                .order('created_at', { ascending: false });

            if (error) throw error;

            allUnbanRequests = data || [];
            updateUnbanRequestsStats();
            displayUnbanRequests();

        } catch (error) {
            console.error('Ошибка загрузки запросов:', error);
            document.getElementById('unbanRequestsBody').innerHTML = `
                <tr>
                    <td colspan="6" style="text-align: center; padding: 20px; color: #dc3545;">
                        ❌ Ошибка загрузки запросов
                    </td>
                </tr>
            `;
        }
    }

    // Обновление статистики
    function updateUnbanRequestsStats() {
        const pending = allUnbanRequests.filter(r => r.status === 'pending').length;
        const approved = allUnbanRequests.filter(r => r.status === 'approved').length;
        const rejected = allUnbanRequests.filter(r => r.status === 'rejected').length;

        document.getElementById('pendingRequestsCount').textContent = pending;
        document.getElementById('approvedRequestsCount').textContent = approved;
        document.getElementById('rejectedRequestsCount').textContent = rejected;
    }

    // Отображение запросов с учетом фильтра
    function displayUnbanRequests() {
        const tbody = document.getElementById('unbanRequestsBody');
        
        let filteredRequests = allUnbanRequests;
        if (currentFilter !== 'all') {
            filteredRequests = allUnbanRequests.filter(r => r.status === currentFilter);
        }

        if (filteredRequests.length === 0) {
            tbody.innerHTML = `
                <tr>
                    <td colspan="6" style="text-align: center; padding: 20px; color: var(--gray);">
                        Запросов не найдено
                    </td>
                </tr>
            `;
            return;
        }

        tbody.innerHTML = filteredRequests.map(request => {
            const createdAt = new Date(request.created_at).toLocaleString('ru-RU');
            
            let statusBadge;
            if (request.status === 'pending') {
                statusBadge = '<span style="background: #fff3cd; color: #856404; padding: 4px 12px; border-radius: 12px; font-size: 11px; font-weight: 700;">⏳ Ожидает</span>';
            } else if (request.status === 'approved') {
                statusBadge = '<span style="background: #d4edda; color: #155724; padding: 4px 12px; border-radius: 12px; font-size: 11px; font-weight: 700;">✅ Одобрено</span>';
            } else {
                statusBadge = '<span style="background: #f8d7da; color: #721c24; padding: 4px 12px; border-radius: 12px; font-size: 11px; font-weight: 700;">❌ Отклонено</span>';
            }

            let actions;
            if (request.status === 'pending') {
                actions = `
                    <button onclick="openReviewUnbanModal(${request.id})" 
                        class="delete-btn" 
                        style="background: var(--blue); padding: 6px 12px;">
                        🔍 Рассмотреть
                    </button>
                `;
            } else {
                const reviewedAt = request.reviewed_at ? new Date(request.reviewed_at).toLocaleString('ru-RU') : '-';
                actions = `<small style="color: var(--gray);">Рассмотрено: ${reviewedAt}</small>`;
            }

            return `
                <tr>
                    <td>#${request.id}</td>
                    <td><strong>${request.username || 'Неизвестно'}</strong></td>
                    <td><code>${request.user_id}</code></td>
                    <td>${createdAt}</td>
                    <td>${statusBadge}</td>
                    <td>${actions}</td>
                </tr>
            `;
        }).join('');
    }

    // Фильтрация запросов
    function filterUnbanRequests(filter) {
        currentFilter = filter;
        
        // Обновляем кнопки
        document.querySelectorAll('.filter-btn').forEach(btn => {
            btn.classList.remove('active');
            btn.style.background = 'white';
            const color = btn.style.borderColor;
            btn.style.color = color || 'var(--blue)';
        });
        
        const filterMap = {
            'all': 'filterAll',
            'pending': 'filterPending',
            'approved': 'filterApproved',
            'rejected': 'filterRejected'
        };
        
        const activeBtn = document.getElementById(filterMap[filter]);
        if (activeBtn) {
            activeBtn.classList.add('active');
            const borderColor = activeBtn.style.borderColor;
            activeBtn.style.background = borderColor;
            activeBtn.style.color = 'white';
        }
        
        displayUnbanRequests();
    }

    // ============= Загрузка MP3 озвучки для предупреждений =============
    async function uploadCustomWarningAudios() {
        const status = document.getElementById('warningAudioStatus');
        if (!status) return;

        if (typeof _sb === 'undefined' || !_sb.storage) {
            status.textContent = '❌ Supabase client не найден';
            return;
        }

        const files = [
            { id: 'audioStandardFar', name: 'warning_standard_far.mp3' },
            { id: 'audioStandardClose', name: 'warning_standard_close.mp3' },
            { id: 'audioCheekyFar', name: 'warning_cheeky_far.mp3' },
            { id: 'audioCheekyClose', name: 'warning_cheeky_close.mp3' }
        ];

        const selected = files.map(item => {
            const input = document.getElementById(item.id);
            return { file: input?.files?.[0] || null, name: item.name };
        });

        const missing = selected.filter(item => !item.file).map(item => item.name);
        if (missing.length) {
            status.textContent = `❌ Не выбраны файлы: ${missing.join(', ')}`;
            return;
        }

        status.textContent = '⏳ Загружаем MP3 в Storage...';

        try {
            const bucket = 'audio';
            let success = 0;
            for (const item of selected) {
                const { error } = await _sb.storage
                    .from(bucket)
                    .upload(item.name, item.file, {
                        upsert: true,
                        contentType: item.file.type || 'audio/mpeg'
                    });
                if (error) throw error;
                success++;
            }

            status.textContent = `✅ Загружено ${success}/4 файла. Готово!`;
        } catch (e) {
            status.textContent = '❌ Ошибка загрузки: ' + (e?.message || e);
        }
    }

    // Конвертирует AudioBuffer в WAV Blob
    function bufferToWav(audioBuffer) {
        const numChannels = audioBuffer.numberOfChannels;
        const sampleRate = audioBuffer.sampleRate;
        const channelData = [];
        for (let i = 0; i < numChannels; i++) {
            channelData.push(audioBuffer.getChannelData(i));
        }
        
        // Interleave + конвертируем в Int16
        const samples = new Float32Array(audioBuffer.length * numChannels);
        let offset = 0;
        for (let i = 0; i < audioBuffer.length; i++) {
            for (let c = 0; c < numChannels; c++) {
                samples[offset++] = channelData[c][i];
            }
        }
        
        const int16Samples = new Int16Array(samples.length);
        for (let i = 0; i < samples.length; i++) {
            int16Samples[i] = Math.max(-1, Math.min(1, samples[i])) < 0 
                ? samples[i] * 0x8000 
                : samples[i] * 0x7FFF;
        }
        
        // WAV заголовок
        const WAV_HEADER_SIZE = 44;
        const dataLength = int16Samples.length * 2;
        const fileLength = 36 + dataLength;
        const header = new ArrayBuffer(WAV_HEADER_SIZE);
        const view = new DataView(header);
        
        const writeString = (offset, string) => {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        };
        
        writeString(0, 'RIFF');
        view.setUint32(4, fileLength, true);
        writeString(8, 'WAVE');
        writeString(12, 'fmt ');
        view.setUint32(16, 16, true);
        view.setUint16(20, 1, true);
        view.setUint16(22, numChannels, true);
        view.setUint32(24, sampleRate, true);
        view.setUint32(28, sampleRate * numChannels * 2, true);
        view.setUint16(32, numChannels * 2, true);
        view.setUint16(34, 16, true);
        writeString(36, 'data');
        view.setUint32(40, dataLength, true);
        
        return new Blob([header, int16Samples], { type: 'audio/wav' });
    }

    // Обновить список запросов
    async function refreshUnbanRequests() {
        await loadUnbanRequests();
    }

    // Открыть модальное окно рассмотрения
    async function openReviewUnbanModal(requestId) {
        currentReviewRequestId = requestId;
        
        const request = allUnbanRequests.find(r => r.id === requestId);
        if (!request) return;

        document.getElementById('reviewUsername').textContent = request.username || 'Неизвестно';
        document.getElementById('reviewUserId').textContent = request.user_id;
        document.getElementById('reviewCreatedAt').textContent = new Date(request.created_at).toLocaleString('ru-RU');
        document.getElementById('reviewComment').value = '';

        // Получаем информацию о бане
        try {
            const { data: banData } = await _sb
                .from('bans')
                .select('*')
                .eq('user_id', request.user_id)
                .maybeSingle();

            if (banData) {
                const bannedUntil = new Date(banData.banned_until);
                const isPermanent = bannedUntil.getFullYear() > 2050;
                const banInfo = isPermanent 
                    ? '🚫 Постоянный бан' 
                    : `⏰ До ${bannedUntil.toLocaleString('ru-RU')}`;
                document.getElementById('reviewBanInfo').innerHTML = `<span style="color: #dc3545; font-weight: 600;">${banInfo}</span>`;
            } else {
                document.getElementById('reviewBanInfo').innerHTML = '<span style="color: #28a745;">✅ Бан уже снят</span>';
            }
        } catch (error) {
            document.getElementById('reviewBanInfo').textContent = 'Ошибка загрузки информации';
        }

        document.getElementById('reviewUnbanModal').classList.add('active');
    }

    // Закрыть модальное окно рассмотрения
    function closeReviewUnbanModal() {
        document.getElementById('reviewUnbanModal').classList.remove('active');
        currentReviewRequestId = null;
    }

    // Одобрить запрос
    async function approveUnbanRequest() {
        if (!currentReviewRequestId) return;

        const comment = document.getElementById('reviewComment').value.trim();
        
        if (!confirm('Вы уверены, что хотите одобрить этот запрос? Бан будет автоматически снят.')) {
            return;
        }

        try {
            const adminIdString = String(uid);
            const request = allUnbanRequests.find(r => r.id === currentReviewRequestId);
            const targetUserId = request?.user_id ? String(request.user_id) : null;

            // Обновляем статус запроса (триггер автоматически снимет бан)
            const { error } = await _sb
                .from('unban_requests')
                .update({
                    status: 'approved',
                    reviewed_at: new Date().toISOString(),
                    reviewed_by: adminIdString,
                    reviewer_comment: comment || 'Запрос одобрен'
                })
                .eq('id', currentReviewRequestId);

            if (error) throw error;

            // Снимаем бан через Edge Function (внутри вызов SECURITY DEFINER)
            if (targetUserId) {
                try {
                    await invokeAdminFunction('unban-user', { targetUserId });
                } catch (unbanError) {
                    console.warn('unban-user Edge Function error:', unbanError?.message || unbanError);
                }
            }

            alert('✅ Запрос одобрен! Бан автоматически снят.');
            closeReviewUnbanModal();
            await loadUnbanRequests();

        } catch (error) {
            console.error('Ошибка одобрения запроса:', error);
            alert('❌ Ошибка при одобрении запроса: ' + (error.message || 'Неизвестная ошибка'));
        }
    }

    // Отклонить запрос
    async function rejectUnbanRequest() {
        if (!currentReviewRequestId) return;

        const comment = document.getElementById('reviewComment').value.trim();
        
        if (!comment) {
            alert('❗ Пожалуйста, укажите причину отклонения в комментарии');
            return;
        }

        if (!confirm('Вы уверены, что хотите отклонить этот запрос?')) {
            return;
        }

        try {
            const adminIdString = String(uid);

            const { error } = await _sb
                .from('unban_requests')
                .update({
                    status: 'rejected',
                    reviewed_at: new Date().toISOString(),
                    reviewed_by: adminIdString,
                    reviewer_comment: comment
                })
                .eq('id', currentReviewRequestId);

            if (error) throw error;

            alert('❌ Запрос отклонен');
            closeReviewUnbanModal();
            await loadUnbanRequests();

        } catch (error) {
            console.error('Ошибка отклонения запроса:', error);
            alert('❌ Ошибка при отклонении запроса: ' + (error.message || 'Неизвестная ошибка'));
        }
    }

    // Закрытие модального окна при клике вне его
    document.getElementById('reviewUnbanModal').addEventListener('click', function(e) {
        if (e.target === this) {
            closeReviewUnbanModal();
        }
    });

    // Функция для администратора: установить время истечения метки
    async function setMarkerExpiry(markerId) {
        if (!isAdmin) {
            alert('У вас нет доступа к этой операции');
            return;
        }

        const input = document.getElementById(`marker-exp-${markerId}`);
        if (!input) return alert('Поле времени не найдено');

        const val = input.value; // format: YYYY-MM-DDTHH:MM
        if (!val) return alert('Выберите дату и время истечения');

        try {
            const ts = new Date(val);
            if (isNaN(ts)) return alert('Неверный формат даты/времени');

            // Сохраняем ISO-строку (универсальный формат), чтобы хранить читаемую дату
            const expValue = ts.toISOString();

            const { error } = await _sb.from('markers').update({ exp: expValue }).eq('id', markerId);
            if (error) {
                alert('Ошибка при установке времени: ' + (error?.message || error));
                return;
            }

            alert('Время истечения обновлено');
            // Обновляем таблицу
            await openAdminModal();
        } catch (e) {
            alert('Ошибка: ' + (e?.message || e));
        }
    }

    // Функция для администратора: очистить время истечения метки
    async function clearMarkerExpiry(markerId) {
        if (!isAdmin) {
            alert('У вас нет доступа к этой операции');
            return;
        }
        if (!confirm('Удалить срок истечения для этой метки?')) return;
        try {
            const { error } = await _sb.from('markers').update({ exp: null }).eq('id', markerId);
            if (error) {
                alert('Ошибка при очистке: ' + (error?.message || error));
                return;
            }
            alert('Срок истечения удалён');
            await openAdminModal();
        } catch (e) {
            alert('Ошибка: ' + (e?.message || e));
        }
    }

    async function expireMarkerById(markerId) {
        return _sb.from('markers').update({ exp: Date.now() }).eq('id', markerId);
    }

    async function expireMarkersByAuthor(authorId) {
        return _sb.from('markers').update({ exp: Date.now() }).eq('author_id', authorId);
    }







    // Функция удаления водителя (админ)
    async function deleteDriver(driverId) {
        if (!isAdmin) {
            alert('У вас нет доступа к этой операции');
            return;
        }

        if (confirm('Вы уверены? Это также удалит все метки этого водителя')) {
            try {
                // Удаляем все метки водителя
                await expireMarkersByAuthor(driverId);
                // Удаляем водителя
                await _sb.from('drivers').delete().eq('user_id', driverId);
                // Пытаемся снять бан через Edge Function (без прямых прав)
                try {
                    await invokeAdminFunction('unban-user', { targetUserId: String(driverId) });
                } catch (e) {
                    console.warn('Edge Function unban-user недоступна:', e?.message || e);
                }
                alert('Водитель удален');
                openAdminModal(); // Обновляем список
            } catch (e) {
                alert('Ошибка при удалении: ' + (e?.message || e));
            }
        }
    }

    // Функция удаления маркера (админ)
    async function deleteMarkerAdmin(markerId) {
        if (!isAdmin) {
            alert('У вас нет доступа к этой операции');
            return;
        }

        if (confirm('Удалить эту метку?')) {
            try {
                await expireMarkerById(markerId);
                alert('Метка удалена');
                openAdminModal(); // Обновляем список
                loadMarkers(); // Обновляем карту
            } catch (e) {
                alert('Ошибка при удалении: ' + (e?.message || e));
            }
        }
    }

    // Функция открытия чата
    async function openChatModal() {
        const target = document.querySelector('.target');
        if (target) target.style.visibility = 'hidden';
        
        if (!currentDriver) {
            alert('Пожалуйста, завершите регистрацию');
            openRegistrationModal();
            return;
        }

        document.getElementById('chatModal').classList.add('active');
        await loadChatMessages();
        // Автоматически обновляем сообщения каждые 5 секунд
        chatUpdateInterval = setInterval(loadChatMessages, 5000);
    }

    // Функция закрытия чата
    // Функция показа контекстного меню для сообщений
    function showChatContextMenu(event, message, userId, userName) {
        event.stopPropagation();
        
        // Удаляем старое меню если оно есть
        const oldMenu = document.querySelector('.chat-context-menu');
        if (oldMenu) oldMenu.remove();
        
        // Создаём меню
        const menu = document.createElement('div');
        menu.className = 'chat-context-menu';
        menu.style.left = event.pageX + 'px';
        menu.style.top = event.pageY + 'px';
        
        // Кнопка удаления сообщения (для владельца или админа)
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'chat-context-menu-item delete';
        deleteBtn.innerHTML = '❌ Удалить сообщение';
        deleteBtn.onclick = () => {
            deleteMessage(message.id, userId);
            menu.remove();
        };
        menu.appendChild(deleteBtn);
        
        // Кнопка жалобы на пользователя
        const reportBtn = document.createElement('button');
        reportBtn.className = 'chat-context-menu-item report';
        reportBtn.innerHTML = '⚠️ Пожаловаться';
        reportBtn.onclick = () => {
            reportUser(userId, userName, 'сообщение', message.text);
            menu.remove();
        };
        menu.appendChild(reportBtn);
        
        // Добавляем меню в документ
        document.body.appendChild(menu);
        
        // Закрываем меню при клике вне его
        setTimeout(() => {
            document.addEventListener('click', function closeMenu(e) {
                if (!menu.contains(e.target)) {
                    menu.remove();
                    document.removeEventListener('click', closeMenu);
                }
            });
        }, 0);
    }

    function closeChatModal() {
        const target = document.querySelector('.target');
        if (target) target.style.visibility = 'visible';
        
        document.getElementById('chatModal').classList.remove('active');
        if (chatUpdateInterval) clearInterval(chatUpdateInterval);
    }

    // ===================== Рация (Push-to-Talk) — клиент =====================
    // Требует: Socket.io client (cdn), MediaRecorder, HTTPS для микрофона.
    const PTT_SERVER_URL = 'https://monolith-180-ptt.onrender.com'; // если пусто — используем текущий origin
    const PTT_SERVER_URL_STORAGE_KEY = 'ptt:serverUrl';
    const PTT_MAX_RECORD_MS = 7000;
    const PTT_COOLDOWN_MS = 10000;

    let pttSocket = null;
    let pttMediaStream = null;
    let pttMediaRecorder = null;
    let pttChunks = [];

    let pttIsPressed = false;
    let pttCooldownUntil = 0;
    let pttRecordAutoStopTimer = null;
    let pttCooldownTimer = null;

    let pttChannelBusy = null; // { userId, name }
    let pttBanned = false;

    let pttLastMessageId = null;
    let pttReporterId = null;

    let pttWakeLock = null;

    function pttBaseUrl() {
        try {
            const stored = localStorage.getItem(PTT_SERVER_URL_STORAGE_KEY);
            const raw = String(stored || PTT_SERVER_URL || '').trim();
            if (raw) return raw.replace(/\/$/, '');
        } catch (e) {}
        return location.origin;
    }

    // Удобная настройка без пересборки: в консоли можно выполнить
    // localStorage.setItem('ptt:serverUrl','https://xxx.onrender.com')
    // затем перезагрузить страницу.

    function pttEl(id) { return document.getElementById(id); }

    function pttGetName() {
        try {
            const driverName = String(currentDriver?.name || '').trim();
            if (driverName) return driverName.slice(0, 32);
        } catch (e) {}
        try {
            const tgName = String(window.Telegram?.WebApp?.initDataUnsafe?.user?.first_name || '').trim();
            if (tgName) return tgName.slice(0, 32);
        } catch (e) {}
        return 'Водитель';
    }

    function pttGetUserId() {
        try {
            if (typeof uid !== 'undefined' && uid) return String(uid);
        } catch (e) {}
        // fallback
        try {
            const k = 'ptt:userId';
            const stored = localStorage.getItem(k);
            if (stored) return stored;
            const gen = String(Math.random()).slice(2, 10);
            localStorage.setItem(k, gen);
            return gen;
        } catch (e) {
            return 'anon';
        }
    }

    function pttLogStatus(text) {
        const el = pttEl('pttStatus');
        if (el) el.textContent = String(text || '');
    }

    function pttSetHoldButtonState(state) {
        const btn = pttEl('pttHoldBtn');
        if (!btn) return;
        btn.classList.remove('disabled', 'busy');
        btn.disabled = false;

        if (pttBanned) {
            btn.classList.add('disabled');
            btn.disabled = true;
            btn.textContent = '🚫 Вы забанены в рации (30 мин)';
            return;
        }

        const now = Date.now();
        const cooldownLeft = Math.max(0, pttCooldownUntil - now);
        if (cooldownLeft > 0) {
            btn.classList.add('disabled');
            btn.disabled = true;
            const sec = Math.ceil(cooldownLeft / 1000);
            btn.textContent = `⏳ Подожди ${sec}с`;
            return;
        }

        const myId = pttGetUserId();
        if (pttChannelBusy && String(pttChannelBusy.userId) !== String(myId)) {
            btn.classList.add('busy');
            btn.disabled = true;
            btn.textContent = `Канал занят: ${pttChannelBusy.name}`;
            return;
        }

        if (state === 'pressed') {
            btn.textContent = '🎙️ Говорю… отпусти для отправки';
            return;
        }

        btn.textContent = '🎙️ Удерживай, чтобы говорить';
    }

    function pttStartCooldown() {
        pttCooldownUntil = Date.now() + PTT_COOLDOWN_MS;
        if (pttCooldownTimer) clearInterval(pttCooldownTimer);
        pttCooldownTimer = setInterval(() => {
            pttSetHoldButtonState('idle');
            if (Date.now() >= pttCooldownUntil) {
                clearInterval(pttCooldownTimer);
                pttCooldownTimer = null;
                pttSetHoldButtonState('idle');
            }
        }, 250);
        pttSetHoldButtonState('idle');
    }

    async function pttRequestWakeLock() {
        try {
            if (!('wakeLock' in navigator)) return;
            if (!isFeatureAllowedByPolicy('screen-wake-lock')) {
                if (!pttRequestWakeLock.__policyWarned) {
                    pttRequestWakeLock.__policyWarned = true;
                    console.info('PTT Wake Lock недоступен в текущем контейнере Telegram/WebView.');
                }
                return;
            }
            if (document.hidden) return;
            if (pttWakeLock) return;
            pttWakeLock = await navigator.wakeLock.request('screen');
            pttWakeLock.addEventListener('release', () => { pttWakeLock = null; });
        } catch (e) {
            pttWakeLock = null;
        }
    }

    function pttReleaseWakeLock() {
        try { pttWakeLock?.release(); } catch (e) {}
        pttWakeLock = null;
    }

    async function pttEnsureMic() {
        if (pttMediaStream) return pttMediaStream;
        if (!navigator.mediaDevices?.getUserMedia) throw new Error('getUserMedia unsupported');
        pttMediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        return pttMediaStream;
    }

    function pttStartRecording() {
        pttChunks = [];

        const options = {};
        try {
            if (window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) {
                options.mimeType = 'audio/webm;codecs=opus';
            }
        } catch (e) {}

        pttMediaRecorder = new MediaRecorder(pttMediaStream, options);
        pttMediaRecorder.ondataavailable = (e) => {
            if (e.data && e.data.size > 0) pttChunks.push(e.data);
        };
        pttMediaRecorder.onstop = () => {
            try {
                const blob = new Blob(pttChunks, { type: pttMediaRecorder.mimeType || 'audio/webm' });
                pttUpload(blob).catch(() => {});
            } catch (e) {
                pttLogStatus('Ошибка сборки записи');
            }
        };

        pttMediaRecorder.start();
    }

    function pttStopRecording() {
        try {
            if (!pttMediaRecorder) return;
            if (pttMediaRecorder.state !== 'inactive') pttMediaRecorder.stop();
        } catch (e) {}
    }

    async function pttUpload(blob) {
        const fd = new FormData();
        fd.append('userId', pttGetUserId());
        fd.append('name', pttGetName());
        try {
            if (Array.isArray(userLocation) && userLocation.length >= 2) {
                const lat = Number(userLocation[0]);
                const lon = Number(userLocation[1]);
                if (Number.isFinite(lat) && Number.isFinite(lon)) {
                    fd.append('lat', String(lat));
                    fd.append('lon', String(lon));
                }
            }
        } catch (e) {}
        fd.append('audio', blob, `ptt-${Date.now()}.webm`);

        pttLogStatus('Отправка…');

        const resp = await fetch(`${pttBaseUrl()}/ptt/upload`, { method: 'POST', body: fd });
        if (!resp.ok) {
            const t = await resp.text().catch(() => '');
            if (resp.status === 409) {
                pttLogStatus('Канал занят');
            } else if (resp.status === 403) {
                pttLogStatus('Вы забанены в рации');
                pttBanned = true;
            } else {
                pttLogStatus(`Ошибка upload: ${resp.status}`);
            }
            console.warn('ptt upload error:', resp.status, t);
            pttSetHoldButtonState('idle');
            return;
        }

        pttLogStatus('Отправлено ✅');
        pttStartCooldown();
    }

    function pttClearAutoStopTimer() {
        if (pttRecordAutoStopTimer) {
            clearTimeout(pttRecordAutoStopTimer);
            pttRecordAutoStopTimer = null;
        }
    }

    function pttCanTalkNow() {
        if (pttBanned) return false;
        if (Date.now() < pttCooldownUntil) return false;
        const myId = pttGetUserId();
        if (pttChannelBusy && String(pttChannelBusy.userId) !== String(myId)) return false;
        return true;
    }

    async function pttPressStart() {
        if (pttIsPressed) return;
        if (!pttCanTalkNow()) {
            pttSetHoldButtonState('idle');
            return;
        }

        try {
            await pttRequestWakeLock();
            await pttEnsureMic();
            pttConnectSocket();
            // Важно: сначала отправляем hello (userId/name), потом ptt:start.
            // Иначе сервер может зафиксировать имя как "Неизвестный".
            try { pttSocket?.emit('hello', { userId: pttGetUserId(), name: pttGetName() }); } catch (e) {}
            try { pttSocket?.emit('ptt:start'); } catch (e) {}

            pttIsPressed = true;
            pttSetHoldButtonState('pressed');
            pttLogStatus('Запись…');

            pttStartRecording();

            pttClearAutoStopTimer();
            pttRecordAutoStopTimer = setTimeout(() => {
                if (!pttIsPressed) return;
                pttPressEnd(true);
            }, PTT_MAX_RECORD_MS);
        } catch (e) {
            pttIsPressed = false;
            pttLogStatus('Нет доступа к микрофону');
            pttSetHoldButtonState('idle');
        }
    }

    function pttPressEnd(auto = false) {
        if (!pttIsPressed) return;
        pttIsPressed = false;
        pttClearAutoStopTimer();

        try { pttSocket?.emit('ptt:stop'); } catch (e) {}
        pttStopRecording();

        pttLogStatus(auto ? '7 сек — отправляю…' : 'Отпущено — отправляю…');
        pttSetHoldButtonState('idle');
    }

    function pttAttachHoldHandlers() {
        const btn = pttEl('pttHoldBtn');
        if (!btn) return;

        btn.addEventListener('mousedown', (e) => { e.preventDefault(); pttPressStart(); });
        window.addEventListener('mouseup', () => pttPressEnd(false));
        btn.addEventListener('touchstart', (e) => { e.preventDefault(); pttPressStart(); }, { passive: false });
        window.addEventListener('touchend', () => pttPressEnd(false));
        btn.addEventListener('mouseleave', () => pttPressEnd(false));
    }

    function pttSetFabTalkingUi(isTalking) {
        const fab = document.getElementById('pttFabBtn');
        if (!fab) return;
        fab.classList.toggle('talking', !!isTalking);
    }

    function pttAttachFabHandlers() {
        const fab = document.getElementById('pttFabBtn');
        if (!fab || fab.__pttBound) return;
        fab.__pttBound = true;

        const onDown = (e) => {
            try { e.preventDefault(); } catch (err) {}
            tryVibrate(18);
            // UI сразу (чтобы было видно нажатие)
            pttSetFabTalkingUi(true);
            // Стартуем запись/канал
            pttPressStart();
            // UI переключаем с небольшой задержкой (pttPressStart async)
            setTimeout(() => { try { pttSetFabTalkingUi(!!pttIsPressed); } catch(e) {} }, 30);
            // если не стартануло (нет микрофона/ошибка) — вернём UI
            setTimeout(() => { try { if (!pttIsPressed) pttSetFabTalkingUi(false); } catch(e) {} }, 450);
        };

        const onUp = (e) => {
            try { e.preventDefault(); } catch (err) {}
            pttPressEnd(false);
            pttSetFabTalkingUi(false);
        };

        fab.addEventListener('pointerdown', onDown, { passive: false });
        fab.addEventListener('pointerup', onUp, { passive: false });
        fab.addEventListener('pointercancel', onUp, { passive: false });
        fab.addEventListener('pointerleave', () => {
            try { pttPressEnd(false); } catch(e) {}
            pttSetFabTalkingUi(false);
        });

        // fallback на старые браузеры
        fab.addEventListener('touchstart', onDown, { passive: false });
        fab.addEventListener('touchend', onUp, { passive: false });
        fab.addEventListener('mousedown', onDown);
        window.addEventListener('mouseup', () => { try { onUp({ preventDefault(){} }); } catch(e) {} });
    }

    // На всякий случай — привяжем обработчики сразу (в initApp тоже вызывается)
    try { pttAttachFabHandlers(); } catch(e) {}

    function pttEnsureReporterId() {
        if (pttReporterId) return pttReporterId;
        try {
            const k = 'ptt:reporterId';
            const stored = localStorage.getItem(k);
            if (stored) { pttReporterId = stored; return stored; }
            const gen = String(Math.random()).slice(2, 12);
            localStorage.setItem(k, gen);
            pttReporterId = gen;
            return gen;
        } catch (e) {
            pttReporterId = 'anon';
            return 'anon';
        }
    }

    async function pttComplainLast() {
        if (!pttLastMessageId) return;
        const btn = pttEl('pttComplainBtn');
        if (btn) btn.disabled = true;
        try {
            const resp = await fetch(`${pttBaseUrl()}/ptt/complaint`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ reporterId: pttEnsureReporterId(), messageId: pttLastMessageId })
            });
            const data = await resp.json().catch(() => null);
            if (!resp.ok) {
                pttLogStatus('Жалоба не отправлена');
                return;
            }
            pttLogStatus(`Жалоба отправлена (счётчик: ${data?.count || 0})`);
        } catch (e) {
            pttLogStatus('Жалоба не отправлена');
        } finally {
            setTimeout(() => { if (btn) btn.disabled = false; }, 1500);
        }
    }

    async function pttPlayIncoming(msg) {
        const speakerName = String(msg?.speakerName || 'Кто-то');
        const url = String(msg?.url || '');
        if (!url) return;

        // Голосовой штурман: сначала имя
        try {
            if (typeof aiSpeak === 'function') aiSpeak(`На связи ${speakerName}`);
            else if (window.speechSynthesis) {
                const u = new SpeechSynthesisUtterance(`На связи ${speakerName}`);
                u.lang = 'ru-RU'; u.rate = 1.0;
                window.speechSynthesis.speak(u);
            }
        } catch (e) {}

        // небольшая пауза, чтобы не слипалось
        await new Promise(r => setTimeout(r, 450));

        try {
            await pttRequestWakeLock();
            const a = new Audio(`${pttBaseUrl()}${url.startsWith('/') ? '' : '/'}${url}`);
            a.volume = 1.0;
            await a.play();
        } catch (e) {
            console.warn('PTT play blocked:', e);

            // Если autoplay заблокирован — покажем in-app уведомление.
            try {
                if (typeof showInAppNotification === 'function') {
                    showInAppNotification({
                        title: `🎙️ Рация: ${speakerName}`,
                        body: 'Новая реплика. Откройте 🎙️ «Рация», чтобы прослушать.',
                        priority: 'high'
                    });
                }
            } catch (e2) {}
        }
    }

    function pttConnectSocket() {
        if (pttSocket) return;
        if (typeof io !== 'function') {
            pttLogStatus('Socket.io недоступен');
            return;
        }

        pttSocket = io(pttBaseUrl(), { transports: ['websocket', 'polling'] });

        pttSocket.on('connect', () => {
            // hello отправляем сразу при connect, чтобы имя было известно серверу
            try { pttSocket.emit('hello', { userId: pttGetUserId(), name: pttGetName() }); } catch (e) {}
            // сразу отправим координаты, если они уже есть
            try {
                if (Array.isArray(userLocation) && userLocation.length >= 2) {
                    const lat = Number(userLocation[0]);
                    const lon = Number(userLocation[1]);
                    if (Number.isFinite(lat) && Number.isFinite(lon)) {
                        pttSocket.emit('ptt:loc', { lat, lon });
                    }
                }
            } catch (e) {}
            pttLogStatus('Подключено к рации');
            pttSetHoldButtonState('idle');
            pttRequestWakeLock();
        });

        pttSocket.on('ptt:state', (state) => {
            pttChannelBusy = state?.busy || null;
            pttBanned = !!state?.banned;
            pttSetHoldButtonState(pttIsPressed ? 'pressed' : 'idle');
        });

        pttSocket.on('ptt:busy', (busy) => {
            pttChannelBusy = busy || null;
            pttSetHoldButtonState(pttIsPressed ? 'pressed' : 'idle');
        });

        pttSocket.on('ptt:free', () => {
            pttChannelBusy = null;
            pttSetHoldButtonState(pttIsPressed ? 'pressed' : 'idle');
        });

        pttSocket.on('ptt:denied', (info) => {
            if (info?.reason === 'banned') {
                pttBanned = true;
                pttLogStatus('Вы забанены в рации');
            } else if (info?.reason === 'busy') {
                pttChannelBusy = info?.busy || pttChannelBusy;
                pttLogStatus('Канал занят');
            }
            pttSetHoldButtonState('idle');
        });

        pttSocket.on('ptt:banned', (info) => {
            if (String(info?.userId) === String(pttGetUserId())) {
                pttBanned = true;
                pttLogStatus('Автобан в рации на 30 минут');
                pttSetHoldButtonState('idle');
            }
        });

        pttSocket.on('ptt:message', (msg) => {
            pttLastMessageId = String(msg?.id || '') || null;
            const btn = pttEl('pttComplainBtn');
            if (btn) btn.disabled = !pttLastMessageId;

            // своё не воспроизводим
            if (String(msg?.speakerId) === String(pttGetUserId())) return;
            pttPlayIncoming(msg).catch(() => {});
        });
    }

    function pttDisconnectSocket() {
        try { pttSocket?.disconnect(); } catch (e) {}
        pttSocket = null;
    }

    function openPttModal() {
        const target = document.querySelector('.target');
        if (target) target.style.visibility = 'hidden';
        const modal = pttEl('pttModal');
        if (modal) modal.classList.add('active');
        pttAttachHoldHandlers();
        const complainBtn = pttEl('pttComplainBtn');
        if (complainBtn && !complainBtn.__pttBound) {
            complainBtn.__pttBound = true;
            complainBtn.addEventListener('click', pttComplainLast);
        }
        pttConnectSocket();
        pttSetHoldButtonState('idle');
        pttRequestWakeLock();

        // Если уже есть последняя реплика — включим кнопку жалобы
        try {
            const btn = pttEl('pttComplainBtn');
            if (btn) btn.disabled = !pttLastMessageId;
        } catch (e) {}
    }

    function closePttModal() {
        const target = document.querySelector('.target');
        if (target) target.style.visibility = 'visible';
        const modal = pttEl('pttModal');
        if (modal) modal.classList.remove('active');
        try { pttPressEnd(false); } catch(e) {}
        pttReleaseWakeLock();
    }

    document.addEventListener('visibilitychange', () => {
        try {
            if (!document.hidden) pttRequestWakeLock();
            else pttReleaseWakeLock();
        } catch (e) {}
    });

    // Функция удаления одного сообщения
    async function deleteMessage(messageId, authorId) {
        try {
            const msgId = parseInt(messageId);
            const authId = parseInt(authorId);
            
            const isOwnMessage = authId === uid;
            const isAdminDeleting = isAdmin && authId !== uid;
            
            if (!isOwnMessage && !isAdminDeleting) {
                alert('Вы можете удалять только свои сообщения');
                return;
            }
            
            if (!confirm('Удалить это сообщение?')) return;
            
            const { error } = await _sb.from('messages').delete().eq('id', msgId);
            if (error) {
                console.error('Ошибка удаления:', error);
                alert('Ошибка удаления: ' + (error?.message || 'неизвестная ошибка'));
                return;
            }
            console.log('✅ Сообщение удалено:', msgId);
            await loadChatMessages();
        } catch (e) {
            console.error('Ошибка при удалении:', e);
            alert('Ошибка удаления: ' + (e?.message || e));
        }
    }

    // Функция удаления всех сообщений пользователя (только админ)
    async function deleteAllUserMessages(userId, userName) {
        if (!isAdmin) {
            alert('Только администратор может удалять сообщения других пользователей');
            return;
        }
        
        if (!confirm(`Удалить все сообщения пользователя "${userName}"? Это действие необратимо.`)) return;
        
        try {
            const { error } = await _sb.from('messages').delete().eq('author_id', userId);
            if (error) {
                alert('Ошибка: ' + (error?.message || 'неизвестная ошибка'));
                return;
            }
            alert('✅ Все сообщения пользователя удалены');
            await loadChatMessages();
        } catch (e) {
            alert('Ошибка: ' + (e?.message || e));
        }
    }

    // Функция отправки жалобы на пользователя
    async function reportUser(userId, userName, reportType = 'сообщение', content = '') {
        if (!uid) {
            alert('Пожалуйста, авторизуйтесь через Telegram');
            const overlay = document.getElementById('tgAuthOverlay'); if (overlay) overlay.style.display = 'flex';
            return;
        }
        if (!currentDriver) {
            alert('Пожалуйста, завершите регистрацию через Telegram перед отправкой жалобы');
            openRegistrationModal();
            return;
        }

        const reason = prompt(`Пожаловаться на пользователя "${userName}"?\n\nУкажите причину жалобы:\n\nПримеры: "Оскорбления", "Спам", "Ложные метки", "Мошенничество"`, '');
        
        if (reason === null) return; // Отмена
        if (!reason.trim()) return alert('Укажите причину жалобы');
        
        try {
            // Попытка записать жалобу в таблицу reports
            const reportData = {
                reporter_id: uid,
                reported_user_id: userId,
                reported_user_name: userName,
                report_type: reportType,
                reason: reason.trim(),
                content: content,
                status: 'new',
                created_at: new Date().toISOString()
            };
            
            const { error: reportError } = await _sb.from('reports').insert([reportData]);
            
            if (reportError) {
                console.error('Ошибка при записи в таблицу reports:', reportError);
                
                // Если таблица не существует - сохраняем в альтернативную таблицу или логируем
                if (reportError.message && reportError.message.includes('reports')) {
                    console.warn('Таблица reports не существует. Попытаемся сохранить в messages...');
                    
                    // Альтернативный вариант - сохраняем как специальное сообщение в чат
                    const adminMessage = {
                        author_id: -1,
                        author_name: '🚨 АДМИН АЛЕРТ',
                        text: `📋 ЖАЛОБА: ${reason.trim()}\n👤 На: ${userName} (ID: ${userId})\n📝 Тип: ${reportType}\n📌 От: пользователя`,
                        created_at: new Date().toISOString()
                    };
                    
                    const { error: msgError } = await _sb.from('messages').insert([adminMessage]);
                    
                    if (msgError) {
                        alert('⚠️ Ошибка при отправке жалобы: ' + (msgError?.message || 'неизвестная ошибка'));
                        console.error('Ошибка при сохранении альтернативной жалобы:', msgError);
                        return;
                    }
                }
            }
            
            alert('✅ Спасибо за сообщение! Ваша жалоба успешно отправлена администраторам.');
            console.log('✅ Жалоба отправлена:', reportData);
        } catch (e) {
            console.error('Ошибка при отправке жалобы:', e);
            alert('❌ Ошибка при отправке жалобы: ' + (e?.message || e));
        }
    }

    // Функция быстрого меню модерации для админа (одним кликом на юзера)
    async function showUserModeratorMenu(userId, userName, event) {
        if (!isAdmin) {
            reportUser(userId, userName, 'сообщение', '');
            return;
        }

        // Защита от undefined event
        if (!event) {
            event = { pageX: window.innerWidth / 2, pageY: window.innerHeight / 2, stopPropagation: () => {} };
        }

        if (event.stopPropagation) {
            event.stopPropagation();
        }

        // Удаляем старое меню если оно есть
        const oldMenu = document.querySelector('.moderator-menu');
        if (oldMenu) oldMenu.remove();

        // Создаём меню
        const menu = document.createElement('div');
        menu.className = 'moderator-menu';
        menu.style.cssText = `
            position: fixed;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 3000;
            border: 2px solid #ff9500;
            overflow: hidden;
        `;
        menu.style.left = (event.pageX || window.innerWidth / 2) + 'px';
        menu.style.top = (event.pageY || window.innerHeight / 2) + 'px';

        // Функция для создания кнопки меню
        const createMenuBtn = (text, color, callback) => {
            const btn = document.createElement('button');
            btn.style.cssText = `
                display: block;
                width: 100%;
                border: none;
                padding: 10px 15px;
                text-align: left;
                cursor: pointer;
                background: white;
                color: ${color};
                font-weight: 600;
                border-bottom: 1px solid #eee;
                font-size: 13px;
            `;
            btn.innerHTML = text;
            btn.onmouseover = () => btn.style.background = '#f9f9f9';
            btn.onmouseout = () => btn.style.background = 'white';
            btn.onclick = callback;
            return btn;
        };

        // Кнопка удаления всех сообщений пользователя
        menu.appendChild(createMenuBtn('🗑️ Удалить все сообщения', '#ff3b30', () => {
            deleteAllUserMessages(userId, userName);
            menu.remove();
        }));

        // Кнопка удаления всех меток пользователя
        menu.appendChild(createMenuBtn('📍 Удалить все метки', '#ff9500', () => {
            deleteAllUserMarkers(userId, userName);
            menu.remove();
        }));

        // Кнопка отправки жалобы
        menu.appendChild(createMenuBtn('⚠️ Пожаловаться', '#007aff', () => {
            reportUser(userId, userName, 'сообщение', '');
            menu.remove();
        }));

        // Кнопка просмотра профиля
        menu.appendChild(createMenuBtn('👤 Открыть профиль', '#34c759', () => {
            // TODO: Реализовать открытие профиля если есть функция
            alert('Функция просмотра других профилей пока не доступна');
            menu.remove();
        }));

        // Добавляем меню в документ
        document.body.appendChild(menu);

        // Закрываем меню при клике вне его
        setTimeout(() => {
            document.addEventListener('click', function closeMenu(e) {
                if (!menu.contains(e.target)) {
                    menu.remove();
                    document.removeEventListener('click', closeMenu);
                }
            });
        }, 0);
    }

    // Функция модерации пользователя из профиля
    async function moderateUserFromProfile(userId, userName, banType) {
        if (!isAdmin) {
            alert('Только администратор может модерировать пользователей');
            return;
        }

        // Закрываем профиль
        closeProfileModal();

        // Устанавливаем текущего пользователя для модерации
        currentModeratingUserId = userId;
        document.getElementById('modUserName').textContent = userName || 'Аноним';
        document.getElementById('modUserId').textContent = userId;

        if (banType === 'temp') {
            // Открываем модальное окно выбора длительности
            openBanDurationModal();
        } else {
            // Открываем модальное окно модерации для постоянного бана
            document.getElementById('moderatorModal').classList.add('active');
            
            // Сразу вызываем функцию постоянного бана
            setTimeout(() => {
                banUser('permanent');
            }, 100);
        }
    }

    // Функция удаления всех меток пользователя
    async function deleteAllUserMarkers(userId, userName) {
        if (!isAdmin) {
            alert('Только администратор может удалять метки других пользователей');
            return;
        }

        if (!confirm(`Удалить все метки пользователя "${userName}"? Это действие необратимо.`)) return;

        try {
            const { error } = await expireMarkersByAuthor(userId);
            if (error) {
                alert('Ошибка: ' + (error?.message || 'неизвестная ошибка'));
                return;
            }
            alert('✅ Все метки пользователя удалены. Обновите карту.');
            // Перезагружаем маркеры если функция существует
            if (typeof loadMarkers === 'function') {
                loadMarkers();
            }
        } catch (e) {
            alert('Ошибка: ' + (e?.message || e));
        }
    }

    // Версия меню модерации для маркеров (вызывается из balloonContent)
    window.showUserModeratorMenuFromMarker = (userId, userName) => {
        if (!window.isAdmin) {
            window.reportUser(userId, userName, 'маркер', '');
            return;
        }

        // Закрываем текущий балун
        if (window.myMap && window.myMap.balloon) {
            window.myMap.balloon.close();
        }

        // Показываем меню через небольшую задержку
        setTimeout(() => {
            window.showUserModeratorMenu(userId, userName, new MouseEvent('click', {
                bubbles: true,
                cancelable: true,
                view: window,
                pageX: window.innerWidth / 2,
                pageY: window.innerHeight / 2
            }));
        }, 100);
    };

    // Переменная для интервала обновления чата
    let chatUpdateInterval = null;

    // Функция загрузки сообщений чата
    async function loadChatMessages() {
        try {
            // Ограничиваем количество сообщений до 30 для быстрости
            // Ограничиваем кол-во сообщений до 30 для быстроты рендера
            const { data: messages } = await _sb.from('messages').select('*').order('created_at', { ascending: true }).limit(30);
            const container = document.getElementById('chatMessages');

            if (!messages || messages.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: var(--gray); padding: 20px;">Нет сообщений. Будьте первым!</div>';
                return;
            }

            // Собираем уникальные авторы и получаем их данные (с кэшированием)
            const authorIds = Array.from(new Set(messages.map(m => String(m.author_id))));
            let authorsMap = {};
            const now = Date.now();
            
            // Проверяем, не устарел ли кэш
            if (now - authorsCacheTime > CACHE_DURATION) {
                authorsCache = {};
                authorsCacheTime = now;
            }
            
            // Берём из кэша то что есть
            const cachedIds = authorIds.filter(id => authorsCache[id]);
            const uncachedIds = authorIds.filter(id => !authorsCache[id]);
            
            // Копируем кэшированные данные
            cachedIds.forEach(id => { authorsMap[id] = authorsCache[id]; });
            
            // Загружаем только некэшированные
            if (uncachedIds.length > 0) {
                try {
                    const { data: authors } = await _sb.from('drivers').select('user_id,likes_sum,is_trusted,avatar_url').in('user_id', uncachedIds);
                    if (authors) {
                        authors.forEach(a => {
                            const id = String(a.user_id);
                            authorsMap[id] = a;
                            authorsCache[id] = a; // Кэшируем
                        });
                    }
                } catch (e) {
                    console.warn('Не удалось загрузить данные профилей авторов:', e?.message || e);
                }
            }

            // Утилита: переводим likes_sum в 0..5 звёзд
            function likesToStars(likes) {
                const n = Number(likes) || 0;
                if (n <= 0) return 0;
                if (n >= 100) return 5;
                if (n >= 60) return 4;
                if (n >= 30) return 3;
                if (n >= 10) return 2;
                return 1;
            }

            // Рендерим сообщения с бейджами-звёздами рядом с именем
            container.innerHTML = '';
            messages.forEach(msg => {
                const isOwn = String(msg.author_id) === String(uid);
                const canDelete = isOwn || isAdmin;
                const messageEl = document.createElement('div');
                messageEl.className = `chat-message ${isOwn ? 'own' : 'other'}`;
                messageEl.style.position = 'relative';

                let photoHTML = '';
                const safeMsgPhotoUrl = sanitizeMediaUrl(msg.photo_url);
                if (safeMsgPhotoUrl) {
                    const escapedPhotoUrl = safeMsgPhotoUrl.replace(/'/g, "\\'");
                    photoHTML = `<img src="${safeMsgPhotoUrl}" class="chat-message-photo" onclick="openPhotoViewer('${escapedPhotoUrl}')" title="Нажмите для увеличения" style="display: block; margin-top: 8px; max-width: 100%;">`;
                }

                const timestamp = new Date(msg.created_at).toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' });

                let deleteButtonHTML = '';
                if (canDelete) {
                    deleteButtonHTML = `<button class="chat-delete-btn" data-msg-id="${msg.id}" data-author-id="${msg.author_id}" style="position: absolute; top: 5px; right: 5px; background: #ff3b30; color: white; border: none; border-radius: 4px; padding: 2px 6px; font-size: 10px; cursor: pointer; transition: all 0.2s;" title="Удалить сообщение">❌</button>`;
                }

                // Бейдж звёзд
                const authorInfo = authorsMap[String(msg.author_id)] || {};
                const likesSum = authorInfo.likes_sum || 0;
                const isTrusted = !!authorInfo.is_trusted;
                const starsCount = likesToStars(likesSum);
                let starsHTML = '';
                for (let i = 0; i < 5; i++) starsHTML += (i < starsCount) ? '★' : '☆';
                const starsBadge = `<span style="margin-left:8px; color: ${isTrusted ? '#b8860b' : '#f5c542'}; font-weight:700;">${starsHTML}</span>`;

                // Отображаем аватар (фото или emoji)
                let avatarHTML = '';
                const safeAvatarUrl = sanitizeMediaUrl(authorInfo.avatar_url);
                if (safeAvatarUrl) {
                    avatarHTML = `<img src="${safeAvatarUrl}" style="width: 24px; height: 24px; border-radius: 50%; margin-right: 6px; object-fit: cover;">`;
                } else {
                    const avatar = authorInfo.avatar || '👤';
                    avatarHTML = `<span style="margin-right: 6px; font-size: 16px;">${avatar}</span>`;
                }

                messageEl.innerHTML = `
                    ${deleteButtonHTML}
                    ${!isOwn ? `<div class="chat-message-author" style="display: flex; align-items: center; cursor: ${isAdmin ? 'pointer' : 'default'}; ${isAdmin ? 'padding: 4px 8px; border-radius: 6px; transition: all 0.2s; user-select: none;' : ''}" data-user-id="${msg.author_id}" data-user-name="${(msg.author_name || 'Пользователь').replace(/"/g, '&quot;')}">${avatarHTML}<span>${msg.author_name || 'Аноним'}</span> ${starsBadge}</div>` : ''}
                    <div>${msg.text || ''}</div>
                    ${photoHTML}
                    <div class="chat-message-time">${timestamp}</div>
                `;
                
                // Добавляем обработчик клика на имя для админа
                if (isAdmin && !isOwn) {
                    const authorDiv = messageEl.querySelector('.chat-message-author');
                    if (authorDiv) {
                        authorDiv.onclick = (e) => {
                            showUserModeratorMenu(msg.author_id, msg.author_name || 'Пользователь', e);
                        };
                        authorDiv.onmouseover = () => {
                            authorDiv.style.background = '#f0f0f5';
                            authorDiv.style.transform = 'scale(1.02)';
                        };
                        authorDiv.onmouseout = () => {
                            authorDiv.style.background = '';
                            authorDiv.style.transform = 'scale(1)';
                        };
                    }
                }
                container.appendChild(messageEl);
                
                // Добавляем обработчик на кнопку удаления
                const deleteBtn = messageEl.querySelector('.chat-delete-btn');
                if (deleteBtn) {
                    deleteBtn.addEventListener('click', async function(e) {
                        e.stopPropagation();
                        const msgId = this.dataset.msgId;
                        const authorId = this.dataset.authorId;
                        await deleteMessage(msgId, authorId);
                    });
                    deleteBtn.addEventListener('mouseover', function() {
                        this.style.background = '#d32f2b';
                        this.style.transform = 'scale(1.1)';
                    });
                    deleteBtn.addEventListener('mouseout', function() {
                        this.style.background = '#ff3b30';
                        this.style.transform = 'scale(1)';
                    });
                }
                
                // Добавляем обработчик клика на сообщение (если админ)
                if (isAdmin && !isOwn) {
                    messageEl.style.cursor = 'pointer';
                    messageEl.addEventListener('click', function(e) {
                        const author = this.querySelector('[data-user-id]');
                        if (author && !e.target.closest('.chat-delete-btn')) {
                            showChatContextMenu(e, msg, author.dataset.userId, author.dataset.userName);
                        }
                    });
                }
            });

            // Скролим вниз к последнему сообщению
            container.scrollTop = container.scrollHeight;
        } catch (e) {
            console.warn('Ошибка при загрузке сообщений:', e?.message || e);
            document.getElementById('chatMessages').innerHTML = '<div style="text-align: center; color: red; padding: 20px;">Ошибка загрузки сообщений</div>';
        }
    }

    // Функция сжатия изображения (на клиенте)
    async function compressImage(file, maxWidth = 800, maxHeight = 800, quality = 0.7) {
        return new Promise((resolve) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    let width = img.width;
                    let height = img.height;

                    // Масштабируем изображение если оно больше лимита
                    if (width > maxWidth || height > maxHeight) {
                        const ratio = Math.min(maxWidth / width, maxHeight / height);
                        width = width * ratio;
                        height = height * ratio;
                    }

                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);

                    // Сжимаем в JPEG с нужным качеством
                    canvas.toBlob((blob) => {
                        resolve(blob);
                    }, 'image/jpeg', quality);
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        });
    }

    // Функция отправки сообщения в чат
    async function sendChatMessage() {
        tryVibrate(12);
        if (!currentDriver) {
            alert('Пожалуйста, завершите регистрацию через Telegram');
            openRegistrationModal();
            return;
        }
        const messageText = document.getElementById('chatInput').value.trim();
        
        if (!messageText && !selectedChatPhoto) {
            alert('Напишите сообщение или добавьте фото');
            return;
        }

        let photoURL = null;

        // Если есть фото, преобразуем в Base64
        if (selectedChatPhoto) {
            try {
                // Сжимаем изображение
                const compressedBlob = await compressImage(selectedChatPhoto, 800, 800, 0.7);
                
                // Проверяем размер после сжатия (максимум 2MB)
                if (compressedBlob.size > 2 * 1024 * 1024) {
                    alert('❌ Фото слишком большое даже после сжатия. Максимум 2MB.');
                    selectedChatPhoto = null;
                    return;
                }

                // Преобразуем blob в Base64
                const reader = new FileReader();
                await new Promise((resolve, reject) => {
                    reader.onload = function(event) {
                        photoURL = event.target.result; // data:image/jpeg;base64,...
                        console.log('✅ Фото преобразовано в Base64, размер:', photoURL.length);
                        resolve();
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(compressedBlob);
                });
            } catch (e) {
                console.error('❌ Ошибка при обработке фото:', e?.message || e);
                alert('❌ Ошибка обработки фото: ' + (e?.message || e));
                selectedChatPhoto = null;
                return;
            }
        }

        // Вставляем сообщение в БД
        try {
            const messageData = {
                author_id: String(uid || ''),
                author_name: currentDriver?.name || 'Аноним',
                text: messageText || '',
                created_at: new Date().toISOString()
            };

            if (!messageData.author_id) {
                alert('❌ Ошибка: не определен ID пользователя. Перезапустите мини‑приложение.');
                return;
            }
            
            // Добавляем фото только если оно есть
            if (photoURL) {
                messageData.photo_url = photoURL;
            }
            
            const { error } = await _sb.from('messages').insert([messageData]);

            if (!error) {
                console.log('✅ Сообщение отправлено');
                document.getElementById('chatInput').value = '';
                selectedChatPhoto = null;
                document.getElementById('chatPhotoPreview').innerHTML = '';
                await loadChatMessages();
            } else {
                alert('❌ Ошибка отправки: ' + (error?.message || 'неизвестная ошибка'));
                console.error('Ошибка БД:', error);
            }
        } catch (e) {
            alert('❌ Ошибка отправки: ' + (e?.message || e));
            console.error('Ошибка отправки:', e);
        }
    }

    // Обновляет поле last_seen для текущего пользователя (если колонка существует)
    let presenceSupported = true;
    async function updateLastSeen() {
        if (!uid) return;
        if (!presenceSupported) return;
        try {
            const payload = { user_id: uid, last_seen: new Date().toISOString() };
            const { error } = await _sb.from('drivers').upsert([payload], { onConflict: 'user_id' });
            if (error) {
                // Если возникает ошибка, возможно колонки нет — отключаем поддержку
                console.warn('updateLastSeen error:', error.message || error);
                presenceSupported = false;
            }
        } catch (e) {
            console.warn('Ошибка updateLastSeen:', e?.message || e);
            presenceSupported = false;
        }
    }

    // Загружает количество пользователей с last_seen в пределах последних 2 минут
    async function loadOnlineCount() {
        const badge = document.getElementById('onlineCountBadge');
        if (!badge) return;
        if (!presenceSupported) {
            const t = document.getElementById('onlineCountText');
            if (t) t.textContent = 'В сети: N/A';
            else badge.textContent = 'В сети: N/A';
            return;
        }
        try {
            const threshold = new Date(Date.now() - 2*60*1000).toISOString();
            const res = await _sb.from('drivers').select('user_id', { count: 'exact' }).gte('last_seen', threshold);
            const count = res.count || (res.data ? res.data.length : 0);
            const t = document.getElementById('onlineCountText');
            if (t) t.textContent = `В сети: ${count}`;
            else badge.textContent = `В сети: ${count}`;
            try { badge.classList.add('visible'); } catch(e) {}
        } catch (e) {
            console.warn('Ошибка loadOnlineCount:', e?.message || e);
            const t = document.getElementById('onlineCountText');
            if (t) t.textContent = 'В сети: ?';
            else badge.textContent = 'В сети: ?';
            presenceSupported = false;
        }
    }

    // Функция выбора фотографии для чата
    document.addEventListener('change', function(e) {
        if (e.target.id === 'chatPhotoInput') {
            const file = e.target.files[0];
            if (file) {
                // Проверяем тип файла
                if (!file.type.startsWith('image/')) {
                    alert('Пожалуйста, выберите изображение');
                    e.target.value = '';
                    return;
                }
                
                // Проверяем исходный размер (максимум 20MB до сжатия)
                if (file.size > 20 * 1024 * 1024) {
                    alert('Исходное фото слишком большое (максимум 20MB)');
                    e.target.value = '';
                    return;
                }
                
                selectedChatPhoto = file;
                
                // Показываем предпросмотр фото
                const reader = new FileReader();
                reader.onload = (event) => {
                    const preview = document.getElementById('chatPhotoPreview');
                    const previewUrl = sanitizeMediaUrl(event?.target?.result);
                    if (!previewUrl) {
                        preview.innerHTML = '';
                        preview.style.display = 'none';
                        return;
                    }
                    preview.innerHTML = `
                        <div style="position: relative; display: inline-block;">
                            <img src="${previewUrl}" style="max-width: 100px; max-height: 100px; border-radius: 8px;">
                            <button onclick="selectedChatPhoto = null; document.getElementById('chatPhotoPreview').innerHTML = ''; document.getElementById('chatInput').focus();" 
                                style="position: absolute; top: -5px; right: -5px; background: red; color: white; border: none; border-radius: 50%; width: 24px; height: 24px; cursor: pointer; font-size: 14px;">✕</button>
                        </div>
                    `;
                    preview.style.display = 'block';
                };
                reader.readAsDataURL(file);
            }
        }
    });

    // Функция голосования за маркер (лайк/дизлайк)
    window.vote = async (id, isUp) => {
        try {
            // Получаем текущий маркер из БД
            const { data: current } = await _sb.from('markers').select('*').eq('id', id).single();
            if (!current) return;
            // Увеличиваем счетчик лайков или дизлайков
            const upd = isUp ? { votes_up: (current.votes_up || 0) + 1 } : { votes_down: (current.votes_down || 0) + 1 };
            await _sb.from('markers').update(upd).eq('id', id);

            // После успешного голосования пересчитаем суммарные лайки автора и сохраним в drivers
            try {
                const authorId = current.author_id;
                const { data: authorMarkers } = await _sb.from('markers').select('votes_up').eq('author_id', authorId);
                let likesSum = 0;
                if (authorMarkers && authorMarkers.length) likesSum = authorMarkers.reduce((s, r) => s + (r.votes_up || 0), 0);
                const isTrusted = likesSum >= (typeof TRUST_LIKES_THRESHOLD !== 'undefined' ? TRUST_LIKES_THRESHOLD : 20);
                // Пытаемся обновить/вставить в drivers (грейсфул — если колонок нет, просто логируем)
                try {
                    await _sb.from('drivers').upsert([{ user_id: authorId, likes_sum: likesSum, is_trusted: isTrusted }], { onConflict: 'user_id' });
                } catch (err) {
                    console.warn('Не удалось обновить drivers.likes_sum/is_trusted:', err?.message || err);
                }
            } catch (e) {
                console.warn('Ошибка при пересчёте лайков автора:', e?.message || e);
            }
        } catch (e) {
            console.warn('Ошибка при обновлении маркера:', e?.message || e);
        }

        // Пересчёт рейтинга будет выполняться динамически при открытии профиля (из таблицы markers)
        loadMarkers();
    };

    // Функция подтверждения актуальности метки (голосование "Стоят" или "Уехали")
    window.confirmMarker = async (markerId, status, options = {}) => {
        // status: 'stay' или 'leave'
        const silent = !!options?.silent;
        if (!uid) {
            if (!silent) alert('Пожалуйста, авторизуйтесь через Telegram');
            const overlay = document.getElementById('tgAuthOverlay'); if (overlay) overlay.style.display = 'flex';
            return;
        }

        try {
            const { data: markerInfo } = await _sb.from('markers').select('author_id,type').eq('id', markerId).maybeSingle();
            const isAdminMarker = markerInfo && isAdminUserId(markerInfo.author_id);
            if (isAdminMarker && status === 'leave') {
                if (!silent) alert('Эта метка подтверждена администрацией и не удаляется голосами.');
                return;
            }

            // Проверяем, не голосовал ли уже этот пользователь за эту метку
            const { data: existing } = await _sb.from('marker_confirmations')
                .select('id').eq('marker_id', markerId).eq('user_id', uid).maybeSingle();
            
            if (existing) {
                if (!silent) alert(`Вы уже голосовали за эту метку. Один голос на метку.`);
                return;
            }

            // Добавляем голос в таблицу marker_confirmations
            const { error: insertError } = await _sb.from('marker_confirmations').insert([{
                marker_id: markerId,
                user_id: uid,
                status: status,
                created_at: new Date().toISOString()
            }]);

            if (insertError && insertError.code === 'PGRST116') {
                // Таблица marker_confirmations не существует, пытаемся использовать счётчик в markers
                console.warn('Таблица marker_confirmations не существует, используем простой счётчик');
                const { data: marker } = await _sb.from('markers').select('leave_confirmations').eq('id', markerId).single();
                if (marker) {
                    const newCount = (status === 'leave') ? ((marker.leave_confirmations || 0) + 1) : (marker.leave_confirmations || 0);
                    await _sb.from('markers').update({ leave_confirmations: newCount }).eq('id', markerId);
                    
                    // Если достаточно подтверждений - удаляем метку
                    if (newCount >= (typeof MARKER_LEAVE_THRESHOLD !== 'undefined' ? MARKER_LEAVE_THRESHOLD : 3)) {
                        await expireMarkerById(markerId);
                        if (!silent) alert(`✅ Метка удалена - ${newCount} человека подтвердили что объект уехал.`);
                        myMap.balloon.close();
                        loadMarkers();
                        return;
                    }
                }
            } else if (!insertError) {
                let sosBonusText = '';
                if (status === 'stay' && markerInfo?.type === 'sos') {
                    try {
                        const { data: claimData, error: claimError } = await _sb.rpc('claim_sos_help_bonus', { p_marker_id: markerId });
                        if (!claimError && Array.isArray(claimData) && claimData.length > 0 && claimData[0]?.granted) {
                            sosBonusText = ' +50 очков кармы за SOS-помощь';
                        }
                    } catch (e) {
                        console.warn('Не удалось начислить SOS-бонус:', e?.message || e);
                    }
                }

                // Успешно добавили запись, считаем количество "leave" подтверждений
                const { data: confirmations } = await _sb.from('marker_confirmations')
                    .select('id').eq('marker_id', markerId).eq('status', 'leave');
                
                const leaveCount = (confirmations ? confirmations.length : 0);
                
                // Если достаточно подтверждений - удаляем метку
                if (leaveCount >= (typeof MARKER_LEAVE_THRESHOLD !== 'undefined' ? MARKER_LEAVE_THRESHOLD : 3)) {
                    await expireMarkerById(markerId);
                    if (!silent) alert(`✅ Метка удалена - ${leaveCount} человека подтвердили что объект уехал.`);
                    myMap.balloon.close();
                    loadMarkers();
                    return;
                }
                
                // Иначе показываем обновлённый счётчик
                if (status === 'stay') {
                    if (!silent) alert(`✅ Подтверждение принято.${sosBonusText}`);
                } else {
                    if (!silent) alert(`✅ Ваш голос учтён (${leaveCount}/${typeof MARKER_LEAVE_THRESHOLD !== 'undefined' ? MARKER_LEAVE_THRESHOLD : 3} для удаления)`);
                }
                loadMarkers(); // обновляем карту с новым счётчиком
            } else if (insertError) {
                if (!silent) alert('Ошибка при голосовании: ' + (insertError.message || 'неизвестная ошибка'));
            }
        } catch (e) {
            console.warn('Ошибка при подтверждении метки:', e?.message || e);
            if (!silent) alert('Ошибка при голосовании: ' + (e?.message || e));
        }
    };

    // Crowdsourcing quick confirm state
    const CROWD_CONFIRM_COOLDOWN_MS = 10 * 60 * 1000;
    const crowdConfirmState = new Map(); // markerId -> { askedAt, wasNear }
    let crowdConfirmPending = null; // { markerId, markerType }

    function shouldCrowdConfirmType(type) {
        return ['dps', 'patrol', 'specbat', 'motobat', 'cargo_control', 'camera'].includes(String(type || ''));
    }

    function crowdConfirmShow(markerId, markerType, streetName = '') {
        try {
            const wrap = document.getElementById('crowdConfirm');
            if (wrap && wrap.classList.contains('active')) return; // не спамим поверх уже открытого
        } catch (e) {}
        crowdConfirmPending = { markerId, markerType };
        const wrap = document.getElementById('crowdConfirm');
        const title = document.getElementById('crowdConfirmTitle');
        const sub = document.getElementById('crowdConfirmSub');
        const label = getMarkerLabel(markerType);
        const place = String(streetName || '').trim() || 'этот участок';
        if (title) title.textContent = `Проехал ${place}. ${label}: стоят или уехали?`;
        if (sub) sub.textContent = 'Подтверди кнопкой';
        if (wrap) wrap.classList.add('active');
        try { if (typeof aiSpeak === 'function') aiSpeak(`Проехал ${place}. Пост еще на месте или уехали? Подтверди кнопкой`); } catch (e) {}
    }

    function crowdConfirmHide() {
        const wrap = document.getElementById('crowdConfirm');
        if (wrap) wrap.classList.remove('active');
        crowdConfirmPending = null;
    }

    async function crowdConfirmAnswer(isYes) {
        const pending = crowdConfirmPending;
        crowdConfirmHide();
        if (!pending?.markerId) return;
        try {
            await window.confirmMarker(pending.markerId, isYes ? 'stay' : 'leave', { silent: true });
            // маленький in-app фидбек
            try {
                if (typeof showInAppNotification === 'function') {
                    showInAppNotification({
                        title: '✅ Спасибо!',
                        body: isYes ? 'Метка подтверждена' : 'Голос "уехали" учтён',
                        priority: 'low'
                    });
                }
            } catch (e2) {}
        } catch (e) {
            console.warn('crowdConfirmAnswer error:', e?.message || e);
        }
    }

    // expose for inline onclick
    window.crowdConfirmAnswer = crowdConfirmAnswer;
    window.crowdConfirmHide = crowdConfirmHide;

    function formatMinutesRu(min) {
        const m = Math.max(0, Math.round(Number(min) || 0));
        const mod10 = m % 10;
        const mod100 = m % 100;
        let w = 'минут';
        if (mod100 >= 11 && mod100 <= 14) w = 'минут';
        else if (mod10 === 1) w = 'минуту';
        else if (mod10 >= 2 && mod10 <= 4) w = 'минуты';
        return `${m} ${w}`;
    }

    function getMarkerAgeMinutes(marker) {
        try {
            const tsMs = (typeof parseMarkerTimestampToMs === 'function') ? parseMarkerTimestampToMs(marker?.ts) : NaN;
            if (!Number.isFinite(tsMs) || tsMs <= 0) return null;
            const diff = Date.now() - tsMs;
            if (diff < 0) return null;
            return Math.floor(diff / (60 * 1000));
        } catch (e) {
            return null;
        }
    }

    // SOS: отметить "Я в пути" (кто едет помогать)
    window.sosEnroute = async (markerId) => {
        if (!uid) {
            alert('Пожалуйста, авторизуйтесь через Telegram');
            const overlay = document.getElementById('tgAuthOverlay'); if (overlay) overlay.style.display = 'flex';
            return;
        }

        try {
            let token = localStorage.getItem('sb_jwt') || '';
            if (!token) {
                const refreshed = await ensureSupabaseAuth();
                token = refreshed || localStorage.getItem('sb_jwt') || '';
            }

            if (!token) {
                alert('Ошибка: нет токена авторизации');
                return;
            }

            const resp = await fetch(`${SUPABASE_URL}/functions/v1/sos-enroute?action=add`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    Authorization: `Bearer ${token}`
                },
                body: JSON.stringify({ markerId: Number(markerId) })
            });

            if (!resp.ok) {
                let txt = '';
                try { txt = await resp.text(); } catch(e) { txt = ''; }
                alert('Ошибка: ' + (txt || String(resp.status)));
                return;
            }

            alert('🚑 Отмечено! Вы в пути.');
            try { if (myMap && myMap.balloon) myMap.balloon.close(); } catch(e) {}
            loadMarkers();
        } catch (e) {
            console.warn('sosEnroute error:', e?.message || e);
            alert('Ошибка: ' + (e?.message || e));
        }
    };

    // Функция удаления маркера (только для автора)
    window.delMarker = async (id) => {
        if (confirm("Удалить вашу метку?")) {
            await expireMarkerById(id);
            // Закрываем всплывающий балун
            myMap.balloon.close();
            // Обновляем список маркеров на карте
            loadMarkers();
        }
    };

    // Экспорт функций модерации через window для доступа из balloonContent
    window.deleteAllUserMessages = deleteAllUserMessages;
    window.deleteAllUserMarkers = deleteAllUserMarkers;
    window.reportUser = reportUser;
    window.deleteMessage = deleteMessage;

    // Функция открытия ленты событий
    async function openActivityModal(mode) {
        const feed = document.getElementById('activityFeed');
        feed.innerHTML = '<div style="text-align: center; color: var(--gray);">⏳ Загрузка событий...</div>';
        const isDpsSpecbatMonthMode = mode === 'dpsSpecbatMonth';

        initActivityHeatmapUI();
        if (isDpsSpecbatMonthMode) {
            activityHeatmapMode = 'month';
            activityHeatmapType = 'dps_specbat';
            const toggle = document.getElementById('heatmapToggle');
            if (toggle) {
                [...toggle.querySelectorAll('button')].forEach(b => b.classList.toggle('active', b.dataset.mode === 'month'));
            }
            const typeToggle = document.getElementById('heatmapTypeToggle');
            if (typeToggle) {
                [...typeToggle.querySelectorAll('button')].forEach(b => b.classList.toggle('active', b.dataset.type === 'dps_specbat'));
            }
        } else if (mode === 'heatmap') {
            activityHeatmapMode = 'week';
            activityHeatmapType = 'all';
            const toggle = document.getElementById('heatmapToggle');
            if (toggle) {
                [...toggle.querySelectorAll('button')].forEach(b => b.classList.toggle('active', b.dataset.mode === 'week'));
            }
            const typeToggle = document.getElementById('heatmapTypeToggle');
            if (typeToggle) {
                [...typeToggle.querySelectorAll('button')].forEach(b => b.classList.toggle('active', b.dataset.type === 'all'));
            }
        }
        loadActivityHeatmap();
        
        try {
            // Загружаем последние маркеры (события добавления)
            let recentMarkersQuery = _sb.from('markers').select('id,type,ts,author_id');
            if (isDpsSpecbatMonthMode) {
                recentMarkersQuery = recentMarkersQuery.in('type', ['dps', 'specbat']);
            }
            const { data: recentMarkers } = await recentMarkersQuery.order('ts', { ascending: false }).limit(20);
            
            // Загружаем информацию о водителях (имя, рейтинг) для отображения звёзд в ленте
            const { data: drivers } = await _sb.from('drivers').select('user_id,name,likes_sum,is_trusted');
            const driverMap = {};
            const driverInfoMap = {};
            if (drivers) {
                drivers.forEach(d => {
                    driverMap[d.user_id] = d.name || 'Аноним';
                    driverInfoMap[d.user_id] = {
                        name: d.name || 'Аноним',
                        likes_sum: (typeof d.likes_sum !== 'undefined' && d.likes_sum !== null) ? Number(d.likes_sum) : 0,
                        is_trusted: !!d.is_trusted
                    };
                });
            }

            // Вспомогательная функция: переводим likes_sum в 0..5 звёзд
            function likesToStars(n) {
                const v = Number(n) || 0;
                if (v <= 0) return 0;
                if (v >= 100) return 5;
                if (v >= 60) return 4;
                if (v >= 30) return 3;
                if (v >= 10) return 2;
                return 1;
            }
            
            let html = '';
            const typeNames = {
                dps: 'ДПС (Стандарт)',
                patrol: 'Рейд',
                specbat: 'Спецбат',
                motobat: 'Мотобат',
                cargo_control: 'Грузовой контроль',
                sos: 'SOS / Нужна помощь',
                dtp: 'ДТП',
                danger: 'Опасность',
                traffic_jam: 'Пробка / Затор',
                camera: 'Наблюдение',
                works: 'Работы'
            };
            const typeEmoji = {
                dps: '👮',
                patrol: '🚔',
                specbat: '🛡️',
                motobat: '🏍️',
                cargo_control: '🚛',
                sos: '🆘',
                dtp: '💥',
                danger: '⚠️',
                traffic_jam: '🚗',
                camera: '📸',
                works: '🚧'
            };
            
            if (recentMarkers && recentMarkers.length > 0) {
                recentMarkers.forEach(marker => {
                    const driverName = driverMap[marker.author_id] || 'Водитель';
                    const authorInfo = driverInfoMap[marker.author_id] || { name: driverName, likes_sum: 0, is_trusted: false };
                    const typeName = typeNames[marker.type] || marker.type;
                    const icon = typeEmoji[marker.type] || '📍';
                    const time = new Date(marker.ts).toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' });

                    // Рендерим звёзды рядом с именем
                    const starsCount = likesToStars(authorInfo.likes_sum);
                    let starsHTML = '';
                    for (let i = 0; i < 5; i++) starsHTML += (i < starsCount) ? '★' : '☆';
                    const starsBadge = `<span style="margin-left:8px; color: ${authorInfo.is_trusted ? '#b8860b' : '#f5c542'}; font-weight:700;">${starsHTML}</span>`;
                    const trustedMark = authorInfo.is_trusted ? '<span style="color:#b8860b; font-weight:800; margin-left:6px;">⭐</span>' : '';

                    html += `
                        <div class="activity-item">
                            <div><span class="activity-icon">${icon}</span><strong>${driverName}</strong> ${trustedMark} ${starsBadge} добавил ${typeName}</div>
                            <div class="activity-time">🕐 ${time}</div>
                        </div>
                    `;
                });
            } else {
                html = '<div style="text-align: center; color: var(--gray); padding: 20px;">Пока нет событий</div>';
            }
            
            feed.innerHTML = html;
        } catch (e) {
            console.warn('Ошибка при загрузке ленты событий:', e?.message || e);
            feed.innerHTML = '<div style="color: red; padding: 20px;">Ошибка загрузки</div>';
        }
        
        const target = document.querySelector('.target');
        if (target) target.style.visibility = 'hidden';
        document.getElementById('activityModal').classList.add('active');
    }

    let activityHeatmapMode = 'week';
    let activityHeatmapType = 'all';
    let activityHeatmapCache = null;
    let activityHeatmapCachedAt = 0;

    function initActivityHeatmapUI() {
        const toggle = document.getElementById('heatmapToggle');
        if (toggle && !toggle.dataset.bound) {
            toggle.dataset.bound = '1';
            toggle.addEventListener('click', (e) => {
                const btn = e.target.closest('button[data-mode]');
                if (!btn) return;
                activityHeatmapMode = btn.dataset.mode;
                [...toggle.querySelectorAll('button')].forEach(b => b.classList.toggle('active', b === btn));
                renderActivityHeatmap();
            });
        }

        const typeToggle = document.getElementById('heatmapTypeToggle');
        if (typeToggle && !typeToggle.dataset.bound) {
            typeToggle.dataset.bound = '1';
            typeToggle.addEventListener('click', (e) => {
                const btn = e.target.closest('button[data-type]');
                if (!btn) return;
                activityHeatmapType = btn.dataset.type;
                [...typeToggle.querySelectorAll('button')].forEach(b => b.classList.toggle('active', b === btn));
                renderActivityHeatmap();
            });
        }
    }

    async function loadActivityHeatmap(force = false) {
        const summaryEl = document.getElementById('heatmapSummary');
        if (summaryEl) summaryEl.textContent = 'Загрузка...';

        if (!uid) {
            if (summaryEl) summaryEl.textContent = 'Нет данных (не авторизован)';
            activityHeatmapCache = { markers: [], updatedAt: new Date() };
            activityHeatmapCachedAt = Date.now();
            renderActivityHeatmap();
            return;
        }

        const now = Date.now();
        if (!force && activityHeatmapCache && (now - activityHeatmapCachedAt) < 120000) {
            renderActivityHeatmap();
            return;
        }

        try {
            const nowDate = new Date();
            const monthStart = new Date(nowDate);
            monthStart.setDate(nowDate.getDate() - 29);
            monthStart.setHours(0, 0, 0, 0);

            // markers.ts в проекте может быть BIGINT (Date.now()) или TIMESTAMPTZ.
            // Сначала пробуем как миллисекунды, затем fallback на ISO.
            const monthStartMs = monthStart.getTime();

            let markers = [];
            {
                const res = await _sb
                    .from('markers')
                    .select('ts,type')
                    .eq('author_id', uid)
                    .gte('ts', monthStartMs)
                    .order('ts', { ascending: false })
                    .limit(10000);
                if (res?.error) {
                    const res2 = await _sb
                        .from('markers')
                        .select('ts,type')
                        .eq('author_id', uid)
                        .gte('ts', monthStart.toISOString())
                        .order('ts', { ascending: false })
                        .limit(10000);
                    if (res2?.error) {
                        console.warn('Ошибка при загрузке тепловой карты (markers.ts filter):', res2.error?.message || res2.error);
                        markers = [];
                    } else {
                        markers = Array.isArray(res2?.data) ? res2.data : [];
                    }
                } else {
                    markers = Array.isArray(res?.data) ? res.data : [];
                }
            }

            activityHeatmapCache = {
                markers: Array.isArray(markers) ? markers : [],
                updatedAt: nowDate
            };
            activityHeatmapCachedAt = now;
            renderActivityHeatmap();
        } catch (e) {
            console.warn('Ошибка при загрузке тепловой карты:', e?.message || e);
            if (summaryEl) summaryEl.textContent = 'Ошибка загрузки';
        }
    }

    function renderActivityHeatmap() {
        const gridEl = document.getElementById('heatmapGrid');
        const summaryEl = document.getElementById('heatmapSummary');
        if (!gridEl || !summaryEl || !activityHeatmapCache) return;

        const markers = Array.isArray(activityHeatmapCache.markers) ? activityHeatmapCache.markers : [];
        const hours = Array.from({ length: 24 }, (_, i) => i);
        const dayNames = ['Пн', 'Вт', 'Ср', 'Чт', 'Пт', 'Сб', 'Вс'];
        const nowDate = activityHeatmapCache.updatedAt || new Date();
        const nowMs = nowDate.getTime();
        const dayStart = new Date(nowDate);
        dayStart.setHours(0, 0, 0, 0);
        const weekStart = new Date(nowDate);
        weekStart.setDate(nowDate.getDate() - 6);
        weekStart.setHours(0, 0, 0, 0);
        const monthStart = new Date(nowDate);
        monthStart.setDate(nowDate.getDate() - 29);
        monthStart.setHours(0, 0, 0, 0);
        const dayLabels = Array.from({ length: 7 }, (_, i) => {
            const d = new Date(weekStart);
            d.setDate(weekStart.getDate() + i);
            const name = dayNames[(d.getDay() + 6) % 7];
            const dd = String(d.getDate()).padStart(2, '0');
            const mm = String(d.getMonth() + 1).padStart(2, '0');
            return `${name} ${dd}.${mm}`;
        });

        const modeStart = activityHeatmapMode === 'day'
            ? dayStart
            : activityHeatmapMode === 'month'
                ? monthStart
                : weekStart;
        const modeStartMs = modeStart.getTime();
        const allowedTypes = activityHeatmapType === 'dps_specbat' ? new Set(['dps', 'specbat']) : null;

        const scopedMarkers = markers.filter(m => {
            if (!m?.ts) return false;
            const tsMs = parseMarkerTimestampToMs(m.ts);
            if (!Number.isFinite(tsMs)) return false;
            if (tsMs < modeStartMs || tsMs > nowMs) return false;
            if (allowedTypes && !allowedTypes.has(m.type)) return false;
            return true;
        });

        const weekCounts = Array.from({ length: 7 }, () => Array(24).fill(0));
        const rowCounts = Array(24).fill(0);
        const msDay = 24 * 60 * 60 * 1000;

        scopedMarkers.forEach(m => {
            const d = new Date(parseMarkerTimestampToMs(m.ts));
            if (isNaN(d.getTime())) return;
            const hour = d.getHours();
            rowCounts[hour] += 1;
            if (activityHeatmapMode === 'week') {
                const dayOffset = Math.floor((d - weekStart) / msDay);
                if (dayOffset >= 0 && dayOffset < 7) {
                    weekCounts[dayOffset][hour] += 1;
                }
            }
        });

        let max = 0;
        if (activityHeatmapMode === 'week') {
            weekCounts.forEach(row => row.forEach(v => { if (v > max) max = v; }));
        } else {
            rowCounts.forEach(v => { if (v > max) max = v; });
        }

        const colorFor = (value) => {
            if (!value || max <= 0) return '#f0f0f5';
            const alpha = Math.min(0.92, 0.12 + (value / max) * 0.8);
            return `rgba(0,122,255,${alpha.toFixed(3)})`;
        };

        let html = '';
        html += '<div></div>';
        hours.forEach(h => {
            html += `<div class="heatmap-hour">${h}</div>`;
        });

        if (activityHeatmapMode === 'week') {
            weekCounts.forEach((row, rowIndex) => {
                html += `<div class="heatmap-label">${dayLabels[rowIndex]}</div>`;
                row.forEach((v, h) => {
                    const title = `${dayLabels[rowIndex]} ${String(h).padStart(2, '0')}:00 — ${v}`;
                    html += `<div class="heatmap-cell" title="${title}" style="background:${colorFor(v)}"></div>`;
                });
            });
        } else {
            const rowLabel = activityHeatmapMode === 'month' ? '30 дней' : 'Сегодня';
            html += `<div class="heatmap-label">${rowLabel}</div>`;
            rowCounts.forEach((v, h) => {
                const title = `${rowLabel} ${String(h).padStart(2, '0')}:00 — ${v}`;
                html += `<div class="heatmap-cell" title="${title}" style="background:${colorFor(v)}"></div>`;
            });
        }

        gridEl.innerHTML = html;

        const total = scopedMarkers.length;
        const peakCount = rowCounts.reduce((acc, v) => Math.max(acc, v), 0);
        const peakHours = peakCount > 0
            ? rowCounts
                .map((v, h) => ({ v, h }))
                .filter(x => x.v === peakCount)
                .map(x => `${String(x.h).padStart(2, '0')}:00`)
            : [];
        const peakText = peakHours.length ? peakHours.join(', ') : 'нет данных';
        const typeLabel = activityHeatmapType === 'dps_specbat' ? 'ДПС + Спецбат' : 'Все типы';

        if (activityHeatmapMode === 'month') {
            summaryEl.textContent = `${typeLabel} • Всего за 30 дней: ${total} • Пиковое время: ${peakText}`;
        } else if (activityHeatmapMode === 'week') {
            summaryEl.textContent = `${typeLabel} • Всего за 7 дней: ${total} • Пиковое время: ${peakText}`;
        } else {
            summaryEl.textContent = `${typeLabel} • Всего сегодня: ${total} • Пиковое время: ${peakText}`;
        }
    }

    // Функция закрытия ленты событий
    function closeActivityModal() {
        const target = document.querySelector('.target');
        if (target) target.style.visibility = 'visible';
        document.getElementById('activityModal').classList.remove('active');
    }

    // Функция загрузки достижений в профиль
    async function loadAchievements() {
        // Получаем количество меток и очков поддержки пользователя
        const { data: markers } = await _sb.from('markers').select('votes_up, votes_down, ts, type, exp').eq('author_id', uid);
        
        let markersCount = 0;
        let totalLikes = 0;
        let totalVotes = 0;
        
        if (markers) {
            markersCount = markers.length;
            markers.forEach(m => {
                totalLikes += m.votes_up || 0;
                totalVotes += (m.votes_up || 0) + (m.votes_down || 0);
            });
        }

        const sosBonus = await getUserSosBonus(uid);
        totalLikes += sosBonus;

        // Иконки достижений (Cyberpunk): плоские SVG в едином «металлическом» стиле
        function achievementIconSvg(iconKey, completed = false) {
            const stroke = completed ? 'rgba(0,212,255,0.95)' : 'rgba(220,232,245,0.88)';
            const fill = completed ? 'rgba(0,212,255,0.10)' : 'rgba(160,170,190,0.12)';
            const accent = completed ? 'rgba(57,255,20,0.85)' : 'rgba(57,255,20,0.55)';

            const base = (paths) => `
<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
  <g fill="none" stroke="${stroke}" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
    ${paths}
  </g>
</svg>`.trim();

            switch (String(iconKey || '')) {
                case 'markers':
                    return base(`<path d="M12 21s7-4.6 7-11a7 7 0 0 0-14 0c0 6.4 7 11 7 11Z" fill="${fill}" stroke="${stroke}"/>
<path d="M12 10.5a2.2 2.2 0 1 0 0-4.4 2.2 2.2 0 0 0 0 4.4Z"/>
<path d="M7.5 18.2h9" stroke="${accent}"/>`);
                case 'likes':
                    return base(`<path d="M8.5 10.5V20H5.8a1.3 1.3 0 0 1-1.3-1.3v-7a1.3 1.3 0 0 1 1.3-1.2H8.5Z" fill="${fill}"/>
<path d="M8.5 10.5l3.4-6.2c.6-1.1 2.2-.8 2.3.5l.2 4.7H19a2 2 0 0 1 2 2.3l-1 6.5A2 2 0 0 1 18 20H8.5"/>
<path d="M12 12.3h6.6" stroke="${accent}"/>`);
                case 'votes':
                    return base(`<path d="M2.8 12s3.6-6.8 9.2-6.8S21.2 12 21.2 12 17.6 18.8 12 18.8 2.8 12 2.8 12Z" fill="${fill}"/>
<path d="M12 15.2a3.2 3.2 0 1 0 0-6.4 3.2 3.2 0 0 0 0 6.4Z"/>
<path d="M12 10.6v2.2" stroke="${accent}"/>`);
                case 'beta':
                    return base(`<path d="M12 2.8l7 3.7v5.9c0 5.2-3.6 8.3-7 9.8-3.4-1.5-7-4.6-7-9.8V6.5l7-3.7Z" fill="${fill}"/>
<path d="M9 12l2.1 2.1L15.5 9.7" stroke="${accent}"/>`);
                case 'bug':
                    return base(`<path d="M9 9.2a3 3 0 0 1 6 0v1.3H9V9.2Z" fill="${fill}"/>
<path d="M7.2 12h9.6"/>
<path d="M8 14.8c.7 1.6 2.2 2.7 4 2.7s3.3-1.1 4-2.7"/>
<path d="M7.5 7.8 6.2 6.5"/>
<path d="M16.5 7.8l1.3-1.3"/>
<path d="M12 10.5V20" stroke="${accent}"/>`);
                case 'night':
                    return base(`<path d="M15.5 3.4a7.5 7.5 0 1 0 5.1 13.1 6.2 6.2 0 0 1-5.1-13.1Z" fill="${fill}"/>
<path d="M9.2 13.4h.01"/>
<path d="M12.2 9.8h.01" stroke="${accent}"/>
<path d="M14.6 14.9h.01"/>`);
                case 'spark':
                    return base(`<path d="M12 2.5l1.5 6 6 1.5-6 1.5-1.5 6-1.5-6-6-1.5 6-1.5 1.5-6Z" fill="${fill}" stroke="${stroke}"/>
<path d="M19.5 13.5l.7 2.6 2.6.7-2.6.7-.7 2.6-.7-2.6-2.6-.7 2.6-.7.7-2.6Z" stroke="${accent}"/>`);
                case 'flame':
                    return base(`<path d="M12 2.8c2.6 3.2 2.8 5.6 1.6 7.4 2.2-.3 3.7 1.6 3.7 4.2 0 3.7-2.5 6.8-5.3 6.8s-5.3-3.1-5.3-6.8c0-2.4 1.1-4.7 3.5-6.7-.2 1.8.6 3 1.8 3.5C12.9 9.5 13.7 6.6 12 2.8Z" fill="${fill}" stroke="${stroke}"/>
<path d="M12 13.2c1.2 1.2 1.5 2.2 1.2 3.2" stroke="${accent}"/>`);
                default:
                    return base(`<path d="M12 3.2l2.1 5.2 5.6.5-4.2 3.6 1.3 5.4L12 15.1 7.2 18l1.3-5.4-4.2-3.6 5.6-.5L12 3.2Z" fill="${fill}" stroke="${stroke}"/>
<path d="M9 12l2 2 4-4" stroke="${accent}"/>`);
            }
        }
        
        // Достижения
        const achievements = [];
        
        // Первые метки и активность
        if (markersCount >= 1) achievements.push({ iconKey: 'markers', title: 'Первая метка', desc: 'Вы начали помогать сообществу' });
        if (markersCount >= 10) achievements.push({ iconKey: 'markers', title: 'Десяток', desc: '10 меток' });
        if (markersCount >= 50) achievements.push({ iconKey: 'markers', title: 'Половина сотни', desc: '50 меток' });
        if (markersCount >= 100) achievements.push({ iconKey: 'markers', title: 'Столетие', desc: '100 меток' });

        // Карма и доверие
        if (totalLikes >= 10) achievements.push({ iconKey: 'likes', title: 'Полезно', desc: '10 очков кармы от сообщества' });
        if (totalLikes >= 50) achievements.push({ iconKey: 'likes', title: 'Лидер взаимопомощи', desc: 'Высокий вклад в подтверждённые события' });
        if (totalLikes >= 100) achievements.push({ iconKey: 'likes', title: 'Легенда', desc: '100 очков кармы' });

        // Точность и надежность
        if (totalVotes >= 50) achievements.push({ iconKey: 'votes', title: 'Глаз орла', desc: 'Сверхточные метки, которые висят часами' });
        if (totalVotes >= 200) achievements.push({ iconKey: 'votes', title: 'Миротворец', desc: 'Большой вклад в спокойные поездки сообщества' });

        // Дополнительно: загружаем серверные ачивки из таблицы user_achievements
        const serverCounts = {};
        try {
            const { data: serverAchs } = await _sb.from('user_achievements').select('key,created_at').eq('user_id', uid);
            // Считаем повторы по ключу
            if (serverAchs && serverAchs.length > 0) {
                serverAchs.forEach(r => { serverCounts[r.key] = (serverCounts[r.key] || 0) + 1; });

                // Серверные ачивки с новыми эмодзи (SafeDrive 180)
                if (serverCounts['beta_tester']) achievements.push({ iconKey: 'beta', title: 'Первопроходец (Beta-Tester)', desc: 'Статус «олда» — был с нами на ЗБТ' });
                if (serverCounts['bug_report']) {
                    achievements.push({ iconKey: 'bug', title: 'Охтник за багами', desc: `Помог чистить код и звуки: ${serverCounts['bug_report']}` });
                    if (serverCounts['bug_report'] >= 5) {
                        achievements.push({ iconKey: 'bug', title: 'Сын Жириновского', desc: 'Обладатель эксклюзивной озвучки' });
                        // Открываем дерзкий стиль локально
                        try { localStorage.setItem('cheekyUnlocked', 'true'); } catch(e){}
                    }
                }
                if (serverCounts['ghost_catcher']) achievements.push({ iconKey: 'night', title: 'Ночной патруль', desc: `Активность в темное время суток` });
                if (serverCounts['night_patrol']) achievements.push({ iconKey: 'spark', title: 'Суетолог', desc: 'Аномально высокая активность' });
                if (serverCounts['phantom_racer']) achievements.push({ iconKey: 'flame', title: 'Призрачный гонщик', desc: 'Вовремя затормозил после уведомления' });
            }
            // Сохраняем глобально для визуализации метки
            try { currentAchievementCounts = serverCounts; } catch(e){}
        } catch (e) {
            console.warn('Не удалось загрузить серверные ачивки:', e?.message || e);
        }

        // Определяем "звание" (статус)
        let title = '🚗 Новичок';
        if (markersCount >= 10) title = '🚙 Активный водитель';
        if (markersCount >= 50) title = '🏎️ Опытный водитель';
        if (markersCount >= 100) title = '🏆 Навигатор-профи';
        if (totalLikes >= 50) title = '👑 Лидер взаимопомощи';

        // Убираем дубликаты по заголовку + подставляем SVG-иконки
        const uniq = [];
        const seen = new Set();
        achievements.forEach(a => {
            if (seen.has(a.title)) return;
            seen.add(a.title);
            uniq.push({
                icon: achievementIconSvg(a.iconKey, true),
                title: a.title,
                desc: a.desc
            });
        });

        // Полный список достижений с прогрессом
        const allAchievements = [
            { key: 'markers_1', iconKey: 'markers', title: 'Первая метка', desc: 'Вы начали помогать сообществу', required: 1, progress: markersCount, metric: 'меток' },
            { key: 'markers_10', iconKey: 'markers', title: 'Десяток', desc: '10 меток', required: 10, progress: markersCount, metric: 'меток' },
            { key: 'markers_50', iconKey: 'markers', title: 'Половина сотни', desc: '50 меток', required: 50, progress: markersCount, metric: 'меток' },
            { key: 'markers_100', iconKey: 'markers', title: 'Столетие', desc: '100 меток', required: 100, progress: markersCount, metric: 'меток' },
            { key: 'likes_10', iconKey: 'likes', title: 'Полезно', desc: '10 очков кармы от сообщества', required: 10, progress: totalLikes, metric: 'кармы' },
            { key: 'likes_50', iconKey: 'likes', title: 'Лидер взаимопомощи', desc: 'Высокий вклад в подтверждённые события', required: 50, progress: totalLikes, metric: 'кармы' },
            { key: 'likes_100', iconKey: 'likes', title: 'Легенда', desc: '100 очков кармы', required: 100, progress: totalLikes, metric: 'кармы' },
            { key: 'votes_50', iconKey: 'votes', title: 'Глаз орла', desc: 'Сверхточные метки, которые висят часами', required: 50, progress: totalVotes, metric: 'голосов' },
            { key: 'votes_200', iconKey: 'votes', title: 'Миротворец', desc: 'Большой вклад в спокойные поездки сообщества', required: 200, progress: totalVotes, metric: 'голосов' },
            { key: 'beta_tester', iconKey: 'beta', title: 'Первопроходец (Beta-Tester)', desc: 'Статус «олда» — был с нами на ЗБТ', required: 1, progress: serverCounts['beta_tester'] || 0, metric: 'раз' },
            { key: 'bug_report_1', iconKey: 'bug', title: 'Охтник за багами', desc: 'Помог чистить код и звуки', required: 1, progress: serverCounts['bug_report'] || 0, metric: 'отчетов' },
            { key: 'bug_report_5', iconKey: 'bug', title: 'Сын Жириновского', desc: 'Обладатель эксклюзивной озвучки', required: 5, progress: serverCounts['bug_report'] || 0, metric: 'отчетов' },
            { key: 'ghost_catcher', iconKey: 'night', title: 'Ночной патруль', desc: 'Активность в темное время суток', required: 1, progress: serverCounts['ghost_catcher'] || 0, metric: 'раз' },
            { key: 'night_patrol', iconKey: 'spark', title: 'Суетолог', desc: 'Аномально высокая активность', required: 1, progress: serverCounts['night_patrol'] || 0, metric: 'раз' },
            { key: 'phantom_racer', iconKey: 'flame', title: 'Призрачный гонщик', desc: 'Вовремя затормозил после уведомления', required: 1, progress: serverCounts['phantom_racer'] || 0, metric: 'раз' }
        ];

        allAchievements.forEach(a => {
            a.completed = a.progress >= a.required;
            a.icon = achievementIconSvg(a.iconKey, a.completed);
        });
        const completedCount = allAchievements.filter(a => a.completed).length;
        const totalCount = allAchievements.length;

        return { achievements: uniq, title, markersCount, totalLikes, totalVotes, allAchievements, completedCount, totalCount };
    }

    // Утилита: гарантированно присвоить одну ачивку пользователю (если ещё нет)
    async function ensureUserAchievement(userId, key) {
        if (!userId || !key) return;
        try {
            const { data: exists } = await _sb.from('user_achievements').select('id').eq('user_id', String(userId)).eq('key', key).maybeSingle();
            if (!exists) {
                await _sb.from('user_achievements').insert([{ user_id: String(userId), key }]);
                console.log(`🏅 Присвоена ачивка ${key} пользователю ${userId}`);
            }
        } catch (e) {
            console.warn('ensureUserAchievement error:', e?.message || e);
        }
    }

    // Админ-функция: присвоить ачивку множеству пользователей (batch)
    async function grantAchievementToUsers(key, userIds = []) {
        if (!window.isAdmin) { console.warn('Недостаточно прав (isAdmin=false)'); return; }
        if (!key || !Array.isArray(userIds) || userIds.length === 0) return;
        try {
            const rows = userIds.map(id => ({ user_id: String(id), key }));
            // Используем upsert с игнорированием дубликатов
            const { error } = await _sb.from('user_achievements').upsert(rows, { onConflict: 'user_id,key', ignoreDuplicates: true });
            if (error) throw error;
            console.log(`🏅 Ачивка ${key} присвоена ${userIds.length} пользователям`);
        } catch (e) {
            console.warn('grantAchievementToUsers error:', e?.message || e);
            throw e; // Пробрасываем ошибку для обработки в UI
        }
    }

    // Удобная обёртка для присвоения beta_tester через консоль или админку
    window.grantBetaToIds = function(ids) { return grantAchievementToUsers('beta_tester', ids); };

    // UI: массовая выдача из поля в админ-панели
    async function grantBetaFromInput() {
        const el = document.getElementById('bulkBetaIds');
        const status = document.getElementById('bulkBetaStatus');
        if (!el) return;
        let raw = (el.value || '').trim();
        if (!raw) { status.textContent = 'Введите хотя бы один user_id.'; return; }
        // Разделители: запятая или пробел или перенос
        const ids = raw.split(/[,\s]+/).map(s => s.trim()).filter(Boolean);
        if (ids.length === 0) { status.textContent = 'Неверный формат ID.'; return; }
        status.textContent = `⏳ Выдаём ачивку ${ids.length} пользователям...`;
        try {
            await grantAchievementToUsers('beta_tester', ids);
            status.textContent = `✅ Ачивка выдана ${ids.length} пользователям.`;
        } catch (e) {
            console.warn(e);
            status.textContent = '❌ Ошибка при выдаче (см. консоль).';
        }
    }

    // Генерация простого WAV (моно) с синусоидой
    function createSineWav(freq = 440, durationSec = 1, volume = 0.5) {
        const sampleRate = 44100;
        const length = sampleRate * durationSec;
        const buffer = new ArrayBuffer(44 + length * 2);
        const view = new DataView(buffer);

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        // RIFF header
        writeString(view, 0, 'RIFF');
        view.setUint32(4, 36 + length * 2, true);
        writeString(view, 8, 'WAVE');
        writeString(view, 12, 'fmt ');
        view.setUint32(16, 16, true);
        view.setUint16(20, 1, true);
        view.setUint16(22, 1, true);
        view.setUint32(24, sampleRate, true);
        view.setUint32(28, sampleRate * 2, true);
        view.setUint16(32, 2, true);
        view.setUint16(34, 16, true);
        writeString(view, 36, 'data');
        view.setUint32(40, length * 2, true);

        // samples
        let offset = 44;
        for (let i = 0; i < length; i++) {
            const t = i / sampleRate;
            const sample = Math.max(-1, Math.min(1, volume * Math.sin(2 * Math.PI * freq * t)));
            view.setInt16(offset, sample * 0x7fff, true);
            offset += 2;
        }

        return new Blob([view], { type: 'audio/wav' });
    }

    // Список файлов для генерации (имена соответствуют ожидаемым в /audio/)
    const PLACEHOLDER_AUDIO_FILES = [
        { name: 'warning_standard_dps_500.mp3', freq: 600, dur: 1.2 },
        { name: 'warning_standard_dps_200.mp3', freq: 800, dur: 0.9 },
        { name: 'warning_standard_cam_500.mp3', freq: 620, dur: 1.2 },
        { name: 'warning_standard_cam_200.mp3', freq: 820, dur: 0.9 },
        { name: 'warning_cheeky_500.mp3', freq: 540, dur: 1.3 },
        { name: 'warning_cheeky_200.mp3', freq: 760, dur: 1.0 }
    ];

    // Генерирует и скачивает все плейсхолдеры
    function generatePlaceholderAudios() {
        const status = document.getElementById('audioGenStatus');
        status.textContent = '⏳ Генерация файлов...';
        setTimeout(() => {
            try {
                PLACEHOLDER_AUDIO_FILES.forEach(f => {
                    const wav = createSineWav(f.freq, f.dur, 0.5);
                    const url = URL.createObjectURL(wav);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = f.name.replace('.mp3', '.wav');
                    document.body.appendChild(a);
                    a.click();
                    a.remove();
                    URL.revokeObjectURL(url);
                });
                status.textContent = '✅ Файлы сгенерированы и начался загрузка. Переименуйте в .mp3 при необходимости и загрузите в /audio/';
            } catch (e) {
                console.warn(e);
                status.textContent = '❌ Ошибка при генерации аудио.';
            }
        }, 50);
    }

    // Позволяет скачать файлы по одному с пользовательским именем
    function downloadSinglePlaceholders() {
        const status = document.getElementById('audioGenStatus');
        status.textContent = '';
        PLACEHOLDER_AUDIO_FILES.forEach(f => {
            const wav = createSineWav(f.freq, f.dur, 0.5);
            const url = URL.createObjectURL(wav);
            const a = document.createElement('a');
            a.href = url;
            a.download = f.name.replace('.mp3', '.wav');
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
        });
        document.getElementById('audioGenStatus').textContent = '✅ Скачивание стартовало.';
    }

    // Загрузка сгенерированных плейсхолдеров в Supabase Storage (bucket: 'audio')
    async function uploadPlaceholdersToStorage() {
        const status = document.getElementById('audioGenStatus');
        status.textContent = '⏳ Загружаем файлы в Supabase Storage...';
        if (typeof _sb === 'undefined' || !_sb.storage) {
            status.textContent = '❌ Supabase client не найден (переменная _sb).';
            return;
        }
        const bucket = 'audio';
        let success = 0;
        for (const f of PLACEHOLDER_AUDIO_FILES) {
            try {
                const wav = createSineWav(f.freq, f.dur, 0.5);
                const fileName = f.name.replace('.mp3', '.wav');
                // Загружаем
                const { data, error } = await _sb.storage.from(bucket).upload(fileName, wav, { upsert: true, contentType: 'audio/wav' });
                if (error) {
                    console.warn('Upload error', fileName, error.message || error);
                    status.textContent = `❌ Ошибка загрузки ${fileName}: ${error.message || error}`;
                    // Продолжаем остальные файлы
                    continue;
                }
                success++;
            } catch (e) {
                console.warn('Ошибка при загрузке файла:', e);
                status.textContent = `❌ Ошибка при загрузке: ${e.message || e}`;
            }
        }
        if (success > 0) {
            status.textContent = `✅ Загружено ${success}/${PLACEHOLDER_AUDIO_FILES.length} файлы в bucket "${bucket}".`;
        }
    }

    // Получить список файлов из Supabase Storage (bucket: 'audio')
    async function listAudioStorageFiles() {
        const listEl = document.getElementById('storageFilesList');
        const status = document.getElementById('warningAudioStatus');
        listEl.innerHTML = '⏳ Получаем список...';
        if (typeof _sb === 'undefined' || !_sb.storage) {
            listEl.innerHTML = '❌ Supabase client не найден (переменная _sb).';
            return;
        }
        const bucket = 'audio';
        try {
            const { data, error } = await _sb.storage.from(bucket).list('', { limit: 200, offset: 0, sortBy: { column: 'name', order: 'asc' } });
            if (error) throw error;
            if (!data || data.length === 0) {
                listEl.innerHTML = '<div style="color: #666;">Пусто</div>';
                return;
            }
            let html = '<ul style="list-style:none;padding:0;margin:0;">';
            data.forEach(item => {
                html += `<li style="display:flex;justify-content:space-between;align-items:center;padding:6px 4px;border-bottom:1px dashed #f0f0f0;">` +
                        `<span style="font-size:13px;">${item.name}</span>` +
                        `<span style="display:flex;gap:8px;">` +
                        `<button onclick="downloadAudioFromStorage('${item.name.replace(/'/g, "\\'")}')" style="padding:6px 8px;background:#007aff;color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:12px;">⬇️</button>` +
                        `</span></li>`;
            });
            html += '</ul>';
            listEl.innerHTML = html;
            if (status) status.textContent = `✅ Получено ${data.length} файлов из bucket "${bucket}".`;
        } catch (e) {
            console.warn('listAudioStorageFiles error:', e);
            listEl.innerHTML = '❌ Ошибка при получении списка (возможно, нет прав у anon ключа).';
        }
    }

    // Скачивание одного файла из Supabase Storage
    async function downloadAudioFromStorage(name) {
        const status = document.getElementById('warningAudioStatus');
        if (status) status.textContent = `⏳ Скачиваем ${name}...`;
        if (typeof _sb === 'undefined' || !_sb.storage) {
            if (status) status.textContent = '❌ Supabase client не найден (переменная _sb).';
            return;
        }
        const bucket = 'audio';
        try {
            const { data, error } = await _sb.storage.from(bucket).download(name);
            if (error) throw error;
            const url = URL.createObjectURL(data);
            const a = document.createElement('a');
            a.href = url;
            a.download = name;
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
            if (status) status.textContent = `✅ Скачан ${name}`;
        } catch (e) {
            console.warn('downloadAudioFromStorage error:', e);
            if (status) status.textContent = '❌ Ошибка при скачивании (возможно, нет прав).';
        }
    }

    // Инициализация карты Яндекс.Карты
    // Функция проверки бана при загрузке
    async function checkBanStatus() {
        try {
            const { data: banned, error } = await _sb.from('bans').select('*').eq('user_id', uid).maybeSingle();
            
            if (error) {
                console.warn('Ошибка при проверке бана:', error?.message);
                return false;
            }
            
            if (banned) {
                console.warn('⛔ Пользователь забанен:', uid);
                // Скрываем всю карту и функциональность
                document.getElementById('map').style.display = 'none';
                document.querySelectorAll('button').forEach(btn => btn.style.display = 'none');
                document.querySelectorAll('.modal').forEach(m => m.style.display = 'none');
                
                // Показываем сообщение о бане
                const banMessage = document.createElement('div');
                banMessage.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: rgba(0, 0, 0, 0.95);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 9999;
                    flex-direction: column;
                    gap: 20px;
                `;
                banMessage.innerHTML = `
                    <div style="font-size: 60px; text-align: center;">🚫</div>
                    <div style="color: white; font-size: 24px; font-weight: bold; text-align: center;">ВЫ ЗАБАНЕНЫ</div>
                    <div style="color: #ccc; font-size: 14px; text-align: center; max-width: 300px;">
                        Причина: ${banned.reason || 'без указания'}<br>
                        Контакт: @admin_easy_ride
                    </div>
                `;
                document.body.appendChild(banMessage);
                return true;
            }
            
            return false;
        } catch (e) {
            console.error('Ошибка проверки баня:', e?.message || e);
            return false;
        }
    }

    // ============= ИНИЦИАЛИЗАЦИЯ КАРТЫ В ЯНДЕКС.ГОТОВАЯ =============
    ymaps.ready(async () => {
        // Показываем экран приветствия
        showSplashScreen();

        try {
            const tgUserForRules = window.Telegram?.WebApp?.initDataUnsafe?.user;
            if (tgUserForRules?.id) {
                await ensureSupabaseAuth();
                await ensureRulesAccepted(String(tgUserForRules.id));
            }

            // Проверяем статус бана с таймаутом
            userBanStatus = await Promise.race([
                checkBanStatus(),
                new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('Ban status check timeout')), 8000)
                )
            ]);

            if (userBanStatus) {
                // Пользователь забанен - показываем уведомление
                showBanNotice(userBanStatus);
                return; // Не инициализируем карту
            }

            // Если не забанен - инициализируем карту
            // Создаем карту с центром и уровнем зума
            await initPrimaryMapInstance();
            
            // Границы Донецкой области (скрыты)
            // const donetskBoundary = new ymaps.Rectangle([
            //     [DONETSK_REGION.south, DONETSK_REGION.west],
            //     [DONETSK_REGION.north, DONETSK_REGION.east]
            // ], {}, {
            //     fillColor: '#0066ff33',
            //     strokeColor: '#007aff',
            //     strokeWidth: 2,
            //     strokeOpacity: 0.7
            // });
            // myMap.geoObjects.add(donetskBoundary);
            // Инициализируем коллекцию маркеров внутри initPrimaryMapInstance()
            
            // События карты (через адаптер движка)
            bindMapCoreEvents();
            
            // Инициализируем приложение (проверяем регистрацию)
            appInitialized = true;
            initApp();
            updateTargetAnchorPosition();
            window.addEventListener('resize', updateTargetAnchorPosition);
            setDtpHeatmapUiState(false);
            
            // Инициализируем GPS отслеживание
            initGPS();
            initDynamicCourseSensors();
            // Обновим состояние кнопки автослежения
            try { updateFollowButton(); } catch(e) { /* ignore */ }
            // Загружаем маркеры с сервера
            loadMarkers();
            // Fallback-поллинг на случай потери realtime
            setInterval(loadMarkersDebounced, 10000);

            // Если actionCard скрыт по умолчанию, показываем кнопку открытия
            const openBtn = document.getElementById('openActionBtn');
            if (openBtn && !actionCardVisible) openBtn.classList.add('visible');

            // Синхронизируем правую колонку с текущим состоянием панели
            try { setRightActionsHidden(!!actionCardVisible); } catch(e) {}

            // Следим за изменением высоты нижнего виджета, чтобы прицел не перекрывался
            try {
                const card = document.getElementById('actionCard');
                if (card && !card.__targetObserverBound) {
                    card.__targetObserverBound = true;
                    card.addEventListener('transitionend', () => { try { updateTargetAnchorPosition(); } catch(e) {} });
                    if ('ResizeObserver' in window) {
                        const ro = new ResizeObserver(() => { try { updateTargetAnchorPosition(); } catch(e) {} });
                        ro.observe(card);
                        card.__targetRO = ro;
                    }
                }
            } catch (e) {}
            
            // Скрываем экран приветствия
            hideSplashScreenImmediately();

        } catch (error) {
            console.error('Ошибка инициализации карты (timeout или ошибка):', error?.message);
            // Скрываем splash screen при ошибке и продолжаем работу
            hideSplashScreenImmediately();
            appInitialized = true;
            
            // Пытаемся инициализировать карту, даже при ошибке проверки бана
            try {
                await initPrimaryMapInstance();
                
                initApp();
                initGPS();
                try { updateFollowButton(); } catch(e) { /* ignore */ }
                loadMarkers();
                setInterval(loadMarkersDebounced, 10000);
                
                const openBtn = document.getElementById('openActionBtn');
                if (openBtn && !actionCardVisible) openBtn.classList.add('visible');
            } catch(e) {
                console.error('Ошибка инициализации карты:', e);
            }
        }
    });



    // Функция проверки, находится ли точка в Донецкой области
    function isInDonetskRegion(coords) {
        if (!coords || coords.length < 2) return false;
        const lat = coords[0];
        const lon = coords[1];
        
        return lat >= DONETSK_REGION.south && 
               lat <= DONETSK_REGION.north && 
               lon >= DONETSK_REGION.west && 
               lon <= DONETSK_REGION.east;
    }

    // Функция добавления новой точки (маркера) на карту
    async function addPoint() {
        tryVibrate(14);
        if (!currentDriver) {
            alert('Пожалуйста, завершите регистрацию');
            openRegistrationModal();
            return;
        }

        // Анти-спам: 1 метка в 2 минуты
        const nowTs = Date.now();
        const rateKey = `last_marker_ts_${uid || 'anon'}`;
        let lastTs = 0;
        try { lastTs = Number(localStorage.getItem(rateKey) || 0); } catch(e) { lastTs = 0; }
        if (lastTs && (nowTs - lastTs) < MARKER_RATE_LIMIT_MS) {
            const waitSec = Math.ceil((MARKER_RATE_LIMIT_MS - (nowTs - lastTs)) / 1000);
            alert(`⏳ Подождите ${waitSec} сек. Можно ставить метку не чаще 1 раза в 2 минуты.`);
            return;
        }

        // Берём координаты из позиции центральной метки (прицела),
        // чтобы постановка была точной даже при поднятии прицела над нижним виджетом.
        const coords = getTargetPlacementCoords();

        const commentEl = document.getElementById('m-comm');
        const rawComment = (commentEl && typeof commentEl.value === 'string') ? commentEl.value.trim() : '';
        if (['sos', 'dps', 'specbat'].includes(String(selectedType))) {
            if (!rawComment) {
                if (selectedType === 'sos') alert('🆘 Для SOS заполните поле: Тип | Комментарий');
                else if (selectedType === 'dps') alert('🚔 Для ДПС заполните поле Статус (например: Работают / Проверка документов)');
                else alert('🛡 Для Спецбата заполните поле: Направление | Инфо');
                return;
            }
        }
        
        // Проверяем, находится ли местоположение в Донецкой области ДНР
        if (!isInDonetskRegion(coords)) {
            alert('⛔ Метки можно добавлять только в ДНР.\n\nТекущее местоположение: ' + coords[0].toFixed(2) + '°N, ' + coords[1].toFixed(2) + '°E');
            return;
        }

        // Вставляем новый маркер в БД
        try {
            let noTsExpMode = false;
            try { noTsExpMode = localStorage.getItem(MARKER_INSERT_NO_TS_EXP_KEY) === '1'; } catch(e) {}

            const markerToCreate = {
                coords: coords, // Центр текущей карты
                type: selectedType, // Тип маркера (ДПС, Рейд и т.д.)
                comment: rawComment, // Комментарий пользователя
                author_id: uid // ID автора маркера
            };
            if (!noTsExpMode) {
                markerToCreate.ts = Date.now(); // Текущее время
                markerToCreate.exp = Date.now() + 7200000; // Время жизни маркера (2 часа)
            }
            let insertedMarkers = null;
            let error = null;

            ({ data: insertedMarkers, error } = await _sb
                .from('markers')
                .insert([markerToCreate])
                .select('id,type,comment,coords'));

            if (error && !noTsExpMode) {
                const fallbackMarkerToCreate = {
                    coords: coords,
                    type: selectedType,
                    comment: rawComment,
                    author_id: uid
                };
                ({ data: insertedMarkers, error } = await _sb
                    .from('markers')
                    .insert([fallbackMarkerToCreate])
                    .select('id,type,comment,coords'));
                if (!error) {
                    try { localStorage.setItem(MARKER_INSERT_NO_TS_EXP_KEY, '1'); } catch(e) {}
                }
            }

            if (!error) {
                try { localStorage.setItem(rateKey, String(Date.now())); } catch(e) {}
                // Попытаемся обновить счетчик в таблице drivers, но игнорируем ошибку, если колонка отсутствует
                try {
                    await _sb.from('drivers').update({ markers_count: (currentDriver.markers_count || 0) + 1 }).eq('user_id', uid);
                } catch (e) {
                    console.warn('Не удалось обновить markers_count в drivers (возможно, колонка отсутствует):', e?.message || e);
                }
                // Обновляем локально
                currentDriver.markers_count = (currentDriver.markers_count || 0) + 1;

                // Если нет ошибки, очищаем поле комментария и обновляем маркеры
                document.getElementById('m-comm').value = '';
                // Отключаем автосдвиг GPS на следующее обновление (чтобы карта не вернулась к GPS после размещения метки)
                disableAutoFollowOnce = true;
                alert('✅ Метка успешно добавлена!');
                if (insertedMarkers && insertedMarkers[0]) {
                    notifyHelpBotAboutMarker(insertedMarkers[0]);
                }
                loadMarkers();
            } else {
                throw error;
            }
        } catch (e) {
            console.warn('Ошибка при добавлении метки:', e?.message || e);
            const msg = (e?.message || String(e));
            if (msg.toLowerCase().includes('rate') || msg.toLowerCase().includes('limit')) {
                alert('⏳ Слишком часто. Можно ставить метку не чаще 1 раза в 2 минуты.');
            } else {
                alert('Ошибка при добавлении метки: ' + msg);
            }
        }
    }

    // Функция загрузки всех активных маркеров с карты
    async function loadMarkers() {
        if (loadMarkersInFlight) {
            loadMarkersPending = true;
            return;
        }
        loadMarkersInFlight = true;
        loadMarkersPending = false;

        // Загружаем маркеры, которые еще не истекли (exp > текущее время)
        // Загружаем все метки и фильтруем их по exp на клиенте,
        // чтобы корректно работать с разными типами поля exp (BIGINT или TIMESTAMPTZ)
        try {
            const queryMarkers = () => _sb.from('markers').select('id,coords,type,comment,photo_url,votes_up,votes_down,author_id,leave_confirmations,exp,ts');
            const queryWithTimeout = (factory) => Promise.race([
                factory(),
                new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('Markers load timeout')), 10000)
                )
            ]);

            let markers = null;
            let markersError = null;
            ({ data: markers, error: markersError } = await queryWithTimeout(queryMarkers));

            if (markersError) {
                const errText = String(markersError?.message || markersError?.code || '').toLowerCase();
                if (errText.includes('unauthorized') || errText.includes('jwt') || errText.includes('token') || String(markersError?.code || '') === '401') {
                    try { clearSupabaseAuth(); } catch (e) {}
                    ({ data: markers, error: markersError } = await queryWithTimeout(queryMarkers));
                }
            }

            if (markersError || !markers || !myMap) {
                if (markersError) console.warn('Ошибка загрузки маркеров:', markersError?.message || markersError);
                console.warn('Маркеры не загружены или карта не инициализирована');
                return;
            }
        const now = Date.now();
        const activeMarkers = (markers || []).filter(m => {
            if (m.exp === null || typeof m.exp === 'undefined') return true;
            if (typeof m.exp === 'number') return m.exp > now;
            const parsed = Date.parse(m.exp);
            return !isNaN(parsed) ? parsed > now : true;
        });
        
        // Подсчитываем метки по типам
        const typeCounts = {};
        activeMarkers.forEach(m => {
            typeCounts[m.type] = (typeCounts[m.type] || 0) + 1;
        });
        
        // Элемент счётчика в UI
        const counterEl = document.getElementById('markersCounter');
        
        // Используем GPS координаты пользователя, иначе центр карты
        const fallbackCenter = (mapAdapter && typeof mapAdapter.getCenter === 'function') ? mapAdapter.getCenter() : (myMap?.getCenter?.() || null);
        const userCoords = (userLocation && userLocation.length >= 2) ? userLocation : fallbackCenter;

        // Для производительности рендерим только метки в видимой области (+запас)
        // или рядом с пользователем (чтобы голос/подсказки не терялись при смещении карты).
        const mapBounds = (mapAdapter && typeof mapAdapter.getBounds === 'function') ? mapAdapter.getBounds() : ((myMap && typeof myMap.getBounds === 'function') ? myMap.getBounds() : null);
        const hasBounds = Array.isArray(mapBounds) && mapBounds.length >= 2 && Array.isArray(mapBounds[0]) && Array.isArray(mapBounds[1]);
        const VIEWPORT_MARGIN_DEG = 0.035;
        const NEARBY_RENDER_METERS = 3000;
        let renderMarkers = (markerRenderMode === 'all')
            ? activeMarkers
            : activeMarkers.filter(m => {
                const coords = extractMarkerCoordsForNotif(m);
                if (!coords) return false;

                let inBounds = true;
                if (hasBounds) {
                    const sw = mapBounds[0];
                    const ne = mapBounds[1];
                    inBounds = coords.lat >= (Number(sw[0]) - VIEWPORT_MARGIN_DEG)
                        && coords.lat <= (Number(ne[0]) + VIEWPORT_MARGIN_DEG)
                        && coords.lon >= (Number(sw[1]) - VIEWPORT_MARGIN_DEG)
                        && coords.lon <= (Number(ne[1]) + VIEWPORT_MARGIN_DEG);
                }

                let nearUser = false;
                if (Array.isArray(userCoords) && userCoords.length >= 2) {
                    nearUser = calculateDistance(Number(userCoords[0]), Number(userCoords[1]), Number(coords.lat), Number(coords.lon)) <= NEARBY_RENDER_METERS;
                }

                return inBounds || nearUser;
            });

        if (markerRenderMode !== 'all' && renderMarkers.length === 0 && activeMarkers.length > 0) {
            renderMarkers = activeMarkers;
        }

        // Обновляем счётчик в UI (включая видимость в viewport-режиме)
        if (counterEl) {
            const typeNames = {
                dps: 'ДПС',
                patrol: 'Рейд',
                specbat: 'Спецбат',
                motobat: 'Мотобат',
                cargo_control: 'Груз. контроль',
                sos: 'SOS',
                dtp: 'ДТП',
                danger: 'Опасность',
                traffic_jam: 'Пробка',
                camera: 'Наблюдение',
                works: 'Работы'
            };
            let counterHTML = 'Активные: ';
            let hasCounters = false;
            for (const [type, count] of Object.entries(typeCounts)) {
                if (count > 0) {
                    counterHTML += `<span class="counter-item"><span>${count}</span> ${typeNames[type] || type}</span>`;
                    hasCounters = true;
                }
            }
            if (!hasCounters) {
                counterHTML = '✅ Активных событий нет';
            } else {
                const modeLabel = markerRenderMode === 'all' ? 'Все' : 'Рядом';
                counterHTML += `<div style="margin-top:4px; font-size:11px; opacity:.85;">Режим: ${modeLabel} • Показано на карте: ${renderMarkers.length} из ${activeMarkers.length}</div>`;
            }
            counterEl.innerHTML = counterHTML;
        }

        // Удаляем только маркеры, которые мы рендерим (не трогаем userLocationMarker и служебные объекты)
        if (mapAdapter && typeof mapAdapter.clearMarkers === 'function') mapAdapter.clearMarkers();
        else if (markersCollection) markersCollection.removeAll();

        // Подготовим данные об авторах (имя, likes_sum, is_trusted)
        const authorIds = Array.from(new Set(renderMarkers.map(m => String(m.author_id))));
        const authorsInfoMap = {}; // user_id -> { name, likes_sum, is_trusted }
        try {
            // Запрашиваем имя и рейтинг из drivers (если таблица/колонки есть)
            if (authorIds.length > 0) {
                const { data: driversInfo } = await _sb.from('drivers').select('user_id,name,likes_sum,is_trusted').in('user_id', authorIds);
                if (driversInfo) {
                    driversInfo.forEach(d => {
                        const id = String(d.user_id);
                        authorsInfoMap[id] = {
                            name: d.name || 'Аноним',
                            likes_sum: (typeof d.likes_sum !== 'undefined' && d.likes_sum !== null) ? Number(d.likes_sum) : 0,
                            is_trusted: !!d.is_trusted
                        };
                    });
                }
            }
        } catch (e) {
            console.warn('Не удалось получить данные drivers для авторов (возможно, таблица/колонки отсутствуют):', e?.message || e);
        }

        // Для авторов без данных подсчитаем суммарные лайки локально по уже загруженным активным меткам
        const missingAuthors = authorIds.filter(id => !authorsInfoMap[id]);
        if (missingAuthors.length > 0) {
            const sumMap = {};
            activeMarkers.forEach(r => {
                const id = String(r.author_id);
                if (!missingAuthors.includes(id)) return;
                sumMap[id] = (sumMap[id] || 0) + (r.votes_up || 0);
            });
            missingAuthors.forEach(id => {
                const likes = sumMap[id] || 0;
                authorsInfoMap[id] = { name: 'Аноним', likes_sum: likes, is_trusted: likes >= (typeof TRUST_LIKES_THRESHOLD !== 'undefined' ? TRUST_LIKES_THRESHOLD : 20) };
            });
        }

        // SOS: кто "в пути" (Edge Function, чтобы не упираться в RLS таблицы)
        const sosEnrouteByMarker = {}; // marker_id -> user_id[]
        const sosResponderNames = {}; // user_id -> name
        try {
            const sosIds = renderMarkers
                .filter(x => String(x?.type) === 'sos')
                .map(x => Number(x?.id))
                .filter(n => Number.isFinite(n) && n > 0);

            if (sosIds.length > 0) {
                let token = localStorage.getItem('sb_jwt') || '';
                if (!token) {
                    const refreshed = await ensureSupabaseAuth();
                    token = refreshed || localStorage.getItem('sb_jwt') || '';
                }

                if (token) {
                    const resp = await fetch(`${SUPABASE_URL}/functions/v1/sos-enroute?action=list`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            Authorization: `Bearer ${token}`
                        },
                        body: JSON.stringify({ markerIds: sosIds })
                    });

                    if (resp.ok) {
                        const payload = await resp.json();
                        const byMarker = payload?.byMarker || {};

                        Object.keys(byMarker).forEach(midStr => {
                            const mid = Number(midStr);
                            const list = Array.isArray(byMarker[midStr]) ? byMarker[midStr] : [];
                            if (!Number.isFinite(mid) || mid <= 0) return;

                            sosEnrouteByMarker[mid] = [];
                            list.forEach(item => {
                                const rid = String(item?.userId || '').trim();
                                const name = String(item?.name || '').trim();
                                if (!rid) return;
                                if (!sosEnrouteByMarker[mid].includes(rid)) sosEnrouteByMarker[mid].push(rid);
                                if (name) sosResponderNames[rid] = name;
                            });
                        });
                    }
                }
            }
        } catch (e) {}

        // Для каждого маркера создаем объект на карте
        renderMarkers.forEach(m => {
            try {
            // Получаем ID автора в начале цикла
            const authorId = String(m.author_id);
            
            // Проверяем, является ли текущий пользователь автором маркера
            const isOwner = String(m.author_id) === String(uid);
            
            // Считаем количество подтверждений "уехали" (грейсфул - если таблица не существует, берём из счётчика в markers)
            let leaveCount = m.leave_confirmations || 0;
            const confirmThreshold = typeof MARKER_LEAVE_THRESHOLD !== 'undefined' ? MARKER_LEAVE_THRESHOLD : 3;
            const confirmationBar = leaveCount > 0 ? `<div style="margin-top: 8px; font-size: 11px; color: #666;">🚗 Уехали: ${leaveCount}/${confirmThreshold}</div>` : '';
            
            // HTML контент для всплывающего окна маркера
            const authorInfo = authorsInfoMap[authorId] || { name: 'Аноним', likes_sum: 0, is_trusted: false };
            const isAdminMarker = isAdminUserId(authorId);
            const showAdminStyle = isAdminMarker && !adminInvisible;
            const isSpecbatMarker = String(m.type) === 'specbat';
            // Переводим likes_sum в 0..5 звёзд
            function likesToStarsLocal(likes) {
                const n = Number(likes) || 0;
                if (n <= 0) return 0;
                if (n >= 100) return 5;
                if (n >= 60) return 4;
                if (n >= 30) return 3;
                if (n >= 10) return 2;
                return 1;
            }
            const starsCountLocal = likesToStarsLocal(authorInfo.likes_sum);
            let starsHTMLLocal = '';
            for (let i = 0; i < 5; i++) starsHTMLLocal += (i < starsCountLocal) ? '★' : '☆';
            const starsBadgeLocal = `<span style="margin-left:8px; color: ${authorInfo.is_trusted ? '#b8860b' : '#f5c542'}; font-weight:700;">${starsHTMLLocal}</span>`;

            const authorNameHtml = showAdminStyle
                ? `<span class="admin-name">${authorInfo.name || 'Admin'}</span>`
                : `<strong>${authorInfo.name || 'Аноним'}</strong>`;
            const authorBadgesHtml = showAdminStyle
                ? `<span class="admin-rank">${ADMIN_RANK_LABEL}</span>`
                : `${authorInfo.is_trusted ? '<span style="color:#b8860b; font-weight:800; margin-left:6px;">⭐</span>' : ''} ${starsBadgeLocal}`;
            const adminOnlineHtml = showAdminStyle
                ? `<div class="admin-online" style="margin-bottom:6px;"><span class="admin-online-dot"></span>На связи</div>`
                : '';
            const adminConfirmHtml = showAdminStyle
                ? `<div class="admin-confirm">✅ Подтверждено администрацией</div>`
                : '';
            const reportButtonHtml = showAdminStyle
                ? adminConfirmHtml
                : `<button class="b-del" style="background: #ff9500; color:white;" onclick="window.reportUser(${m.author_id}, '${(authorInfo.name || 'Пользователь').replace(/'/g, "\\'")}')" title="Пожаловаться на автора метки">⚠️ Пожаловаться</button>`;

            const sosEnrouteIds = (String(m.type) === 'sos') ? (sosEnrouteByMarker[Number(m.id)] || []) : [];
            const sosEnrouteCount = Array.isArray(sosEnrouteIds) ? sosEnrouteIds.length : 0;
            const sosEnrouteNames = (sosEnrouteIds || [])
                .map(id => sosResponderNames[id] || id)
                .filter(Boolean)
                .slice(0, 6);
            const sosEnrouteNamesText = sosEnrouteNames.length ? ` — ${sosEnrouteNames.join(', ')}` : '';
            const sosEnrouteInfoHtml = (String(m.type) === 'sos')
                ? `<div style="margin-top: 8px; font-size: 11px; color: #666;">🚑 В пути: ${sosEnrouteCount}${sosEnrouteNamesText}</div>`
                : '';
            const canEnroute = String(m.type) === 'sos' && uid && String(uid) !== String(m.author_id);
            const sosEnrouteBtnHtml = canEnroute
                ? `<button class="b-poll-btn" onclick="window.sosEnroute(${m.id})" style="flex: 1; background: var(--blue); color: white; font-weight: 900;">🚑 Я в пути</button>`
                : '';

            const bHtml = `<div class="b-cont">
                <div style="font-size:13px; margin-bottom:6px; color:#222; cursor: ${window.isAdmin ? 'pointer' : 'default'}; padding: 4px; border-radius: 4px; transition: all 0.2s;" onmouseover="${window.isAdmin ? `this.style.background='#f0f0f5'; this.style.transform='scale(1.02)'` : ''}" onmouseout="${window.isAdmin ? `this.style.background=''; this.style.transform='scale(1)'` : ''}" onclick="${window.isAdmin ? `window.showUserModeratorMenuFromMarker(${m.author_id}, '${(authorInfo.name || 'Пользователь').replace(/'/g, "\\'")}')` : ''}">${authorNameHtml} ${authorBadgesHtml}</div>
                ${adminOnlineHtml}
                <strong>${m.comment || 'Метка'}</strong>
                ${(() => {
                    const safeMarkerPhoto = sanitizeMediaUrl(m.photo_url);
                    if (!safeMarkerPhoto) return '';
                    const escaped = safeMarkerPhoto.replace(/'/g, "\\'");
                    return `<div style="margin-top: 8px; margin-bottom: 8px;"><img src="${safeMarkerPhoto}" style="max-width: 100%; border-radius: 8px; cursor: pointer; max-height: 250px;" onclick="openPhotoViewer('${escaped}')" title="Нажмите для увеличения"></div>`;
                })()}
                <div class="b-poll">
                    <button class="b-poll-btn" onclick="window.vote(${m.id}, true)">👍 ${m.votes_up || 0}</button>
                    <button class="b-poll-btn" onclick="window.vote(${m.id}, false)">👎 ${m.votes_down || 0}</button>
                </div>
                <div style="margin-top: 8px; display: flex; gap: 5px;">
                    <button class="b-poll-btn" onclick="window.confirmMarker(${m.id}, 'stay')" style="flex: 1; background: #34c759; color: white; font-weight: bold;">✅ Стоят</button>
                    <button class="b-poll-btn" onclick="window.confirmMarker(${m.id}, 'leave')" style="flex: 1; background: #ff3b30; color: white; font-weight: bold;">🚗 Уехали</button>
                </div>
                ${sosEnrouteBtnHtml ? `<div style="margin-top: 8px; display: flex; gap: 5px;">${sosEnrouteBtnHtml}</div>` : ''}
                ${confirmationBar}
                ${sosEnrouteInfoHtml}
                ${isOwner ? `<button class="b-del" onclick="window.delMarker(${m.id})">Удалить</button>` : ''}
                ${reportButtonHtml}
            </div>`;
            // Определяем доверие автора и добавляем звездочку к иконке, если он проверен
            const isTrustedAuthor = authorInfo.is_trusted;
            const iconInner = showAdminStyle
                ? `<div class="admin-marker admin-marker--map"><span class="admin-siren admin-siren-left"></span><span class="admin-siren admin-siren-right"></span><span class="admin-marker-core">${MAP_ICONS[m.type]}</span><span class="admin-marker-badge">♛</span></div>`
                : (isSpecbatMarker
                    ? `<div class="specbat-marker" title="Спецбат">${MAP_ICONS[m.type]}<span class="specbat-badge">SB</span></div>`
                    : `<div style="background:white; border-radius:50%; width:30px; height:30px; display:flex; align-items:center; justify-content:center; border:2px solid ${isTrustedAuthor ? '#b8860b' : 'var(--blue)'}; font-size:18px; position: relative;">${MAP_ICONS[m.type]}${isTrustedAuthor ? '<span style=\"position:absolute; top:-6px; right:-6px; font-size:12px;\">⭐</span>' : ''}</div>`);
            // Создаем маркер с иконкой и балуном
            const iconSize = showAdminStyle ? 34 : (isSpecbatMarker ? 34 : 30);
            const normalizedCoords = extractMarkerCoordsForNotif(m);
            if (!normalizedCoords) return;
            const markerCoordsForMap = [Number(normalizedCoords.lat), Number(normalizedCoords.lon)];
            if (!Number.isFinite(markerCoordsForMap[0]) || !Number.isFinite(markerCoordsForMap[1])) return;

            const p = new ymaps.Placemark(markerCoordsForMap, { balloonContent: bHtml, iconContent: iconInner }, 
            { iconLayout: 'default#imageWithContent', iconImageHref: '', iconImageSize: [iconSize, iconSize], iconImageOffset: [-(iconSize/2), -(iconSize/2)] });
            const markerDescriptor = {
                coords: [Number(normalizedCoords.lon), Number(normalizedCoords.lat)],
                icon: MAP_ICONS[m.type] || '📍',
                hint: `${getMarkerLabel(m.type)}${m.comment ? ` • ${String(m.comment).slice(0, 48)}` : ''}`,
                balloonHtml: bHtml,
                author_role: showAdminStyle ? 'admin' : 'user',
                author_name: authorInfo.name || 'Admin',
                markerData: {
                    ...m,
                    author_role: showAdminStyle ? 'admin' : 'user',
                    author_name: authorInfo.name || 'Admin',
                    balloonHtml: bHtml
                }
            };
            // Добавляем маркер в коллекцию
            if (mapAdapter && typeof mapAdapter.addMarker === 'function') mapAdapter.addMarker(p, markerDescriptor);
            else if (markersCollection) markersCollection.add(p);
            
            // Проверяем расстояние до маркера и выдаем уведомление если нужно
            checkMarkerDistance(m, userCoords);
            
            // Очищаем уведомления для маркеров которые уже далеко (более 800м)
            if (distanceNotifications.has(m.id)) {
                const mc = extractMarkerCoordsForNotif(m);
                if (mc) {
                    const distance = calculateDistance(userCoords[0], userCoords[1], mc.lat, mc.lon);
                    const releaseMeters = (String(m?.type || '') === 'sos')
                        ? Math.max(MONOLITH_SOS_PRIORITY_RADIUS_METERS + 600, getUserDistSettingMeters() + 600)
                        : (getUserDistSettingMeters() + 600);
                    if (distance > releaseMeters) {
                        distanceNotifications.delete(m.id);
                    }
                }
            }
            } catch (e) {
                console.warn('Пропуск повреждённой метки:', m?.id, e?.message || e);
            }
        });
        if (dtpHeatmapEnabled) {
            dtpHeatmapCacheLoadedAt = 0;
            scheduleDtpHeatmapRender();
        }
        if (patrolHeatmapEnabled) {
            patrolHeatmapCacheLoadedAt = 0;
            schedulePatrolHeatmapRender();
        }
        } catch (error) {
            console.error('Ошибка при загрузке маркеров (timeout или ошибка БД):', error?.message);
        } finally {
            loadMarkersInFlight = false;
            if (loadMarkersPending) {
                loadMarkersPending = false;
                setTimeout(() => { loadMarkers().catch?.(()=>{}); }, 60);
            }
        }
    }
</script>
    <!-- Модальное окно для модерации пользователя -->
    <div id="moderatorModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 style="margin:0;">Модерация пользователя</h3>
                <button class="modal-close" onclick="closeModerationModal()">×</button>
            </div>
            <div id="moderatorModalContent">
                <div style="background: #f0f0f5; padding: 15px; border-radius: 12px; margin-bottom: 20px;">
                    <div style="font-size: 14px; color: var(--gray); margin-bottom: 8px;">Пользователь:</div>
                    <div id="modUserName" style="font-size: 18px; font-weight: 700; margin-bottom: 4px;">—</div>
                    <div style="font-size: 12px; color: var(--gray);">
                        Telegram ID: <span id="modUserId" style="font-weight: 600; color: #000;">—</span>
                    </div>
                </div>
                
                <div class="moderation-section">
                    <div class="moderation-title">⚙️ Действия модерации</div>
                    <div class="moderation-buttons">
                        <button class="mod-btn mod-btn-temp" onclick="openBanDurationModal()">
                            <span style="font-size: 18px;">⏱️</span>
                            Временный бан
                        </button>
                        
                        <button class="mod-btn mod-btn-perm" onclick="banUser('permanent')">
                            <span style="font-size: 18px;">🚫</span>
                            Постоянный бан
                        </button>
                    </div>
                    
                    <div style="margin-top: 10px; padding: 12px; background: #fff3cd; border-radius: 8px; font-size: 12px; color: #856404;">
                        ⚠️ Забаненные пользователи не смогут создавать метки и отправлять сообщения в чат
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Модальное окно выбора длительности бана -->
    <div id="banDurationModal" class="ban-duration-modal">
        <div class="ban-duration-content">
            <div class="ban-duration-title">⏱️ Выберите длительность бана</div>
            
            <div class="ban-options">
                <div class="ban-option" data-hours="1">
                    <span class="duration">1 час</span>
                    <span class="label">Быстрое предупреждение</span>
                </div>
                <div class="ban-option" data-hours="6">
                    <span class="duration">6 часов</span>
                    <span class="label">Серьёзное нарушение</span>
                </div>
                <div class="ban-option" data-hours="24">
                    <span class="duration">24 часа</span>
                    <span class="label">Сутки</span>
                </div>
                <div class="ban-option" data-hours="72">
                    <span class="duration">3 дня</span>
                    <span class="label">Длительное наказание</span>
                </div>
                <div class="ban-option" data-hours="168">
                    <span class="duration">7 дней</span>
                    <span class="label">Неделя</span>
                </div>
                <div class="ban-option" data-hours="720">
                    <span class="duration">30 дней</span>
                    <span class="label">Месяц</span>
                </div>
            </div>
            
            <div class="ban-actions">
                <button class="ban-cancel-btn" onclick="closeBanDurationModal()">Отмена</button>
                <button class="ban-confirm-btn" onclick="confirmTempBan()">Забанить</button>
            </div>
        </div>
    </div>

    <script>
        // Переменная для хранения ID текущего модерируемого пользователя
        let currentModeratingUserId = null;

        // Функция открытия модального окна модерации (вызывается при клике на имя автора в маркере)
        window.showUserModeratorMenuFromMarker = function(userId, userName) {
            if (!window.isAdmin) {
                console.warn('Доступ запрещён: только для администраторов');
                return;
            }
            
            currentModeratingUserId = userId;
            document.getElementById('modUserName').textContent = userName || 'Аноним';
            document.getElementById('modUserId').textContent = userId;
            document.getElementById('moderatorModal').classList.add('active');
        };

        // Функция закрытия модального окна модерации
        function closeModerationModal() {
            document.getElementById('moderatorModal').classList.remove('active');
            currentModeratingUserId = null;
        }

        // Переменная для хранения выбранной длительности бана (в часах)
        let selectedBanHours = 24; // По умолчанию 24 часа

        // Функция открытия модального окна выбора длительности бана
        function openBanDurationModal() {
            // Закрываем модальное окно модерации
            document.getElementById('moderatorModal').classList.remove('active');
            
            // Открываем модальное окно выбора длительности
            document.getElementById('banDurationModal').classList.add('active');
            
            // Сбрасываем предыдущий выбор
            document.querySelectorAll('.ban-option').forEach(opt => opt.classList.remove('selected'));
            
            // Устанавливаем обработчики на опции
            document.querySelectorAll('.ban-option').forEach(option => {
                option.onclick = function() {
                    // Убираем выделение со всех опций
                    document.querySelectorAll('.ban-option').forEach(opt => opt.classList.remove('selected'));
                    // Добавляем выделение на выбранную опцию
                    this.classList.add('selected');
                    // Сохраняем выбранное количество часов
                    selectedBanHours = parseInt(this.getAttribute('data-hours'));
                };
            });
        }

        // Функция закрытия модального окна выбора длительности бана
        function closeBanDurationModal() {
            document.getElementById('banDurationModal').classList.remove('active');
            // Возвращаемся к модальному окну модерации
            document.getElementById('moderatorModal').classList.add('active');
        }

        // Функция подтверждения временного бана
        async function confirmTempBan() {
            // Проверяем, выбрана ли длительность
            const selectedOption = document.querySelector('.ban-option.selected');
            if (!selectedOption) {
                alert('⚠️ Пожалуйста, выберите длительность бана');
                return;
            }
            
            // Закрываем модальное окно выбора длительности
            document.getElementById('banDurationModal').classList.remove('active');
            
            // Вызываем функцию бана с выбранной длительностью
            await banUserWithDuration(selectedBanHours);
        }

        // Функция бана пользователя с указанной длительностью (в часах)
        async function banUserWithDuration(hours) {
            if (!currentModeratingUserId) {
                alert('Ошибка: не выбран пользователь для модерации');
                return;
            }

            const userName = document.getElementById('modUserName').textContent;
            
            // Форматируем длительность для сообщения
            let durationText = '';
            if (hours < 24) {
                durationText = `${hours} ${hours === 1 ? 'час' : hours < 5 ? 'часа' : 'часов'}`;
            } else if (hours < 168) {
                const days = Math.floor(hours / 24);
                durationText = `${days} ${days === 1 ? 'день' : days < 5 ? 'дня' : 'дней'}`;
            } else {
                const days = Math.floor(hours / 24);
                durationText = `${days} ${days === 1 ? 'день' : days < 5 ? 'дня' : 'дней'}`;
            }
            
            const confirmMessage = `Вы уверены, что хотите забанить пользователя "${userName}" на ${durationText}?`;

            if (!confirm(confirmMessage)) {
                // Если отменили, возвращаемся к модальному окну модерации
                document.getElementById('moderatorModal').classList.add('active');
                return;
            }

            try {
                // Определяем дату окончания бана
                const bannedUntil = new Date(Date.now() + hours * 60 * 60 * 1000).toISOString();
                const targetUserId = String(currentModeratingUserId);

                await invokeAdminFunction('ban-user', {
                    targetUserId,
                    bannedUntil,
                    banType: 'temp',
                    reason: `Временный бан на ${durationText}`
                });

                alert(`✅ Пользователь "${userName}" забанен на ${durationText}`);
                currentModeratingUserId = null;

                // Удаляем все маркеры забаненного пользователя с карты (опционально)
                if (confirm('Удалить все метки этого пользователя с карты?')) {
                    const { error: deleteError } = await _sb
                        .from('markers')
                        .delete()
                        .eq('author_id', targetUserId);

                    if (deleteError) {
                        console.error('Ошибка удаления меток:', deleteError);
                    } else {
                        alert('✅ Метки пользователя удалены');
                        await loadMarkers(); // Обновляем карту
                    }
                }

            } catch (error) {
                console.error('Ошибка при бане пользователя:', error);
                const msg = String(error?.message || 'Неизвестная ошибка');
                alert('❌ Edge Function ban-user отклонила запрос: ' + msg);
                // Возвращаемся к модальному окну модерации
                document.getElementById('moderatorModal').classList.add('active');
            }
        }

        // Функция бана пользователя
        async function banUser(banType) {
            if (!currentModeratingUserId) {
                alert('Ошибка: не выбран пользователь для модерации');
                return;
            }

            const userName = document.getElementById('modUserName').textContent;
            const confirmMessage = banType === 'temp' 
                ? `Вы уверены, что хотите забанить пользователя "${userName}" на 24 часа?`
                : `Вы уверены, что хотите НАВСЕГДА забанить пользователя "${userName}"?`;

            if (!confirm(confirmMessage)) return;

            try {
                // Определяем дату окончания бана
                const bannedUntil = banType === 'temp' 
                    ? new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString() // +24 часа
                    : new Date('2099-12-31').toISOString(); // "Навсегда"

                // Преобразуем user_id в строку для совместимости с TEXT типом в БД
                const userIdString = String(currentModeratingUserId);

                await invokeAdminFunction('ban-user', {
                    targetUserId: userIdString,
                    bannedUntil,
                    banType,
                    reason: banType === 'temp' ? 'Временный бан (24ч)' : 'Постоянный бан'
                });

                const successMessage = banType === 'temp'
                    ? `✅ Пользователь "${userName}" забанен на 24 часа`
                    : `✅ Пользователь "${userName}" забанен навсегда`;

                alert(successMessage);
                closeModerationModal();

                // Удаляем все маркеры забаненного пользователя с карты (опционально)
                if (confirm('Удалить все метки этого пользователя с карты?')) {
                    const { error: deleteError } = await _sb
                        .from('markers')
                        .delete()
                        .eq('author_id', userIdString);

                    if (deleteError) {
                        console.error('Ошибка удаления меток:', deleteError);
                    } else {
                        alert('✅ Метки пользователя удалены');
                        await loadMarkers(); // Обновляем карту
                    }
                }

            } catch (error) {
                console.error('Ошибка при бане пользователя:', error);
                const msg = String(error?.message || 'Неизвестная ошибка');
                alert('❌ Edge Function ban-user отклонила запрос: ' + msg);
            }
        }

        // Закрытие модального окна при клике вне его области
        document.getElementById('moderatorModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeModerationModal();
            }
        });

        // Закрытие модального окна выбора длительности бана при клике вне его области
        document.getElementById('banDurationModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeBanDurationModal();
            }
        });
    
        // ============= ЭКРАН ПРИВЕТСТВИЯ =============
        function getGreeting() {
            const hour = new Date().getHours();
            if (hour >= 5 && hour < 12) return '🌅 Доброе утро';
            if (hour >= 12 && hour < 17) return '☀️ Добрый день';
            if (hour >= 17 && hour < 22) return '🌆 Добрый вечер';
            return '🌙 Доброй ночи';
        }

        function showSplashScreen() {
            const splashScreen = document.getElementById('splashScreen');
            const greetingText = document.getElementById('greetingText');
            const usernameText = document.getElementById('usernameText');

            greetingText.textContent = getGreeting();
            
            // Получаем имя водителя из разных источников
            const driverName = currentDriver?.name || 
                               window.Telegram?.WebApp?.initDataUnsafe?.user?.first_name || 
                               'водитель';
            usernameText.textContent = `Водитель ${driverName}`;

            splashScreen.classList.remove('hidden');

            // Скрываем экран через 2 секунды (вместо 1)
            setTimeout(() => {
                splashScreen.classList.add('hidden');
            }, 2000);
        }
        
        // Функция для скрытия экрана загрузки немедленно
        function hideSplashScreenImmediately() {
            document.getElementById('splashScreen').classList.add('hidden');
        }

        // ============= ПРОВЕРКА БАНА =============
        let userBanStatus = null;
        let appInitialized = false;

        async function checkBanStatus() {
            try {
                const userIdString = String(uid ?? '').trim();
                if (!/^\d+$/.test(userIdString)) return null;
                const { data, error } = await _sb
                    .from('bans')
                    .select('*')
                    .eq('user_id', userIdString)
                    .maybeSingle();

                if (error && error.code !== 'PGRST116') {
                    const errText = String(error?.message || error?.code || '').toLowerCase();
                    if (errText.includes('unauthorized') || errText.includes('jwt') || errText.includes('token')) {
                        try { clearSupabaseAuth(); } catch (e) {}
                        return null;
                    }
                    console.error('Ошибка проверки бана:', error);
                    return null;
                }

                if (!data) return null;

                const bannedUntil = new Date(data.banned_until);
                const now = new Date();

                // Проверяем, истек ли бан
                if (now >= bannedUntil) {
                    // Бан истек - удаляем запись
                    await _sb.from('bans').delete().eq('user_id', userIdString);
                    return null;
                }

                return data;
            } catch (error) {
                console.error('Ошибка проверки бана:', error);
                return null;
            }
        }

        function showBanNotice(banData) {
            const banNotice = document.getElementById('banNotice');
            const banMessage = document.getElementById('banMessage');
            const banTimeRemaining = document.getElementById('banTimeRemaining');

            const bannedUntil = new Date(banData.banned_until);
            const isPermanent = bannedUntil.getFullYear() > 2050;

            if (isPermanent) {
                banMessage.textContent = 'Ваш аккаунт заблокирован навсегда за нарушение правил.';
                banTimeRemaining.textContent = '';
            } else {
                banMessage.textContent = 'Ваш аккаунт временно заблокирован за нарушение правил.';
                updateBanTimer(bannedUntil);
            }

            banNotice.classList.add('active');
            
            // Скрываем экран приветствия если он показан
            document.getElementById('splashScreen').classList.add('hidden');
        }

        function updateBanTimer(bannedUntil) {
            const banTimeRemaining = document.getElementById('banTimeRemaining');

            function update() {
                const now = new Date();
                const diff = bannedUntil - now;

                if (diff <= 0) {
                    banTimeRemaining.textContent = 'Бан истек. Перезагрузите страницу.';
                    setTimeout(() => location.reload(), 2000);
                    return;
                }

                const hours = Math.floor(diff / (1000 * 60 * 60));
                const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((diff % (1000 * 60)) / 1000);

                banTimeRemaining.textContent = `Осталось: ${hours}ч ${minutes}м ${seconds}с`;
            }

            update();
            setInterval(update, 1000);
        }

        async function requestUnban() {
            const btn = document.getElementById('unbanRequestBtn');
            const status = document.getElementById('unbanStatus');

            btn.disabled = true;
            btn.textContent = '⏳ Отправка...';

            try {
                // Проверяем авторизацию
                const userIdNum = uid;
                if (!userIdNum) {
                    throw new Error('Не авторизован');
                }

                const userIdString = String(userIdNum);
                
                // Получаем имя пользователя - важна правильная переменная
                const driverName = currentDriver && currentDriver.name ? currentDriver.name : null;
                const telegramName = window.Telegram && window.Telegram.WebApp && window.Telegram.WebApp.initDataUnsafe && window.Telegram.WebApp.initDataUnsafe.user && window.Telegram.WebApp.initDataUnsafe.user.first_name ? window.Telegram.WebApp.initDataUnsafe.user.first_name : null;
                const fullName = driverName || telegramName || 'водитель';
                
                console.log('Начало: userIdString=' + userIdString + ', fullName=' + fullName);

                // Не создаем повторный pending-запрос
                const { data: pendingRequest, error: pendingError } = await _sb
                    .from('unban_requests')
                    .select('id,status,created_at')
                    .eq('user_id', userIdString)
                    .eq('status', 'pending')
                    .order('created_at', { ascending: false })
                    .maybeSingle();

                if (pendingError && pendingError.code !== 'PGRST116') {
                    throw pendingError;
                }

                if (pendingRequest) {
                    status.textContent = 'ℹ️ У вас уже есть активный запрос на разбан';
                    status.style.color = '#ff9500';
                    status.style.display = 'block';
                    btn.textContent = '⏳ Запрос уже отправлен';
                    btn.disabled = true;
                    return;
                }
                
                // Вставляем запрос
                const insertResult = await _sb.from('unban_requests').insert({
                    user_id: userIdString,
                    username: fullName,
                    status: 'pending',
                    created_at: new Date().toISOString()
                });

                if (insertResult.error) {
                    throw insertResult.error;
                }

                status.textContent = '✅ Запрос отправлен модераторам';
                status.style.color = '#28a745';
                status.style.display = 'block';
                btn.textContent = '✓ Запрос отправлен';
                btn.disabled = true;

            } catch (err) {
                console.error('requestUnban ошибка:', err);
                
                let msg = '❌ Ошибка отправки запроса';
                if (err && err.message) {
                    msg = '❌ ' + err.message.substring(0, 80);
                }
                
                status.textContent = msg;
                status.style.color = '#dc3545';
                status.style.display = 'block';
                btn.disabled = false;
                btn.textContent = '📨 Подать запрос на разбан';
            }
        }

        // ============= ИНИЦИАЛИЗАЦИЯ С ПРОВЕРКОЙ БАНА =============
        // Эта логика теперь интегрирована в ymaps.ready() выше


</script>

    <!-- Кнопка открытия нижнего виджета (появляется когда он закрыт) -->
    <button id="openActionBtn" class="open-action-btn" onclick="toggleActionCard()">▲</button>

    <script>
        // Вспомогательная функция для запуска из консоли браузера
        console.log('%c🎤 EASY RIDE 180 - Озвучка', 'font-size:16px;font-weight:bold;color:#007aff');
        console.log('%cДля загрузки MP3 озвучки, выполните в консоли:\nuploadCustomWarningAudios()', 'font-size:13px;color:#666');
        window.quickUploadAudio = async function() {
            console.log('⏳ Запускаем загрузку MP3 озвучки...');
            if (typeof uploadCustomWarningAudios === 'function') {
                await uploadCustomWarningAudios();
            } else {
                console.error('❌ Функция uploadCustomWarningAudios не найдена');
            }
        };
        console.log('%cИЛИ нажмите эту ссылку:\n', 'font-size:13px;color:#999');
        console.log('%c[ЗАГРУЗИТЬ ОЗВУЧКУ]', 'font-size:14px;cursor:pointer;color:#007aff;text-decoration:underline;background:#f0f0f0;padding:8px 16px;border-radius:6px');
    </script>
</body>
</html>
