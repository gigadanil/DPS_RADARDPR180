// @ts-nocheck
import { serve } from "https://deno.land/std@0.224.0/http/server.ts";

const TELEGRAM_HELP_BOT_TOKEN = (Deno.env.get("TELEGRAM_HELP_BOT_TOKEN") || "").trim();
const SUPABASE_URL = (Deno.env.get("SUPABASE_URL") || "").trim();
const SUPABASE_SERVICE_ROLE_KEY = (Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") || Deno.env.get("SERVICE_ROLE_KEY") || "").trim();
const MINIAPP_URL = (Deno.env.get("MINIAPP_URL") || "https://t.me/DPSRADARDPR180bot").trim();

function corsHeaders() {
  return {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Headers": "content-type, authorization",
    "Access-Control-Allow-Methods": "POST, OPTIONS",
    "Content-Type": "application/json"
  };
}

function jsonResponse(body: Record<string, unknown>, status = 200) {
  return new Response(JSON.stringify(body), { status, headers: corsHeaders() });
}

function base64UrlToUint8Array(input: string): Uint8Array {
  const padded = input.replace(/-/g, "+").replace(/_/g, "/") + "===".slice((input.length + 3) % 4);
  const raw = atob(padded);
  const out = new Uint8Array(raw.length);
  for (let i = 0; i < raw.length; i++) out[i] = raw.charCodeAt(i);
  return out;
}

function decodeJwtSub(token: string): string | null {
  try {
    const parts = token.split(".");
    if (parts.length !== 3) return null;
    const payloadB64 = parts[1];

    const payloadJson = new TextDecoder().decode(base64UrlToUint8Array(payloadB64));
    const payload = JSON.parse(payloadJson);
    return String(payload?.sub || "") || null;
  } catch {
    return null;
  }
}

function toLabel(type: string): string {
  const labels: Record<string, string> = {
    sos: "SOS / –ù—É–∂–Ω–∞ –ø–æ–º–æ—â—å",
    dtp: "–î–¢–ü",
    danger: "–û–ø–∞—Å–Ω–æ—Å—Ç—å",
    traffic_jam: "–ü—Ä–æ–±–∫–∞ / –ó–∞—Ç–æ—Ä",
    works: "–î–æ—Ä–æ–∂–Ω—ã–µ —Ä–∞–±–æ—Ç—ã"
  };
  return labels[type] || "–î–æ—Ä–æ–∂–Ω–æ–µ —Å–æ–±—ã—Ç–∏–µ";
}

function haversineKm(lat1: number, lon1: number, lat2: number, lon2: number): number {
  const R = 6371;
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = Math.sin(dLat / 2) ** 2 +
    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
    Math.sin(dLon / 2) ** 2;
  return 2 * R * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}

serve(async (req) => {
  if (req.method === "OPTIONS") return new Response(null, { status: 204, headers: corsHeaders() });
  if (req.method !== "POST") return jsonResponse({ error: "Method Not Allowed" }, 405);

  if (!TELEGRAM_HELP_BOT_TOKEN || !SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY) {
    return jsonResponse({ error: "Missing env config" }, 500);
  }

  const auth = req.headers.get("authorization") || "";
  const token = auth.startsWith("Bearer ") ? auth.slice(7).trim() : "";
  const sub = token ? decodeJwtSub(token) : null;
  if (!sub) return jsonResponse({ error: "Unauthorized" }, 401);

  let body: any = null;
  try {
    body = await req.json();
  } catch {
    return jsonResponse({ error: "Invalid JSON" }, 400);
  }

  const markerId = Number(body?.markerId || 0);
  const type = String(body?.type || "");
  const comment = String(body?.comment || "").trim();
  const driverName = String(body?.driverName || "–í–æ–¥–∏—Ç–µ–ª—å");
  const driverRank = String(body?.driverRank || "–£—á–∞—Å—Ç–Ω–∏–∫");
  const placeText = String(body?.placeText || "").trim();
  const lat = Number(body?.lat);
  const lon = Number(body?.lon);

  const helpTypes = new Set(["sos", "dtp", "danger", "traffic_jam", "works"]);
  if (!helpTypes.has(type)) {
    return jsonResponse({ ok: true, skipped: true, reason: "not-help-type" });
  }

  const bypassRadiusForSos = true;

  const q = new URL(`${SUPABASE_URL}/rest/v1/telegram_help_subscribers`);
  q.searchParams.set("select", "chat_id,is_active,radius_km,home_lat,home_lon");
  q.searchParams.set("is_active", "eq.true");

  const subscribersResp = await fetch(q.toString(), {
    headers: {
      apikey: SUPABASE_SERVICE_ROLE_KEY,
      Authorization: `Bearer ${SUPABASE_SERVICE_ROLE_KEY}`
    }
  });

  if (!subscribersResp.ok) {
    return jsonResponse({ error: "Failed to load subscribers", status: subscribersResp.status }, 500);
  }

  const subscribers = await subscribersResp.json() as Array<{
    chat_id: string;
    is_active: boolean;
    radius_km?: number | null;
    home_lat?: number | null;
    home_lon?: number | null;
  }>;

  const title = "üì¢ –í–ù–ò–ú–ê–ù–ò–ï: –ù–£–ñ–ù–ê –ü–û–ú–û–©–¨!";
  const typeLabel = toLabel(type);
  const locationText = placeText || (Number.isFinite(lat) && Number.isFinite(lon)
    ? `${lat.toFixed(5)}, ${lon.toFixed(5)}`
    : "–Ω–µ —É–∫–∞–∑–∞–Ω–æ");
  const mapUrl = Number.isFinite(lat) && Number.isFinite(lon)
    ? `${MINIAPP_URL}${MINIAPP_URL.includes("?") ? "&" : "?"}marker_id=${encodeURIComponent(String(markerId))}&lat=${encodeURIComponent(String(lat))}&lon=${encodeURIComponent(String(lon))}`
    : MINIAPP_URL;

  const text = [
    title,
    `üìç –ú–µ—Å—Ç–æ: ${locationText}`,
    `üõ† –¢–∏–ø: ${typeLabel}${comment ? ` / ${comment}` : ""}`,
    `üë§ –í–æ–¥–∏—Ç–µ–ª—å: ${driverName} (${driverRank})`
  ].join("\n");

  let sent = 0;
  let skippedByRadius = 0;
  let failed = 0;
  const errors: Array<{ chat_id: string; status: number; body: string }> = [];
  for (const s of subscribers) {
    const chatId = String(s.chat_id || "").trim();
    if (!chatId) continue;

    if (
      Number.isFinite(lat) && Number.isFinite(lon) &&
      Number.isFinite(Number(s.home_lat)) && Number.isFinite(Number(s.home_lon))
    ) {
      if (type === "sos" && bypassRadiusForSos) {
        // –î–ª—è SOS –≤—Å–µ–≥–¥–∞ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º, –¥–∞–∂–µ –µ—Å–ª–∏ –ø–æ–¥–ø–∏—Å—á–∏–∫ –≤–Ω–µ –∑–∞–¥–∞–Ω–Ω–æ–≥–æ —Ä–∞–¥–∏—É—Å–∞
      } else {
      const radius = Number(s.radius_km || 10);
      const distance = haversineKm(Number(lat), Number(lon), Number(s.home_lat), Number(s.home_lon));
      if (distance > radius) {
        skippedByRadius += 1;
        continue;
      }
      }
    }

    const tgResp = await fetch(`https://api.telegram.org/bot${TELEGRAM_HELP_BOT_TOKEN}/sendMessage`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        chat_id: chatId,
        text,
        reply_markup: {
          inline_keyboard: [[
            { text: "üìç –ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å –Ω–∞ –∫–∞—Ä—Ç–µ", url: mapUrl }
          ]]
        },
        disable_web_page_preview: true
      })
    });

    if (tgResp.ok) {
      sent += 1;
    } else {
      failed += 1;
      let errBody = "";
      try { errBody = await tgResp.text(); } catch { errBody = ""; }
      errors.push({ chat_id: chatId, status: tgResp.status, body: errBody.slice(0, 300) });
    }
  }

  return jsonResponse({
    ok: true,
    sent,
    failed,
    skippedByRadius,
    subscribersCount: subscribers.length,
    markerId,
    type,
    errors
  });
});
